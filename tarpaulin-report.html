<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","carson","projects","aglet","aglet","src","commands","mod.rs"],"content":"pub mod regex;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet","src","commands","regex.rs"],"content":"use std::path::PathBuf;\n\nuse aglet_pretty::{ColorWhen, PrettyPrintSettings, PrettyPrinter};\nuse aglet_regex::{Parser, Tokenizer};\nuse aglet_text::SourceFile;\nuse clap::Args;\nuse colored::control::ShouldColorize;\nuse colored::Colorize;\nuse eyre::{eyre, Result};\nuse itertools::Itertools;\n\nuse crate::{CliInput, Input};\n\n#[derive(Debug, Args)]\npub struct RegexArgs {\n    /// Print the token stream\n    #[arg(short, long)]\n    tokens: bool,\n\n    /// Print the resulting abstract syntax tree\n    #[arg(short, long)]\n    ast: bool,\n\n    /// Display the span of each token or AST node\n    #[arg(short, long)]\n    spans: bool,\n\n    /// Include metadata column for each token or AST node\n    #[arg(short, long)]\n    meta: bool,\n\n    /// Remove alignment spacing in the spans column\n    #[arg(long)]\n    no_align: bool,\n\n    /// Disable colour output\n    #[arg(long)]\n    no_color: bool,\n\n    /// Force color output\n    #[arg(long)]\n    force_color: bool,\n\n    /// Use test mode - generate test output or test input data.\n    ///\n    /// Implies --no_color, --no_align, --ast, and --tokens\n    #[arg(short = 'T', long)]\n    test: bool,\n\n    /// Output file\n    #[arg(short, long)]\n    out: Option\u003cPathBuf\u003e,\n}\n\npub fn run(input: Input, args: RegexArgs) -\u003e Result\u003c()\u003e {\n    let is_stdin = input.is_stdin();\n    let iter = SectionIterator::new(Box::new(input), !is_stdin);\n\n    let color_supported = ShouldColorize::from_env().should_colorize();\n    let color_when = match (color_supported, args.no_color, args.force_color) {\n        (true, false, false) =\u003e ColorWhen::Auto,\n        (_, _, true) =\u003e ColorWhen::Always,\n        _ =\u003e ColorWhen::Never,\n    };\n    let printer_settings = PrettyPrintSettings::default()\n        .indent(\"\\u{254E}   \".bright_black().to_string().as_ref())\n        .color_when(color_when)\n        .align(!args.no_align)\n        .include_spans(args.spans);\n\n    if is_stdin \u0026\u0026 (!args.tokens \u0026\u0026 !args.ast) {\n        println!(\"Warning: no output options used (try --ast or --tokens)\");\n    }\n\n    for section in iter {\n        let section = section?;\n        let printer_settings = printer_settings.clone().source(section.source.clone());\n        run_section(\u0026section, \u0026printer_settings, is_stdin, \u0026args)?;\n    }\n\n    Ok(())\n}\n\nfn run_section(\n    section: \u0026InputSection,\n    printer_settings: \u0026PrettyPrintSettings,\n    is_stdin: bool,\n    args: \u0026RegexArgs,\n) -\u003e Result\u003c()\u003e {\n    if !is_stdin {\n        println!(\"{}\\n\", section.source.src);\n    }\n\n    if args.tokens {\n        print_tokens(section, printer_settings.clone(), args)?;\n    }\n\n    if args.ast {\n        print_ast(section, printer_settings.clone())?;\n    }\n\n    Ok(())\n}\n\nfn print_tokens(\n    section: \u0026InputSection,\n    printer_settings: PrettyPrintSettings,\n    args: \u0026RegexArgs,\n) -\u003e Result\u003c()\u003e {\n    let mut printer = PrettyPrinter::new(printer_settings);\n\n    let tokenizer = Tokenizer::new(section.source.src.as_ref());\n    if args.meta {\n        for token_stack in tokenizer.into_token_stack_iter() {\n            match token_stack {\n                Ok(stack) =\u003e {\n                    printer.print(\u0026stack)?;\n                },\n                Err(stack_error) =\u003e {\n                    printer.print(\u0026stack_error)?;\n                },\n            }\n        }\n    } else {\n        for token in tokenizer {\n            match token {\n                Ok(tok) =\u003e {\n                    printer.print(\u0026tok)?;\n                },\n                Err(e) =\u003e {\n                    printer.print(\u0026e)?;\n                },\n            }\n        }\n    }\n\n    println!(\"TOKENS:\\n{}\\n\", printer.finish()?);\n\n    Ok(())\n}\n\nfn print_ast(section: \u0026InputSection, printer_settings: PrettyPrintSettings) -\u003e Result\u003c()\u003e {\n    let mut printer = PrettyPrinter::new(printer_settings);\n\n    let tokens = Tokenizer::new(section.source.src.as_ref()).collect_vec();\n    let parse_result = Parser::new(tokens.into_iter()).parse();\n    println!(\"AST:\\n{}\\n\", printer.print(\u0026parse_result.ast)?.finish()?);\n    if parse_result.errors.len() \u003e 0 {\n        println!(\n            \"PARSE ERR:\\n{}\\n\",\n            parse_result.errors.into_iter().join(\"\\n\")\n        );\n    }\n\n    Ok(())\n}\n\nstruct InputSection {\n    source: SourceFile,\n    tests:  Vec\u003cTestKind\u003e,\n}\n\nenum TestKind {\n    TokenTest(String),\n    AstTest(String),\n}\n\nstruct SectionIterator {\n    input:        CliInput,\n    last_section: Option\u003cInputSection\u003e,\n    allow_tests:  bool,\n}\n\nimpl SectionIterator {\n    fn new(input: CliInput, allow_tests: bool) -\u003e Self {\n        Self {\n            input: condense_input(input),\n            last_section: None,\n            allow_tests,\n        }\n    }\n\n    fn next_section(\u0026mut self) -\u003e Result\u003cOption\u003cInputSection\u003e\u003e {\n        loop {\n            let data = self.next_block()?;\n\n            if data.len() == 0 {\n                return Ok(self.last_section.take());\n            }\n\n            let header = data[0].to_lowercase();\n            if self.allow_tests \u0026\u0026 header.starts_with(\"token\") {\n                self.add_test(TestKind::TokenTest(data[1..].join(\"\\n\")))?;\n            } else if self.allow_tests \u0026\u0026 header.starts_with(\"ast\") {\n                self.add_test(TestKind::AstTest(data[1..].join(\"\\n\")))?;\n            } else {\n                let section = self.start_section(data.join(\"\\n\"));\n                if section.is_some() {\n                    return Ok(section);\n                }\n                if !self.allow_tests {\n                    return Ok(self.last_section.take());\n                }\n            }\n        }\n    }\n\n    fn next_block(\u0026mut self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let data = self\n            .input\n            .by_ref()\n            .take_while(|line| match line {\n                Ok(line) =\u003e line.len() \u003e 0,\n                _ =\u003e true,\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        Ok(data)\n    }\n\n    fn add_test(\u0026mut self, test: TestKind) -\u003e Result\u003c()\u003e {\n        let Some(section) = \u0026mut self.last_section else {\n            return Err(eyre!(\"no section for test\"));\n        };\n\n        section.tests.push(test);\n        Ok(())\n    }\n\n    fn start_section(\u0026mut self, input: String) -\u003e Option\u003cInputSection\u003e {\n        self.last_section.replace(InputSection {\n            source: SourceFile::new_from_source(\"\".to_string(), \"\u003cstdin\u003e\".to_string(), input),\n            tests:  Vec::new(),\n        })\n    }\n}\n\nimpl Iterator for SectionIterator {\n    type Item = Result\u003cInputSection\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        match self.next_section() {\n            Ok(Some(section)) =\u003e Some(Ok(section)),\n            Ok(None) =\u003e None,\n            Err(err) =\u003e Some(Err(err)),\n        }\n    }\n}\n\nfn condense_input(input: CliInput) -\u003e CliInput {\n    let input = input\n        .scan(None, |last_len: \u0026mut Option\u003cusize\u003e, item| {\n            match (item, *last_len) {\n                (Ok(line), Some(len)) =\u003e {\n                    let should_filter = line.len() == 0 \u0026\u0026 len == 0;\n                    *last_len = Some(line.len());\n                    Some((should_filter, Ok(line)))\n                },\n                (Ok(line), None) =\u003e {\n                    *last_len = Some(line.len());\n                    Some((false, Ok(line)))\n                },\n                (res, _) =\u003e {\n                    *last_len = None;\n                    Some((false, res))\n                },\n            }\n        })\n        .filter_map(|(should_filter, item)| if should_filter { None } else { Some(item) });\n\n    Box::new(input)\n}\n\n#[cfg(test)]\nmod tests {\n    use itertools::Itertools;\n\n    use super::*;\n\n    #[test]\n    fn test_condense_input() {\n        let input = vec![\n            Ok(\"line 1\".to_string()),\n            Ok(\"line 2\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"line 3\".to_string()),\n            Ok(\"line 4\".to_string()),\n            Err(eyre!(\"err 1\")),\n            Err(eyre!(\"err 2\")),\n            Ok(\"\".to_string()),\n            Err(eyre!(\"err 3\")),\n            Ok(\"\".to_string()),\n            Ok(\"\".to_string()),\n        ]\n        .into_iter();\n\n        let expected = vec![\n            Ok(\"line 1\".to_string()),\n            Ok(\"line 2\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"line 3\".to_string()),\n            Ok(\"line 4\".to_string()),\n            Err(eyre!(\"err 1\")),\n            Err(eyre!(\"err 2\")),\n            Ok(\"\".to_string()),\n            Err(eyre!(\"err 3\")),\n            Ok(\"\".to_string()),\n        ];\n\n        let actual = condense_input(Box::new(input)).collect_vec();\n        assert_eq!(expected.len(), actual.len());\n\n        for (expected, actual) in expected.into_iter().zip(actual) {\n            if let (Ok(expected), Ok(actual)) = (\u0026expected, \u0026actual) {\n                assert_eq!(expected, actual);\n            } else if let (Err(expected), Err(actual)) = (\u0026expected, \u0026actual) {\n                assert_eq!(expected.to_string(), actual.to_string());\n            } else {\n                panic!(\"can't compare {:?} and {:?}\", expected, actual);\n            }\n        }\n    }\n\n    #[test]\n    fn test_input_iter() {\n        let input = vec![\n            \"abc\",\n            \"def\",\n            \"\",\n            \"\",\n            \"TOKENS:\",\n            \"token test\",\n            \"data\",\n            \"\",\n            \"ghi\",\n            \"jkl\",\n            \"\",\n            \"TOKENS ===\",\n            \"\",\n            \"AST ===\",\n            \"ast data\",\n        ]\n        .into_iter()\n        .map(|line| Ok(line.to_string()) as Result\u003cString\u003e);\n\n        let mut iter = SectionIterator::new(Box::new(input), true);\n\n        let section = iter.next().unwrap().unwrap();\n        assert_eq!(section.source.src, \"abc\\ndef\".to_string());\n        assert_eq!(section.tests.len(), 1);\n        assert!(matches!(section.tests[0], TestKind::TokenTest(_)));\n        let TestKind::TokenTest(data) = \u0026section.tests[0] else {\n            panic!(\"not a token test\");\n        };\n        assert_eq!(data, \"token test\\ndata\");\n\n        let section = iter.next().unwrap().unwrap();\n        assert_eq!(section.source.src, \"ghi\\njkl\");\n        assert_eq!(section.tests.len(), 2);\n        assert!(matches!(section.tests[0], TestKind::TokenTest(_)));\n        let TestKind::TokenTest(data) = \u0026section.tests[0] else {\n            panic!(\"not a token test\");\n        };\n        assert_eq!(data, \"\");\n        assert!(matches!(section.tests[1], TestKind::AstTest(_)));\n        let TestKind::AstTest(data) = \u0026section.tests[1] else {\n            panic!(\"not an ast test\");\n        };\n        assert_eq!(data, \"ast data\");\n\n        let section = iter.next();\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn test_input_iter_no_tests() {\n        let input = vec![\"abc\", \"def\", \"\"]\n            .into_iter()\n            .map(|line| Ok(line.to_string()) as Result\u003cString\u003e);\n\n        let mut iter = SectionIterator::new(Box::new(input), false);\n        let section = iter.next();\n        assert!(section.is_some());\n\n        let input = vec![\n            \"abc\",\n            \"def\",\n            \"\",\n            \"TOKENS:\",\n            \"misinterpreted\",\n            \"test data\",\n            \"\",\n        ]\n        .into_iter()\n        .map(|line| Ok(line.to_string()));\n\n        let mut iter = SectionIterator::new(Box::new(input), false);\n\n        let section = iter.next();\n        assert!(section.is_some());\n        let Some(Ok(section)) = section else {\n            panic!(\"error reading section\");\n        };\n        assert_eq!(section.source.src, \"abc\\ndef\".to_string());\n        assert_eq!(section.tests.len(), 0);\n\n        let section = iter.next();\n        assert!(section.is_some());\n        let Some(Ok(section)) = section else {\n            panic!(\"error reading section\");\n        };\n        assert_eq!(section.source.src, \"TOKENS:\\nmisinterpreted\\ntest data\");\n        assert_eq!(section.tests.len(), 0);\n\n        let section = iter.next();\n        assert!(section.is_none());\n    }\n}\n","traces":[{"line":55,"address":[555819,553216,555670],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":56,"address":[553350,553233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[553532,553360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[553570,553630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[553695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[553772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[553809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[553799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[554089,553780,554216,554177,554046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[554081,555757,553819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[554173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[554243,554124,555779,554212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[554444,554370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[554461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[554376,555663,554512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[554883,554774,555708,555195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[555188,555273,555681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[555616,555402,555485,555558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[554781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[555856],"length":1,"stats":{"Line":0},"fn_name":"run_section"},{"line":90,"address":[555915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[555924,555983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[556041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[556064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[556051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[555879,556180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[556164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[557111,558605,556304],"length":1,"stats":{"Line":0},"fn_name":"print_tokens"},{"line":110,"address":[556340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[556365,556460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[556472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[556501,557352,558390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[557530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[557976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[558339,558072,558247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[558087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[558183,558461,558553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[557089,556531,556494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[556699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[556742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[556806,556946,557038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[556818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[556882,557171,557263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[556324,557566,557745,557963,556712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[557916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[559975,560084,558624],"length":1,"stats":{"Line":0},"fn_name":"print_ast"},{"line":143,"address":[558644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[558671,558751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[558797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[559991,558636,558862,558936,559242,560020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[559421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[559687,559581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[559475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[559444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[560112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[560184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[560272,561582,562068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[560311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[560327,560489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[560574,560454],"length":1,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[560588,560649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[560607,560713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[560905,560779,560822],"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[560945,561823,562047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[561037,560796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[561603,560303,561101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[561000,561166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[561245,561300],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[561325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[561314],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[561414,561456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[562096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[562128,562279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[546240,546258],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":213,"address":[546286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[546311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[562236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[562560,562304,562587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[562324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[562427,562504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[562389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[562482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[562608,563108,563141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[562637,562973],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[562737,562670,563119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[562912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[563184],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":242,"address":[563208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[563339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[563330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[563258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[563456],"length":1,"stats":{"Line":1},"fn_name":"condense_input"},{"line":251,"address":[563488],"length":1,"stats":{"Line":3},"fn_name":null},{"line":252,"address":[547116,546336,547524],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":253,"address":[546387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[546735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[547205,546781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[547247],"length":1,"stats":{"Line":3},"fn_name":null},{"line":257,"address":[547317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[546689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[546723,546855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[546898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[546499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[546546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[546581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[547632,547650],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"}],"covered":49,"coverable":106},{"path":["/","home","carson","projects","aglet","aglet","src","lib.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet","src","main.rs"],"content":"mod commands;\n\nuse std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::PathBuf;\n\nuse clap::{Parser, Subcommand};\nuse commands::regex::RegexArgs;\nuse eyre::Result;\n\n#[derive(Parser, Debug)]\n#[command(name = \"aglet\")]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n\n    /// Input file. Uses stdin if omitted\n    #[arg(short, long)]\n    input: Option\u003cPathBuf\u003e,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Tools for inspecting and debugging regular expressions\n    #[command(name = \"regex\")]\n    Regex(RegexArgs),\n}\n\ntype CliInput = Box\u003cdyn Iterator\u003cItem = Result\u003cString\u003e\u003e\u003e;\n\nfn main() -\u003e Result\u003c()\u003e {\n    color_eyre::install()?;\n\n    let args = Cli::parse();\n\n    let input = Input::new(args.input)?;\n    match args.command {\n        Commands::Regex(args) =\u003e commands::regex::run(input, args),\n    }?;\n\n    Ok(())\n}\n\npub struct Input {\n    input:    CliInput,\n    filename: String,\n    is_stdin: bool,\n}\n\nimpl Input {\n    pub fn new(input_path: Option\u003cPathBuf\u003e) -\u003e Result\u003cSelf\u003e {\n        let input = if let Some(input_path) = input_path {\n            let file = File::open(input_path.clone())?;\n            let iter = io::BufReader::new(file)\n                .lines()\n                .map(|res| res.map_err(|err| err.into()));\n\n            Self {\n                input:    Box::new(iter) as CliInput,\n                filename: input_path.to_string_lossy().to_string(),\n                is_stdin: false,\n            }\n        } else {\n            let iter = std::io::stdin()\n                .lines()\n                .map(|res| res.map_err(|err| err.into()));\n\n            Self {\n                input:    Box::new(iter) as CliInput,\n                filename: \"\u003cstdin\u003e\".to_string(),\n                is_stdin: true,\n            }\n        };\n\n        Ok(input)\n    }\n\n    #[inline]\n    pub fn is_stdin(\u0026self) -\u003e bool {\n        self.is_stdin\n    }\n\n    #[inline]\n    pub fn filename(\u0026self) -\u003e \u0026str {\n        \u0026self.filename\n    }\n}\n\nimpl Iterator for Input {\n    type Item = Result\u003cString\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.input.next()\n    }\n}\n","traces":[{"line":32,"address":[643216,642432,643167],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":33,"address":[642439,642567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[642500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[642911,643183,642518,642659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[643127,643092,642995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[642796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[643049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[644294,643248,644837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[644792,643270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[643456,643567,643370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[643528,643661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[638576,638624,638633,638604],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":60,"address":[643836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[643942,643867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[643377,644394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[638704,638684,638713,638656],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":70,"address":[644614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[644637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[644210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[644912],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":94,"address":[644929],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25},{"path":["/","home","carson","projects","aglet","aglet-derive","src","default_with_span.rs"],"content":"use proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{Data, DataStruct, DeriveInput, Ident, Type};\n\npub fn impl_default_with_span(input: DeriveInput) -\u003e TokenStream {\n    let type_name = input.ident;\n    if let Data::Struct(data) = input.data {\n        impl_for_struct(type_name, data)\n    } else if let Data::Enum(_) = input.data {\n        impl_with_no_span(type_name)\n    } else {\n        panic!(\"can only derive DefaultAst for structs and enums\");\n    }\n}\n\nfn impl_for_struct(type_name: Ident, data: DataStruct) -\u003e TokenStream {\n    if let Some((index, field)) = find_span_field(data.fields) {\n        if let Some(span_name) = field.ident {\n            impl_with_named_span(type_name, span_name)\n        } else {\n            impl_with_numbered_span(type_name, index)\n        }\n    } else {\n        impl_with_no_span(type_name)\n    }\n}\n\nfn find_span_field(fields: syn::Fields) -\u003e Option\u003c(usize, syn::Field)\u003e {\n    fields\n        .into_iter()\n        .enumerate()\n        .filter(|(_, field)| {\n            let is_named_span = field\n                .ident\n                .as_ref()\n                .map(|name| name == \"span\")\n                .unwrap_or_default();\n            let is_span_type = type_is_span(\u0026field.ty);\n\n            is_named_span || is_span_type\n        })\n        .next()\n}\n\nfn type_is_span(ty: \u0026Type) -\u003e bool {\n    let Type::Path(path) = ty else {\n        return false;\n    };\n\n    if path.path.is_ident(\"Span\") {\n        return true;\n    }\n\n    let Some(last_segment) = path.path.segments.last() else {\n        return false;\n    };\n\n    return last_segment.ident == \"Span\";\n}\n\nfn impl_with_named_span(type_name: Ident, span_name: Ident) -\u003e TokenStream {\n    let s = quote! {\n        impl aglet_text::DefaultWithSpan for #type_name {\n            fn default_with_span(span: aglet_text::Span) -\u003e Self {\n                let mut result: Self = core::default::Default::default();\n                result.#span_name = span;\n                result\n            }\n        }\n    };\n\n    s.into()\n}\n\nfn impl_with_numbered_span(type_name: Ident, index: usize) -\u003e TokenStream {\n    let s = quote! {\n        impl aglet_text::DefaultWithSpan for #type_name {\n            fn default_with_span(span: aglet_text::Span) -\u003e Self {\n                let mut result: Self = core::default::Default::default();\n                result.#index = span;\n                result\n            }\n        }\n    };\n\n    s.into()\n}\n\nfn impl_with_no_span(type_name: Ident) -\u003e TokenStream {\n    let s = quote! {\n        impl aglet_text::DefaultWithSpan for #type_name {\n            fn default_with_span(_: aglet_text::Span) -\u003e Self {\n                core::default::Default::default()\n            }\n        }\n    };\n\n    s.into()\n}\n","traces":[{"line":5,"address":[166625,165920],"length":1,"stats":{"Line":0},"fn_name":"impl_default_with_span"},{"line":6,"address":[165932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[166012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[166245,166102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[166165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[166370,166283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[166667,166336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[167777,168011,166880],"length":1,"stats":{"Line":0},"fn_name":"impl_for_struct"},{"line":17,"address":[167032,166892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[167124,167217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[167257,167423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[167325,167450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[167159,167923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[168048,168196],"length":1,"stats":{"Line":0},"fn_name":"find_span_field"},{"line":29,"address":[168064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[174816,174841],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":33,"address":[174855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[174969,174960],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":38,"address":[174898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[174920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[168224],"length":1,"stats":{"Line":0},"fn_name":"type_is_span"},{"line":46,"address":[168238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[168310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[168282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[168364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[168371,168321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[168406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[168381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[170046,168432],"length":1,"stats":{"Line":0},"fn_name":"impl_with_named_span"},{"line":62,"address":[168506,168449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[169958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[171640,170080],"length":1,"stats":{"Line":0},"fn_name":"impl_with_numbered_span"},{"line":76,"address":[170097,170154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[171606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[171680,172865],"length":1,"stats":{"Line":0},"fn_name":"impl_with_no_span"},{"line":90,"address":[171692,171749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[172831],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":37},{"path":["/","home","carson","projects","aglet","aglet-derive","src","lib.rs"],"content":"mod default_with_span;\n\nuse proc_macro::TokenStream;\nuse syn::{parse_macro_input, DeriveInput};\n\n#[proc_macro_derive(DefaultWithSpan)]\npub fn default_with_span(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    default_with_span::impl_default_with_span(input)\n}\n","traces":[{"line":7,"address":[174580,174549,174224],"length":1,"stats":{"Line":0},"fn_name":"default_with_span"},{"line":8,"address":[174425,174591,174240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[174386,174525],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","carson","projects","aglet","aglet-ingest","src","lib.rs"],"content":"mod position;\nmod span;\n\npub use position::Position;\npub use span::Span;\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-ingest","src","position.rs"],"content":"#[derive(Copy, Clone)]\npub struct Position {\n    pub idx: usize,\n    pub line: u32,\n    pub col: u32,\n}\n\nimpl Position {\n    pub fn new() -\u003e Self {\n        Position {\n            idx: 0,\n            line: 1,\n            col: 1,\n        }\n    }\n\n    pub fn set(\u0026mut self, other: Position) {\n        self.idx = other.idx;\n        self.line = other.line;\n        self.col = other.col;\n    }\n\n    pub fn advance(\u0026mut self, c: char) {\n        self.idx += 1;\n\n        if c == '\\n' {\n            self.line += 1;\n            self.col = 1;\n        } else {\n            self.col += 1;\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-ingest","src","span.rs"],"content":"use crate::position::Position;\n\npub struct Span\u003c'a\u003e {\n    pub text: \u0026'a str,\n    pub start: Position,\n    pub end: Position,\n}\n\nimpl \u003c'a\u003e Span\u003c'a\u003e {\n    pub fn new(text: \u0026'a str) -\u003e Self {\n        Span {\n            text,\n            start: Position::new(),\n            end: Position::new(),\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","ast_printer.rs"],"content":"use std::fmt::{self, Write};\n\nuse aglet_text::Span;\nuse colored::{Color, Colorize};\n\nuse crate::{Pretty, Result, Writer};\n\nconst DEFAULT_COLOR: Color = Color::White;\nconst PARAMETER_COLOR: Color = Color::TrueColor {\n    r: 150,\n    g: 150,\n    b: 150,\n};\n\n/// Printer for an abstract syntax tree\n///\n/// Tree nodes can be printed with properties and children, with children being\n/// printed indented as another node.\n///\n/// # Example\n///\n/// An alternation node with two literal children might be printed like this:\n///\n/// ```ast\n/// (Alternation\n///     (Literal value='a')\n///     (Literal value='b'))\n/// ```\npub struct AstPrinter\u003c'a, 'b: 'a\u003e {\n    writer: \u0026'a mut Writer\u003c'b\u003e,\n    result: Result,\n}\n\nimpl\u003c'a, 'b: 'a\u003e AstPrinter\u003c'a, 'b\u003e {\n    /// Begin printing an AST node - its name will be printed, and its span will be added\n    /// to the output at this stage.\n    ///\n    /// To keep spans aligned with their nodes, all children should either also be printed\n    /// with this printer, or the caller that adds the children needs to supply a span\n    /// (or `None`) for each child printed which isn't a node.\n    pub fn new(\n        writer: \u0026'a mut Writer\u003c'b\u003e,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e Self {\n        let result = Ok(()).and_then(|_| {\n            if writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(writer, \"({}\", name.color(color))?;\n            } else {\n                write!(writer, \"({}\", name)?;\n            }\n\n            Ok(())\n        });\n\n        writer.add_span(span);\n\n        AstPrinter { writer, result }\n    }\n\n    /// Add a property to the node.\n    ///\n    /// Properties are printed on the same line as the node, and can optionally be\n    /// prefixed with a name.\n    pub fn property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: \u0026impl fmt::Debug,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        self.result = self.result.and_then(|_| {\n            let name_text = if let Some(name) = name {\n                format!(\"{}=\", name)\n            } else {\n                String::new()\n            };\n\n            if self.writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(\n                    self.writer,\n                    \" {}{}\",\n                    name_text.color(PARAMETER_COLOR).italic(),\n                    format!(\"{:?}\", value).color(color)\n                )?;\n            } else {\n                write!(self.writer, \" {}{:?}\", name_text, value)?;\n            }\n\n            Ok(())\n        });\n\n        self\n    }\n\n    /// Maybe add a property to the node.\n    ///\n    /// The property will be added if `value` is not `None`. The property is printed\n    /// on the same line as the node and can be optionally prefixed with a name.\n    pub fn maybe_property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: Option\u003c\u0026impl fmt::Debug\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        if let Some(value) = value {\n            self.property(name, value, color)\n        } else {\n            self\n        }\n    }\n\n    /// Add a child to the node.\n    ///\n    /// The child will be recursively pretty printed at a higher level of indentation.\n    /// Children are printed on a new line and so should add a value to `w.spans`\n    /// and to `w.meta` if applicable.\n    pub fn child(\u0026mut self, name: Option\u003c\u0026str\u003e, item: \u0026impl Pretty) -\u003e \u0026mut Self {\n        self.result = self.result.and_then(|_| {\n            write!(self.writer, \"\\n\")?;\n\n            self.writer.level += 1;\n            if let Some(name) = name {\n                write!(self.writer, \"{}: \", name)?;\n            }\n\n            item.print(self.writer)?;\n            self.writer.level -= 1;\n\n            Ok(())\n        });\n\n        self\n    }\n\n    /// Add multiple children to the node\n    ///\n    /// Children will be recursively printed at a higher level of indentation.\n    /// Children are printed on a new line and so should use [`Writer.add_span()`][1]\n    /// and [`Writer.add_meta()`][2] if appliccable\n    ///\n    /// [1]: crate::writer::Writer::add_span\n    /// [2]: crate::writer::Writer::add_meta\n    pub fn children(\u0026mut self, items: \u0026Vec\u003cimpl Pretty\u003e) -\u003e \u0026mut Self {\n        for item in items {\n            self.child(None, item);\n        }\n\n        self\n    }\n\n    /// Finish the AST node.\n    ///\n    /// Writes the closing `)` of the node and returns the result of printing all of its\n    /// parts. If errors occurred, only the first will be returned (an no printing will have\n    /// taken place since it occurred).\n    pub fn finish(\u0026mut self) -\u003e Result {\n        self.result.and_then(|_| {\n            write!(self.writer, \")\")?;\n            Ok(())\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use aglet_text::Span;\n\n    use super::*;\n    use crate::{ColorWhen, PrettyPrintSettings, PrettyPrinter};\n\n    struct Expr {\n        kind: ExprKind,\n    }\n\n    impl Pretty for Expr {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            w.print(\u0026self.kind)\n        }\n    }\n\n    enum ExprKind {\n        Add(Add),\n        Number(Number),\n    }\n\n    impl Pretty for ExprKind {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            match self {\n                Self::Add(add) =\u003e w.print(add),\n                Self::Number(number) =\u003e w.print(number),\n            }\n        }\n    }\n\n    struct Add {\n        span:  Span,\n        left:  Box\u003cExpr\u003e,\n        right: Box\u003cExpr\u003e,\n    }\n\n    impl Pretty for Add {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            w.print_ast(\"Add\", Some(self.span), None)\n                .child(None, \u0026*self.left)\n                .child(None, \u0026*self.right)\n                .finish()\n        }\n    }\n\n    struct Number {\n        span:  Span,\n        value: i32,\n    }\n\n    impl Pretty for Number {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            w.print_ast(\"Number\", Some(self.span), None)\n                .property(Some(\"value\"), \u0026self.value, None)\n                .finish()\n        }\n    }\n\n    #[test]\n    fn print_ast() {\n        // 10 + -1 + 6\n        // 0   4   8\n        let expr = Expr {\n            kind: ExprKind::Add(Add {\n                span:  Span::new(0, 11),\n                left:  Box::new(Expr {\n                    kind: ExprKind::Add(Add {\n                        span:  Span::new(0, 7),\n                        left:  Box::new(Expr {\n                            kind: ExprKind::Number(Number {\n                                span:  Span::new(0, 2),\n                                value: 10,\n                            }),\n                        }),\n                        right: Box::new(Expr {\n                            kind: ExprKind::Number(Number {\n                                span:  Span::new(5, 7),\n                                value: -1,\n                            }),\n                        }),\n                    }),\n                }),\n                right: Box::new(Expr {\n                    kind: ExprKind::Number(Number {\n                        span:  Span::new(10, 11),\n                        value: 6,\n                    }),\n                }),\n            }),\n        };\n\n        let mut printer = PrettyPrinter::new(\n            PrettyPrintSettings::default()\n                .align(false)\n                .include_meta(false)\n                .color_when(ColorWhen::Never),\n        );\n\n        let expected = concat!(\n            \"0 - 11:\\t(Add\\n\",\n            \"0 - 7:\\t  (Add\\n\",\n            \"0 - 2:\\t    (Number value=10)\\n\",\n            \"5 - 7:\\t    (Number value=-1))\\n\",\n            \"10 - 11:\\t  (Number value=6))\"\n        );\n\n        let out = printer.print(\u0026expr).expect(\"print failed\").finish();\n        assert!(out.is_ok());\n        let out = out.unwrap();\n        assert_eq!(expected, out);\n    }\n}\n","traces":[{"line":41,"address":[172352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[183248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[352384,352704,352544,352224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":45},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","error.rs"],"content":"use std::fmt;\n\npub type Result = std::result::Result\u003c(), Error\u003e;\n\n#[derive(thiserror::Error, Debug, Clone, Copy)]\npub enum Error {\n    #[error(\"format error: {0}\")]\n    FormatError(#[from] fmt::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","lib.rs"],"content":"mod ast_printer;\nmod error;\nmod span_printer;\nmod token_printer;\nmod writer;\n\nuse std::{iter, result};\n\nuse aglet_text::{SourceFile, Span};\nuse ast_printer::AstPrinter;\nuse colored::control::ShouldColorize;\nuse colored::{Color, Colorize};\npub use error::*;\npub use span_printer::SpanPrinter;\nuse token_printer::TokenPrinter;\npub use writer::Writer;\n\nconst EXTRA_COLOR: Color = Color::TrueColor {\n    r: 150,\n    g: 150,\n    b: 150,\n};\n\n/// Pretty printer for parser data\n///\n/// The debug trait doesn't allow for pretty-printing outside of its struct,\n/// tuple, etc. printers. To print an AST without a lot of extraneous closing\n/// braces on their own lines, this separate pretty-printer provides the auto\n/// indentation for custom printers.\n///\n/// Printers can also supply text spans for each printed line, which will be\n/// displayed to the left of the main structure, as well as metadata which will\n/// be displayed to the right.\npub struct PrettyPrinter {\n    settings: PrettyPrintSettings,\n    main:     String,\n    spans:    Vec\u003cOption\u003cSpan\u003e\u003e,\n    meta:     Vec\u003cOption\u003cString\u003e\u003e,\n}\n\nimpl PrettyPrinter {\n    pub fn new(settings: PrettyPrintSettings) -\u003e Self {\n        let main = String::new();\n\n        Self {\n            settings,\n            main,\n            spans: Vec::new(),\n            meta: Vec::new(),\n        }\n    }\n\n    /// Print a pretty-printable structure\n    ///\n    /// The output string is kept internally until [`finish`](PrettyPrinter::finish) is\n    /// called, because while a nested structure like an AST only requires one call to\n    /// `print`, a list of structures like `tokens` requires many prints. Storing the\n    /// output as internal state across `print` invocations allows the printer to maintain\n    /// column widths until the entire dataset has been processed.\n    pub fn print(\u0026mut self, item: \u0026impl Pretty) -\u003e result::Result\u003c\u0026Self, Error\u003e {\n        let mut writer = Writer::new(\u0026mut self.main, \u0026mut self.spans, \u0026mut self.meta)\n            .with_indent(\u0026self.settings.indent);\n        match self.settings.color_when {\n            ColorWhen::Always =\u003e {\n                writer.use_color = true;\n            },\n            ColorWhen::Never =\u003e {\n                writer.use_color = false;\n            },\n            _ =\u003e (),\n        };\n\n        item.print(\u0026mut writer)?;\n\n        Ok(self)\n    }\n\n    /// Finish printing a dataset and return the formatted results\n    pub fn finish(\u0026self) -\u003e result::Result\u003cString, Error\u003e {\n        let use_color = match self.settings.color_when {\n            ColorWhen::Always =\u003e true,\n            ColorWhen::Auto =\u003e ShouldColorize::from_env().should_colorize(),\n            ColorWhen::Never =\u003e false,\n        };\n\n        // each span is transformed into a tuple of two formatted positions in order to\n        // align them in the output (`start` aligned to the left, `end` to the right,\n        // with the dash separating them in the center)\n        let span_lines = self\n            .spans\n            .iter()\n            .map(|maybe_span| {\n                maybe_span.as_ref().map(|span| {\n                    self.settings\n                        .source\n                        .as_ref()\n                        .and_then(|file| {\n                            let filename = file.filename.clone();\n                            let start = file.file_position_from_offset(\u0026span.start);\n                            let end = file.file_position_from_offset(\u0026span.end);\n\n                            start.and_then(|start| end.map(|end| (filename, start, end)))\n                        })\n                        .map(|(filename, start, end)| {\n                            (format!(\"{} {:?}\", filename, start), format!(\"{:?}\", end))\n                        })\n                        .unwrap_or_else(|| (format!(\"{:?}\", span.start), format!(\"{:?}\", span.end)))\n                })\n            })\n            // spans are optional, so chain them with a never-ending string of `None`\n            // so that the main output isn't cut short if they're missing\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // calculate the maximum width of the start and end spans to align the entire set\n        // to the same width\n        let (max_start, max_end) = if self.settings.align {\n            span_lines\n                .iter()\n                .fold((0, 0), |(acc_left, acc_right), line| {\n                    let (left, right) = line\n                        .as_ref()\n                        .map(|(l, r)| (l.len(), r.len()))\n                        .unwrap_or((acc_left, acc_right));\n                    (usize::max(left, acc_left), usize::max(right, acc_right))\n                })\n        } else {\n            // if the align setting is turned off, using 0 as a width has the same effect as\n            // not using alignment formatting at all\n            (0, 0)\n        };\n\n        // colored strings interfere with alignment, so the clean length (without any terminal\n        // color/style markers) of each line of the main column is added as context\n        let main_lines = self\n            .main\n            .lines()\n            .map(|line| (line, len_clean(line)))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let max_main = main_lines.iter().map(|(_, len)| *len).max().unwrap_or(0);\n\n        // span and meta lines are optional, so chain them with a neverending stream of `None`\n        // so they don't cut the output short if they're missing.\n        let span_lines = span_lines.into_iter().chain(iter::repeat(None));\n        let meta_lines = self.meta.iter().chain(iter::repeat(\u0026None));\n\n        Ok(main_lines\n            .into_iter()\n            .zip(span_lines)\n            .zip(meta_lines)\n            .map(|(((main, main_len), span), meta)| {\n                let span_column = if self.settings.include_spans {\n                    // format each span line into aligned columns. Terminal colors are added after\n                    // formatting, so the `{:\u003cmax_start$}` formatters are fine here (plus each\n                    // line is colored in the same way so they shouldn't interfere regardless)\n                    span.map(|(span_left, span_right)| {\n                        format!(\"{:\u003cmax_start$} - {:\u003emax_end$}:\\t\", span_left, span_right)\n                    })\n                    // colorize the span column if applicable\n                    .map(|span| {\n                        if use_color {\n                            span.color(EXTRA_COLOR).to_string()\n                        } else {\n                            span\n                        }\n                    })\n                    // account for lines with no span information\n                    .unwrap_or_else(|| {\n                        if self.settings.align {\n                            // if alignment is being used, output enough spaces to maintain\n                            // the column width (the max start and end width, plus 3 for \" - \")\n                            format!(\"{}:\\t\", \" \".repeat(max_start + max_end + 3))\n                        } else {\n                            String::new()\n                        }\n                    })\n                } else {\n                    String::new()\n                };\n\n                let main_column = if self.settings.include_meta {\n                    // Using `{:\u003cmax_main$}` doesn't account for the invisible formatting\n                    // characters, so the right number of spaces for alignment need to be\n                    // manually output for the main column data\n                    format!(\"{}{}\", main, \" \".repeat(max_main - main_len))\n                } else {\n                    main.to_string()\n                };\n\n                let meta_column = if self.settings.include_meta {\n                    meta.as_ref()\n                        .map(|meta| {\n                            if use_color {\n                                meta.color(EXTRA_COLOR).to_string()\n                            } else {\n                                meta.to_string()\n                            }\n                        })\n                        .unwrap_or_else(|| String::new())\n                } else {\n                    String::new()\n                };\n\n                // final output of all three columns. Some may be empty\n                format!(\"{}{}{}\", span_column, main_column, meta_column)\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\"))\n    }\n}\n\n/// Clean length of a string potentially containing terminal color markers\nfn len_clean(string: \u0026str) -\u003e usize {\n    enum State {\n        Count,\n        Match,\n        Filter,\n    }\n\n    let mut result = 0;\n    let mut state = State::Count;\n\n    // count each character not part of the terminal formatting syntax.\n    // terminal formatting is done with the sequence `\\x1b[`, a series of\n    // color/style options expressed as bytes, and `m`.\n    for c in string.chars() {\n        match state {\n            // count each character until the beginning of a format sequence `\\x1b` is\n            // encountered, and then switch to the match state to confirm the beginning\n            // of a sequence by finding `[`\n            State::Count =\u003e {\n                if c == '\\x1b' {\n                    state = State::Match;\n                    continue;\n                }\n\n                result += 1;\n            },\n            // the beginning of a format sequence `\\x1b` has been found, but unless it\n            // is immediately followed by `[` a format sequence has not been found; so\n            // either match it here or allow `\\x1b` to be counted. If a sequence has been\n            // found, switch to the filter state to ignore all characters in the sequence.\n            State::Match =\u003e {\n                if c == '[' {\n                    state = State::Filter;\n                    continue;\n                }\n\n                // count `\\x1b` and whatever was found after it\n                result += 2;\n            },\n            // ignore all bytes in a format sequence until the terminating byte `m`\n            // has been found\n            State::Filter =\u003e {\n                if c == 'm' {\n                    state = State::Count;\n                }\n            },\n        }\n    }\n\n    result\n}\n\n#[derive(Debug, Clone)]\npub struct PrettyPrintSettings {\n    source:        Option\u003cSourceFile\u003e,\n    align:         bool,\n    include_spans: bool,\n    include_meta:  bool,\n    color_when:    ColorWhen,\n    indent:        String,\n}\n\nimpl PrettyPrintSettings {\n    /// Add a source file to include line/column number information with spans\n    pub fn source(mut self, source: SourceFile) -\u003e Self {\n        self.source = Some(source);\n        self\n    }\n\n    /// Control whether the pretty printer should align its output columns\n    /// with extra spaces to ensure they line up visually.\n    pub fn align(mut self, value: bool) -\u003e Self {\n        self.align = value;\n        self\n    }\n\n    /// Control whether spans are printed in a column to the left of the main output\n    pub fn include_spans(mut self, value: bool) -\u003e Self {\n        self.include_spans = value;\n        self\n    }\n\n    /// Control whether optional metadata is printed in a column to the right of the main output\n    pub fn include_meta(mut self, value: bool) -\u003e Self {\n        self.include_meta = value;\n        self\n    }\n\n    /// Control whether output is printed in color\n    pub fn color_when(mut self, value: ColorWhen) -\u003e Self {\n        self.color_when = value;\n        self\n    }\n\n    /// Control how nested structures are indented in the output.\n    pub fn indent(mut self, value: \u0026str) -\u003e Self {\n        self.indent = value.to_string();\n        self\n    }\n}\n\nimpl Default for PrettyPrintSettings {\n    fn default() -\u003e Self {\n        Self {\n            source:        None,\n            align:         true,\n            include_spans: true,\n            include_meta:  true,\n            color_when:    ColorWhen::Auto,\n            indent:        \"  \".to_string(),\n        }\n    }\n}\n\n/// When to print output in color\n#[derive(Debug, Clone, Copy)]\npub enum ColorWhen {\n    /// Force output coloring\n    Always,\n\n    /// Use colored output when the terminal supports it, and/or delegate the decision to\n    /// the `CLICOLOR_FORCE`, `NO_COLOR`, and `CLICOLOR` environment variables\n    Auto,\n\n    // Turn off output colorin\n    Never,\n}\n\n/// Support pretty-printing\npub trait Pretty {\n    /// Pretty-print a value to a [`Writer`](crate::Writer)\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result;\n}\n","traces":[{"line":42,"address":[150880,151348,151374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[150901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[151096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[151155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[155856,156297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[156018,155895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[156051,156331,155943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[156059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[156120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[156112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[156130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[156122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[156243,156173,156280,155879,156101],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[156226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[153243,151408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[151447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[151521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[151531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[151583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[151638,151599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[151630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[156448,156392],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":94,"address":[156483,156513,156564],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[156608,156505,156919,156888],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":98,"address":[156651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[156690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[156757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[156944,157075,156787,157072,156955],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":104,"address":[157233,157949,157216],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":105,"address":[157518,157718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[158006,156556,158235,158071,157984],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":116,"address":[151696,151729,151770],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[151948,151739,151885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[151924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[158595,158547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[158704,158713],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":123,"address":[158585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[158639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[151705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[152048,151802],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[158800,158853],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":139,"address":[152117,152197],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[153295,152313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[152595,152523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[152681,153119,152872,153014],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[152744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[152918],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[159103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[159141,160880,162166,160913,159352,159426],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":156,"address":[161712,161204,161300,161944,161416],"length":1,"stats":{"Line":5},"fn_name":null},{"line":159,"address":[159340,162479,162192],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":160,"address":[162216,162273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[162356,162280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[162246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[162512,159391,163020],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":168,"address":[162534,163015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[162772,162563,162609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[162551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[159123,159301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[159311,160112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[159669,159840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[159469,159622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[159632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[160298,160140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[163056,163232,160286],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":192,"address":[163085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[163117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[163105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[163264,163276],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":200,"address":[160196,160125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[160616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[153344],"length":1,"stats":{"Line":1},"fn_name":"len_clean"},{"line":219,"address":[153358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[153367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[153448,153372,153492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[153460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[153583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[153498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[153534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[153588,153552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[153667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[153509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[153618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[153672,153636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[153520,153715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[153702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[153438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[153728,153962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[153758,153914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[153939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[154000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[154023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[154028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[154048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[154071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[154076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[154096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[154119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[154124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[154144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[154162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[154165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[154192,154417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[154252,154295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[154397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[154637,154448],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":321,"address":[154479],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":107},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","span_printer.rs"],"content":"pub trait SpanPrinter {\n    fn print_with_span(\u0026self, source: \u0026str);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","token_printer.rs"],"content":"use std::fmt::{self, Write};\n\nuse aglet_text::Span;\nuse colored::{Color, Colorize};\n\nuse crate::{Result, Writer};\n\nconst DEFAULT_COLOR: Color = Color::White;\nconst PARAMETER_COLOR: Color = Color::TrueColor {\n    r: 150,\n    g: 150,\n    b: 150,\n};\n\n///Printer for a tokenizer token\n///\n/// Tokens can optionally be printed with properties. They are printed all on one\n/// line, with no nesting components.\n///\n/// # Example\n///\n/// A literal token might be printed like this:\n///\n/// ```tok\n/// [Literal value='a']\n/// ```\npub struct TokenPrinter\u003c'a, 'b: 'a\u003e {\n    writer: \u0026'a mut Writer\u003c'b\u003e,\n    result: Result,\n}\n\nimpl\u003c'a, 'b: 'a\u003e TokenPrinter\u003c'a, 'b\u003e {\n    /// Begin printing the token = its name will be printed, and its span will be added\n    /// to the output at this stage. If the caller is printing the tokenizer's state stack\n    /// along with the token, it can be passed here as well and it will be printed\n    /// in the metadata column.\n    pub fn new(\n        writer: \u0026'a mut Writer\u003c'b\u003e,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        stack: Option\u003cString\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e Self {\n        let result = Ok(()).and_then(|_| {\n            if writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(writer, \"[{}\", name.color(color))?;\n            } else {\n                write!(writer, \"[{}\", name)?;\n            }\n\n            Ok(())\n        });\n\n        writer.add_span(span);\n        writer.add_meta(stack);\n\n        TokenPrinter { writer, result }\n    }\n\n    /// Add a property to the token.\n    ///\n    /// Properties can be optionally prefixed with a name\n    pub fn property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: \u0026impl fmt::Debug,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        self.result = self.result.and_then(|_| {\n            let name_text = if let Some(name) = name {\n                format!(\"{}=\", name)\n            } else {\n                String::new()\n            };\n\n            if self.writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(\n                    self.writer,\n                    \" {}{}\",\n                    name_text.color(PARAMETER_COLOR),\n                    format!(\"{:?}\", value).color(color)\n                )?;\n            } else {\n                write!(self.writer, \" {}{:?}\", name_text, value)?;\n            }\n\n            Ok(())\n        });\n\n        self\n    }\n\n    /// Maybe add a property to the token.\n    ///\n    /// The property will be added if `value` is not `None`. It can be optionally\n    /// prefixed with a property name.\n    pub fn maybe_property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: Option\u003c\u0026impl fmt::Debug\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        if let Some(value) = value {\n            self.property(name, value, color)\n        } else {\n            self\n        }\n    }\n\n    /// Finish printing the token\n    ///\n    /// Writes the closing `]` of the token and and returns the result of printing all of\n    /// its parts. If errors occurred, only the first will be returned (and no printing will\n    /// have taken place since it occurred).\n    pub fn finish(\u0026mut self) -\u003e Result {\n        self.result.and_then(|_| {\n            write!(self.writer, \"]\\n\")?;\n            Ok(())\n        })\n    }\n}\n","traces":[{"line":37,"address":[146321,145984,146294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[900492,899776],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":45,"address":[899788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[218800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[218862,219035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[219000,218606,218673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[218993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[146169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[146217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[567920,568176,567792,568304,568048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[567632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[146336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","writer.rs"],"content":"use std::fmt::{self, Write};\n\nuse aglet_text::Span;\nuse colored::control::ShouldColorize;\nuse colored::Color;\n\nuse crate::{AstPrinter, Pretty, Result, TokenPrinter};\n\n/// Writer for pretty-printing parser structures\n///\n/// The writer keeps track of the indentation of nested structures, as well as\n/// spans and metadata that should be reported along with the main output.\npub struct Writer\u003c'a\u003e {\n    buf:                  \u0026'a mut (dyn Write + 'a),\n    spans:                \u0026'a mut Vec\u003cOption\u003cSpan\u003e\u003e,\n    meta:                 \u0026'a mut Vec\u003cOption\u003cString\u003e\u003e,\n    on_newline:           bool,\n    indent:               String,\n    pub(crate) level:     u32,\n    pub(crate) use_color: bool,\n}\n\nimpl\u003c'a\u003e Writer\u003c'a\u003e {\n    pub fn new\u003cT\u003e(\n        buf: \u0026'a mut T,\n        spans: \u0026'a mut Vec\u003cOption\u003cSpan\u003e\u003e,\n        meta: \u0026'a mut Vec\u003cOption\u003cString\u003e\u003e,\n    ) -\u003e Self\n    where\n        T: Write + 'a,\n    {\n        Self {\n            buf,\n            spans,\n            meta,\n            on_newline: true,\n            indent: \"\\t\".to_string(),\n            level: 0,\n            use_color: ShouldColorize::from_env().should_colorize(),\n        }\n    }\n\n    /// Set the indentation style\n    ///\n    /// The provided string will be repeated by the number of indents\n    /// for any indented lines in the output\n    pub fn with_indent(mut self, indent: \u0026str) -\u003e Self {\n        self.indent = indent.to_string();\n        self\n    }\n\n    /// Print the indentation for the current level\n    pub fn print_indent(\u0026mut self) -\u003e fmt::Result {\n        for _ in 0..self.level {\n            self.buf.write_str(self.indent.as_str())?;\n        }\n\n        Ok(())\n    }\n\n    /// Create an printer for a nested abstract syntax tree structure.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - the display name of the AST node\n    /// * `span` - the text span of the node's origin in the input\n    /// * `color` - the color to print the node's name in\n    pub fn print_ast\u003c'b\u003e(\n        \u0026'b mut self,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e AstPrinter\u003c'b, 'a\u003e {\n        AstPrinter::new(self, name, span, color)\n    }\n\n    /// Create a printer for a token stream.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - the display name of the token\n    /// * `span` - the text span of the token's origin in the input\n    /// * `stack` - the state stack information when the token was produced\n    /// * `color` - the color to print the token's name in\n    pub fn print_token\u003c'b\u003e(\n        \u0026'b mut self,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        stack: Option\u003cString\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e TokenPrinter\u003c'b, 'a\u003e {\n        TokenPrinter::new(self, name, span, stack, color)\n    }\n\n    /// Pretty-print a structure\n    pub fn print(\u0026mut self, item: \u0026impl Pretty) -\u003e Result {\n        item.print(self)\n    }\n\n    /// Add a span to the output\n    pub fn add_span(\u0026mut self, span: Option\u003cSpan\u003e) {\n        self.spans.push(span);\n    }\n\n    /// Add a line of metadata to the output\n    pub fn add_meta(\u0026mut self, meta: Option\u003cString\u003e) {\n        self.meta.push(meta);\n    }\n}\n\nimpl Write for Writer\u003c'_\u003e {\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e fmt::Result {\n        for line in s.split_inclusive('\\n') {\n            if self.on_newline {\n                self.print_indent()?;\n            }\n\n            self.on_newline = line.ends_with('\\n');\n            self.buf.write_str(line)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":24,"address":[196376,196112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[850773,850544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[850753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[850814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[212126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[212256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[212336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[212367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[212480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[212496],"length":1,"stats":{"Line":1},"fn_name":"write_str"},{"line":113,"address":[212532,212660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[212701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[212830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[212735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[212767,212508,212905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[212648],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":23,"coverable":27},{"path":["/","home","carson","projects","aglet","aglet-regex","src","error.rs"],"content":"use crate::{parse, tokenize};\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"tokenizer error: {0}\")]\n    TokenizerError(#[from] tokenize::Error),\n\n    #[error(\"parser error: {0}\")]\n    ParserError(#[from] parse::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-regex","src","lib.rs"],"content":"pub mod error;\npub mod parse;\npub mod tokenize;\n\npub use error::Error;\npub use parse::ast::ParseResult;\npub use parse::Parser;\npub use tokenize::{Token, Tokenizer};\n\npub fn tokenize\u003cS: AsRef\u003cstr\u003e\u003e(input: \u0026str) -\u003e Result\u003cVec\u003cToken\u003e, tokenize::Error\u003e {\n    let tr = Tokenizer::new(input);\n    tr.collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n}\n\npub fn parse\u003cS: AsRef\u003cstr\u003e\u003e(input: \u0026str) -\u003e ParseResult {\n    let tr = Tokenizer::new(input);\n    let p = Parser::new(tr);\n    p.parse()\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","ast.rs"],"content":"use std::convert::TryFrom;\nuse std::default::Default;\n\nuse aglet_derive::DefaultWithSpan;\nuse aglet_text::Span;\n\nuse crate::parse::error;\nuse crate::tokenize::{self, TokenKind};\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct ParseResult {\n    pub ast:    Expr,\n    pub errors: Vec\u003cerror::Error\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Expr {\n    pub span: Span,\n    pub kind: ExprKind,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum ExprKind {\n    Alternation(Alternation),\n    Concatenation(Concatenation),\n    Repetition(Repetition),\n    Any,\n    Literal(char),\n    Digit(bool),\n    Whitespace(bool),\n    WordChar(bool),\n    Boundary(Boundary),\n    Group(Group),\n    Class(Class),\n    #[default]\n    Empty,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Alternation {\n    pub span:  Span,\n    pub items: Vec\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Concatenation {\n    pub span:  Span,\n    pub items: Vec\u003cExpr\u003e,\n}\n\n#[derive(Debug)]\npub struct Repetition {\n    pub span: Span,\n    pub kind: RepetitionKind,\n    pub item: Box\u003cExpr\u003e,\n}\n\n#[derive(Debug)]\npub enum RepetitionKind {\n    ZeroOrOne,\n    ZeroOrMore,\n    OneOrMore,\n    Range(Range),\n}\n\nimpl TryFrom\u003cTokenKind\u003e for RepetitionKind {\n    type Error = error::TokenConvertError;\n\n    fn try_from(value: TokenKind) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            TokenKind::Question =\u003e Ok(Self::ZeroOrOne),\n            TokenKind::Star =\u003e Ok(Self::ZeroOrMore),\n            TokenKind::Plus =\u003e Ok(Self::OneOrMore),\n            _ =\u003e Err(error::TokenConvertError::InvalidTokenForRepetition(value)),\n        }\n    }\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Range {\n    pub span:  Span,\n    pub start: Option\u003cusize\u003e,\n    pub end:   Option\u003cusize\u003e,\n}\n\n#[derive(Debug)]\npub struct Boundary {\n    pub span: Span,\n    pub kind: BoundaryKind,\n}\n\n#[derive(Debug)]\npub enum BoundaryKind {\n    StartOfLine,\n    EndOfLine,\n    StartOfText,\n    EndOfText,\n    WordBoundary,\n    NonWordBoundary,\n}\n\nimpl TryFrom\u003cTokenKind\u003e for BoundaryKind {\n    type Error = error::TokenConvertError;\n\n    fn try_from(value: TokenKind) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            TokenKind::StartOfLine =\u003e Ok(Self::StartOfLine),\n            TokenKind::EndOfLine =\u003e Ok(Self::EndOfLine),\n            TokenKind::StartOfText =\u003e Ok(Self::StartOfText),\n            TokenKind::EndOfText =\u003e Ok(Self::EndOfText),\n            TokenKind::WordBoundary =\u003e Ok(Self::WordBoundary),\n            TokenKind::NonWordBoundary =\u003e Ok(Self::NonWordBoundary),\n            _ =\u003e Err(error::TokenConvertError::InvalidTokenForBoundary(value)),\n        }\n    }\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Group {\n    pub span: Span,\n    pub kind: GroupKind,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum GroupKind {\n    Capturing(CapturingGroup),\n    Named(NamedGroup),\n    NonCapturing(NonCapturingGroup),\n    Flags(FlagGroup),\n    #[default]\n    Empty,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct CapturingGroup {\n    pub span:  Span,\n    pub index: usize,\n    pub expr:  Box\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct NamedGroup {\n    pub span: Span,\n    pub name: StringSpan,\n    pub expr: Box\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct NonCapturingGroup {\n    pub span:  Span,\n    pub flags: Option\u003cFlags\u003e,\n    pub expr:  Box\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct FlagGroup {\n    pub flags: Flags,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Flags {\n    pub span:        Span,\n    pub set_flags:   Vec\u003cFlagKind\u003e,\n    pub clear_flags: Vec\u003cFlagKind\u003e,\n}\n\n#[derive(Debug, PartialEq)]\npub enum FlagKind {\n    CaseInsensitive,\n    MultiLine,\n    DotMatchesNewline,\n    CRLFMode,\n    SwapGreed,\n    Unicode,\n    IgnoreWhitespace,\n}\n\nimpl From\u003ctokenize::Flag\u003e for FlagKind {\n    fn from(value: tokenize::Flag) -\u003e Self {\n        match value {\n            tokenize::Flag::CaseInsensitive =\u003e Self::CaseInsensitive,\n            tokenize::Flag::MultiLine =\u003e Self::MultiLine,\n            tokenize::Flag::DotMatchesNewline =\u003e Self::DotMatchesNewline,\n            tokenize::Flag::CRLFMode =\u003e Self::CRLFMode,\n            tokenize::Flag::SwapGreed =\u003e Self::SwapGreed,\n            tokenize::Flag::Unicode =\u003e Self::Unicode,\n            tokenize::Flag::IgnoreWhitespace =\u003e Self::IgnoreWhitespace,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Class {\n    pub span:    Span,\n    pub negated: bool,\n    pub kind:    ClassKind,\n}\n\n#[derive(Debug)]\npub enum ClassKind {\n    Unicode(UnicodeClass),\n    Specified(SpecifiedClass),\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct UnicodeClass {\n    pub span:  Span,\n    pub name:  Option\u003cStringSpan\u003e,\n    pub value: StringSpan,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct SpecifiedClass {\n    pub span:  Span,\n    pub items: Vec\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct ClassSpec {\n    pub span: Span,\n    pub kind: ClassSpecKind,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum ClassSpecKind {\n    Intersection(Intersection),\n    Difference(Difference),\n    Symmetrical(Symmetrical),\n    Literal(char),\n    Digit(bool),\n    Whitespace(bool),\n    WordChar(bool),\n    Range(char, char),\n    Posix(PosixClass),\n    Class(Class),\n    #[default]\n    Empty,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Intersection {\n    pub span:  Span,\n    pub left:  Box\u003cClassSpec\u003e,\n    pub right: Box\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Difference {\n    pub span:  Span,\n    pub left:  Box\u003cClassSpec\u003e,\n    pub right: Box\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Symmetrical {\n    pub span:  Span,\n    pub left:  Box\u003cClassSpec\u003e,\n    pub right: Box\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct PosixClass {\n    pub span:    Span,\n    pub kind:    PosixKind,\n    pub negated: bool,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum PosixKind {\n    AlNum,\n    Alpha,\n    Ascii,\n    Blank,\n    Cntrl,\n    Digit,\n    Graph,\n    Lower,\n    Print,\n    Punct,\n    Space,\n    Upper,\n    Word,\n    XDigit,\n    #[default]\n    Unknown,\n}\n\nimpl TryFrom\u003c\u0026str\u003e for PosixKind {\n    type Error = error::TokenConvertError;\n\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            \"alnum\" =\u003e Ok(Self::AlNum),\n            \"alpha\" =\u003e Ok(Self::Alpha),\n            \"ascii\" =\u003e Ok(Self::Ascii),\n            \"blank\" =\u003e Ok(Self::Blank),\n            \"cntrl\" =\u003e Ok(Self::Cntrl),\n            \"digit\" =\u003e Ok(Self::Digit),\n            \"graph\" =\u003e Ok(Self::Graph),\n            \"lower\" =\u003e Ok(Self::Lower),\n            \"print\" =\u003e Ok(Self::Print),\n            \"punct\" =\u003e Ok(Self::Punct),\n            \"space\" =\u003e Ok(Self::Space),\n            \"upper\" =\u003e Ok(Self::Upper),\n            \"word\" =\u003e Ok(Self::Word),\n            \"xdigit\" =\u003e Ok(Self::XDigit),\n            _ =\u003e Err(error::TokenConvertError::InvalidPosixClass(\n                value.to_string(),\n            )),\n        }\n    }\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct StringSpan {\n    pub span:  Span,\n    pub value: String,\n}\n","traces":[{"line":69,"address":[522624],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":70,"address":[522646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[522898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[522929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[522960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[522726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[523040],"length":1,"stats":{"Line":1},"fn_name":"try_from"},{"line":106,"address":[523058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[523230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[523259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[523285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[523311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[523337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[523363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[523116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[523424],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":180,"address":[523431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[523464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[523471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[523478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[523485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[523492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[523499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[523506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[523520],"length":1,"stats":{"Line":1},"fn_name":"try_from"},{"line":293,"address":[523635,523576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[523607,523697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[523669,523759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[523731,523821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[523793,523883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[523945,523855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[523917,524007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[523979,524069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[524041,524131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[524193,524103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[524165,524255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[524227,524317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[524289,524379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[524486,524351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[524425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[524410],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":32,"coverable":41},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","error.rs"],"content":"use std::convert::From;\nuse std::{fmt, result};\n\nuse aglet_text::Span;\nuse thiserror::Error;\n\nuse crate::tokenize;\n\npub type Result\u003cT\u003e = result::Result\u003cT, Error\u003e;\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    pub span: Span,\n    pub kind: ErrorKind,\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}) {}\", self.span, self.kind)\n    }\n}\n\nimpl From\u003ctokenize::Error\u003e for Error {\n    fn from(value: tokenize::Error) -\u003e Self {\n        Error {\n            span: value.span,\n            kind: ErrorKind::TokenizeError(value.cause),\n        }\n    }\n}\n\n#[derive(Error, Clone, Debug, Eq, PartialEq)]\npub enum ErrorKind {\n    #[error(\"tokenizer error: {0}\")]\n    TokenizeError(tokenize::ErrorCause),\n\n    #[error(\"unexpected end of input: expected {0}\")]\n    UnexpectedEOF(String),\n\n    #[error(\"unexpected token {0:?}: expected {1}\")]\n    UnexpectedToken(tokenize::TokenKind, String),\n\n    #[error(\"empty character class\")]\n    EmptyClass,\n\n    #[error(\"unexpected token: {0}\")]\n    TokenConvertError(TokenConvertError),\n\n    #[error(\"not implemented\")]\n    NotImplemented,\n}\n\n#[derive(Error, Clone, Debug, Eq, PartialEq)]\npub enum TokenConvertError {\n    #[error(\"invalid token for boundary: {0:?}\")]\n    InvalidTokenForBoundary(tokenize::TokenKind),\n\n    #[error(\"invalid token for repetition: {0:?}\")]\n    InvalidTokenForRepetition(tokenize::TokenKind),\n\n    #[error(\"invalid posix class: {0}\")]\n    InvalidPosixClass(String),\n}\n","traces":[{"line":18,"address":[547584],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":19,"address":[547605,547707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[547792],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":26,"address":[547804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[547812],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","input.rs"],"content":"use std::iter::Peekable;\n\nuse aglet_text::Span;\n\nuse crate::parse::error::*;\nuse crate::tokenize::{self, Token, TokenKind};\n\npub(crate) struct Input\u003c'a\u003e {\n    data:   Peekable\u003cBox\u003cdyn Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e + 'a\u003e\u003e,\n    span:   Span,\n    errors: Vec\u003cError\u003e,\n}\n\nimpl\u003c'a\u003e Input\u003c'a\u003e {\n    pub fn new\u003cT\u003e(data: T) -\u003e Self\n    where\n        T: Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e + 'a,\n    {\n        let data = Box::new(data) as Box\u003cdyn Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e\u003e;\n        Self {\n            data:   data.peekable(),\n            span:   Span::new(0, 0),\n            errors: Vec::new(),\n        }\n    }\n\n    pub fn position(\u0026self) -\u003e usize {\n        self.span.end\n    }\n\n    pub fn peek_kind(\u0026mut self) -\u003e Option\u003cResult\u003c\u0026TokenKind\u003e\u003e {\n        self.skip_errors();\n\n        match self.data.peek() {\n            None =\u003e None,\n            Some(Ok(tok)) =\u003e Some(Ok(\u0026tok.kind)),\n            Some(Err(err)) =\u003e Some(Err(Error::from(err.clone()))),\n        }\n    }\n\n    #[inline]\n    pub fn has_where\u003cF\u003e(\u0026mut self, f: F) -\u003e Result\u003cbool\u003e\n    where\n        F: Fn(\u0026TokenKind) -\u003e bool,\n    {\n        match self.peek_kind() {\n            None =\u003e Ok(false),\n            Some(Err(err)) =\u003e Err(err),\n            Some(Ok(kind)) =\u003e Ok(f(kind)),\n        }\n    }\n\n    pub fn next(\u0026mut self) -\u003e Option\u003cResult\u003cToken\u003e\u003e {\n        self.skip_errors();\n\n        let item = self.data.next().map(|res| res.map_err(Error::from));\n\n        if let Some(Ok(tok)) = \u0026item {\n            self.span = tok.span;\n        }\n\n        item\n    }\n\n    #[inline]\n    pub fn match_where\u003cF\u003e(\u0026mut self, f: F) -\u003e Result\u003cOption\u003cToken\u003e\u003e\n    where\n        F: Fn(\u0026TokenKind) -\u003e bool,\n    {\n        if self.has_where(f)? {\n            Ok(Some(\n                self.next()\n                    .expect(\"next token matches previous peek\")\n                    .expect(\"next token matches previous peek\"),\n            ))\n        } else {\n            Ok(None)\n        }\n    }\n\n    #[inline]\n    pub fn error(\u0026self, kind: ErrorKind) -\u003e Error {\n        Error {\n            span: self.span,\n            kind,\n        }\n    }\n\n    #[inline]\n    pub fn errors(\u0026self) -\u003e \u0026[Error] {\n        \u0026self.errors\n    }\n\n    fn skip_errors(\u0026mut self) {\n        loop {\n            match self.data.peek() {\n                Some(Err(err)) if !err.is_fatal() =\u003e self.errors.push(err.clone().into()),\n                _ =\u003e return,\n            }\n\n            self.data.next();\n        }\n    }\n}\n","traces":[{"line":15,"address":[377496,377136,377088,376736],"length":1,"stats":{"Line":9},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":27,"address":[301360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[301365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[301376],"length":1,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[301414],"length":1,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[301424,301470],"length":1,"stats":{"Line":16},"fn_name":null},{"line":35,"address":[301465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[384613,380736,381413,378533,383653,383616,377536,383333,381696,383296,384933,380133,383013,385216,383973,385573,385856,380453,378176,382693,382016,381733,377856,378816,382656,378213,382336,378496,382053,382373,385536,383936,384293,377893,384576,379776,384896,378853,385253,384256,381056,381093,379136,379456,377573,385893,379813,380096,379493,380773,379173,380416,381376,382976],"length":1,"stats":{"Line":46},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[392736,392352,386208,388512,391200,391968,386976,394272,389280,389664,387744,391584,393120,386592,394656,387360,393504,390048,390816,388896,390432,393888,388128],"length":1,"stats":{"Line":35},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":31,"coverable":41},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","mod.rs"],"content":"pub mod ast;\npub mod error;\nmod input;\npub mod parser;\nmod pretty;\n\n#[cfg(test)]\nuse aglet_text::Span;\npub use error::{Error, ErrorKind};\npub use parser::Parser;\n\n#[cfg(test)]\nuse crate::tokenize::{self, Token, TokenKind};\n\n#[cfg(test)]\npub(crate) fn token_iter(tokens: Vec\u003cTokenKind\u003e) -\u003e impl Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e {\n    tokens.into_iter().map(|kind| {\n        Ok(Token {\n            span: Span::new(0, 0),\n            kind,\n        })\n    })\n}\n\n#[cfg(test)]\npub(crate) fn span_token_iter(\n    span_start: usize,\n    tokens: Vec\u003c(usize, TokenKind)\u003e,\n) -\u003e impl Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e {\n    tokens\n        .into_iter()\n        .scan(span_start, |span_start, (span_len, kind)| {\n            let start = *span_start;\n            *span_start += span_len;\n            Some((start, span_len, kind))\n        })\n        .map(|(span_start, span_len, kind)| {\n            let tok = Token {\n                span: Span::new(span_start, span_start + span_len),\n                kind,\n            };\n\n            Ok(tok)\n        })\n}\n\n#[cfg(test)]\nmacro_rules! assert_kind {\n    ($expr:expr, $kind:pat) =\u003e {\n        if !matches!($expr.kind, $kind) {\n            panic!(\"{:?} does not match {}\", $expr.kind, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_err {\n    ($res:expr, $kind:pat) =\u003e {\n        if !matches!($res, Err(Error { kind: $kind, .. })) {\n            panic!(\"{:?} does not match error {}\", $res, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\npub(crate) use assert_err;\n#[cfg(test)]\npub(crate) use assert_kind;\n","traces":[{"line":16,"address":[418832],"length":1,"stats":{"Line":7},"fn_name":"token_iter"},{"line":17,"address":[372352,372596],"length":1,"stats":{"Line":14},"fn_name":"{closure#0}"},{"line":18,"address":[372502],"length":1,"stats":{"Line":8},"fn_name":null},{"line":19,"address":[372382],"length":1,"stats":{"Line":6},"fn_name":null},{"line":20,"address":[372467],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[418896],"length":1,"stats":{"Line":1},"fn_name":"span_token_iter"},{"line":30,"address":[418933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[372624,372662,372988],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":33,"address":[372714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[372730,372922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[372777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[373049,373399,373024],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":38,"address":[373293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[373113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[373241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[373355],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","parser.rs"],"content":"use std::convert::TryFrom;\n\nuse aglet_text::Span;\n\nuse crate::parse::ast::*;\nuse crate::parse::error::*;\nuse crate::parse::input::Input;\nuse crate::tokenize::token::tok;\nuse crate::tokenize::{self, Token, TokenKind};\n\n/// Parse regular expressions from a [token stream](tokenize::Tokenizer)\n///\n/// Uses a recursive-descent approach to parse a regular expression, with a grammar free\n/// of left-recursion.\n///\n/// # Grammar:\n///\n/// ```grammar\n/// expr -\u003e\n///     | alternation\n///     | \\e\n/// alternation -\u003e\n///     | concatenation ('|' alternation)?\n/// concatenation -\u003e\n///     | repetition concatenation?\n/// repetition -\u003e\n///     | item repetition-spec?\n/// repetition_spec -\u003e\n///     | repetition_range\n///     | QUESTION\n///     | STAR\n///     | PLUS\n/// repetition_range -\u003e\n///     | '{' repetition_range_contents '}'\n/// repetition_range_contents -\u003e\n///     | NUMBER? (',' NUMBER?)?\n/// item -\u003e\n///     | DOT\n///     | LITERAL\n///     | DIGIT_CLASS\n///     | WHITESPACE_CLASS\n///     | WORD_CLASS\n///     | BOUNDARY\n///     | group\n///     | class\n/// group -\u003e\n///     | '(' group_contents ')'\n/// group_contents -\u003e\n///     | '?' flags? ':' expr\n///     | '?' flags\n///     | '?' 'P'? '\u003c' NAME '\u003e' expr\n///     | expr\n/// class -\u003e\n///     | unicode_class\n///     | '[' specified_class ']'\n/// unicode_class -\u003e\n///     | unicode_escape CHAR\n///     | unicode_escape '{' NAME '}'\n///     | unicode_escape '{' NAME '!'? '=' NAME '}'\n/// unicode_escape -\u003e\n///     | '\\p'\n///     | '\\P'\n/// specified_class -\u003e\n///     | NEGATED? spec_item+\n/// spec_item -\u003e\n///     | spec_term spec_set?\n/// spec_term -\u003e\n///     | LITERAL ('-' LITERAL)?\n///     | DIGIT_CLASS\n///     | WHITESPACE_CLASS\n///     | WORD_CLASS\n///     | '[' ':' '^'? NAME ':' ']'\n///     | '[' specified_class ']'\n/// spec_set -\u003e\n///     | '~~' spec_term spec_set?\n///     | '--' spec_item spec_set?\n///     | '\u0026\u0026' spec_item spec_set?\n/// ```\npub struct Parser\u003c'a\u003e {\n    input:       Input\u003c'a\u003e,\n    group_index: usize,\n    errors:      Vec\u003cError\u003e,\n}\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    /// Create a new parser from a token iterator\n    ///\n    /// Since [`Tokenizer`](tokenize::Tokenizer) implements Iterator, a parser can be built\n    /// from it directly\n    pub fn new\u003cT\u003e(input: T) -\u003e Self\n    where\n        T: Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e + 'a,\n    {\n        Parser {\n            input:       Input::new(input),\n            group_index: 1,\n            errors:      Vec::new(),\n        }\n    }\n\n    /// Parse the regular expression into a [syntax tree](Ast)\n    pub fn parse(mut self) -\u003e ParseResult {\n        let res = self.parse_expr();\n        let ast = self.ok_or_default(res);\n\n        let mut errors = self.errors;\n        errors.extend_from_slice(self.input.errors());\n\n        ParseResult { ast, errors }\n    }\n\n    /// Parse an expression, starting with alternations as the weakest binding operation\n    ///\n    /// An alternation is a list of expressions separated by `|` symbols, where the\n    /// regular expression must match one of the alternatives.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// expr -\u003e\n    ///     | alternation\n    ///     | \\e\n    /// alternation -\u003e\n    ///     | concatenation ('|' alternation)?\n    /// ```\n    pub fn parse_expr(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut items = Vec::new();\n\n        // don't recursively match concatenation and then alternation as in the grammar,\n        // rather just use a loop to match a series of concatenations\n        loop {\n            // parse an alternate\n            let item = match self.parse_concatenation()? {\n                Some(item) =\u003e item,\n\n                // If there is nothing in the alternate (e.g., `/abc|/`) then an empty\n                // expression is allowed\n                None =\u003e Expr {\n                    span: Span::new(self.input.position(), self.input.position()),\n                    kind: ExprKind::Empty,\n                },\n            };\n\n            // there will always be at least one item, since even an empty token stream will\n            // first match an `ExprKind::Empty`\n            items.push(item);\n\n            // continue matching expressions as alternates as long as there are more\n            // `|` symbols separating them\n            if !self.input.has_where(TokenKind::is_alternate)? {\n                break;\n            }\n\n            self.input.next();\n        }\n\n        if items.len() \u003e 1 {\n            // The alternation expression type only makes sense if there is more than one\n            // alternate\n            let span = Span::wrap(\u0026items[0].span, \u0026items[items.len() - 1].span);\n            let kind = ExprKind::Alternation(Alternation { span, items });\n\n            Ok(Expr { span, kind })\n        } else {\n            // If there is only one alternate, don't bother wrapping it in an `Alternation`\n            // and just use the underlying expression instead. There is always at least one\n            // item so it's safe to unwrap\n            Ok(items.pop().unwrap())\n        }\n    }\n\n    /// Parse a concatenation, using repetition as the next weakest binding operation\n    ///\n    /// A concatenation is a series of sub-expressions directly next to each other with\n    /// no conjoining symbol, where the regular expression will match them one after the other.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// concatenation -\u003e\n    ///     | repetition concatenation?\n    /// ```\n    pub fn parse_concatenation(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let mut items = Vec::new();\n\n        // don't recursively match repetitions and concatenations, rather just use a loop\n        // to match a series of repetitions, accomplishing the same thing\n        while let Some(item) = self.parse_repetition()? {\n            items.push(item);\n        }\n\n        // A concatenation only makes sense so long as there's more than one element\n        // to concatenate, otherwise the sub-expression type should pass through\n        if items.len() \u003e 1 {\n            let span = Span::wrap(\u0026items[0].span, \u0026items[items.len() - 1].span);\n            Ok(Some(Expr {\n                span,\n                kind: ExprKind::Concatenation(Concatenation { span, items }),\n            }))\n        } else {\n            // If there's less than two items, return the subexpression instead of a new\n            // concatenation (or None if no items were matched)\n            Ok(items.pop())\n        }\n    }\n\n    /// Parse a repetition of items\n    ///\n    /// Repetition specifies the number of times an item should be matched:\n    ///\n    /// * exactly one time (default),\n    /// * zero or one times,\n    /// * zero or more times,\n    /// * one or more times,\n    /// * exactly `n` times,\n    /// * `n` or more times,\n    /// * up to `n` times,\n    /// * between `n` and `m` times\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// repetition -\u003e\n    ///     | item repetition-spec?\n    /// repetition_spec -\u003e\n    ///     | repetition_range\n    ///     | QUESTION\n    ///     | STAR\n    ///     | PLUS\n    /// repetition_range -\u003e\n    ///     | '{' repetition_range_contents '}'\n    /// repetition_range_contents -\u003e\n    ///     | NUMBER? (',' NUMBER?)?\n    /// ```\n    pub fn parse_repetition(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        // match the item to be repeated\n        let Some(item) = self.parse_item()? else {\n            return Ok(None);\n        };\n\n        // the default quantity (exactly once) doesn't require any text to be matched,\n        // so matching a repetition specifier is optional. When not present, the sub-item\n        // will pass through instead of a repetition expr\n        if let Some(kind) = self.parse_repetition_spec()? {\n            let span = Span::new(item.span.start, self.input.position());\n            let repetition = Repetition {\n                span,\n                kind,\n                item: Box::new(item),\n            };\n\n            // a repetition specifier is present, so encode it in a repetition expression\n            Ok(Some(Expr {\n                span,\n                kind: ExprKind::Repetition(repetition),\n            }))\n        } else {\n            // no repetition specifier was present, so pass through the matched item\n            Ok(Some(item))\n        }\n    }\n\n    /// Parse a repetition specifier\n    ///\n    /// The specifier is the optional part of a repetition expression, so the parser generates\n    /// a [`RepetitionKind`] rather than an [`Expr`].\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// repetition_spec -\u003e\n    ///     | repetition_range\n    ///     | QUESTION\n    ///     | STAR\n    ///     | PLUS\n    /// repetition_range -\u003e\n    ///     | '{' repetition_range_contents '}'\n    /// repetition_range_contents -\u003e\n    ///     | NUMBER? (',' NUMBER?)?\n    /// ```\n    pub fn parse_repetition_spec(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        self.parse_alts(vec![\n            Self::parse_question,\n            Self::parse_star,\n            Self::parse_plus,\n            Self::parse_repetition_range,\n        ])\n    }\n\n    /// Parse the zero-or-one quantity specifier (`?`)\n    pub fn parse_question(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        if self.input.has_where(TokenKind::is_question)? {\n            self.input.next();\n            Ok(Some(RepetitionKind::ZeroOrOne))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse the zero-or-more quantity specifier (`*`)\n    pub fn parse_star(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        if self.input.has_where(TokenKind::is_star)? {\n            self.input.next();\n            Ok(Some(RepetitionKind::ZeroOrMore))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse the one-or-more quantity specifier (`+`)\n    pub fn parse_plus(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        if self.input.has_where(TokenKind::is_plus)? {\n            self.input.next();\n            Ok(Some(RepetitionKind::OneOrMore))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse a specified range for a repetition\n    ///\n    /// A repetition range specifies a custom quantity for an item not expressible by\n    /// the `?`, `*`, and `+` specifiers:\n    ///\n    /// * `n` to `m`: `{n,m}`\n    /// * up to `n`: `{,n}` or `{0,n}`\n    /// * `n` or more: `{n,}`\n    /// * exactly `n`: `{n}`\n    ///\n    /// The can also be used in place of the `?`, `*`, and `+` specifiers:\n    ///\n    /// * zero or one: `{0,1}`\n    /// * zero or more: `{0,}`\n    /// * one or more: `{1,}`\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// repetition_range -\u003e\n    ///     | '{' repetition_range_contents '}'\n    /// repetition_range_contents -\u003e\n    ///     | NUMBER? (',' NUMBER?)?\n    /// ```\n    pub fn parse_repetition_range(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_brace)? else {\n            return Ok(None);\n        };\n\n        // both numbers are optional, `{,}` is equivalent to `{0,}` and `*`\n        let mut start: Option\u003cusize\u003e = None;\n        let mut end: Option\u003cusize\u003e = None;\n\n        // first number\n        if let Some(tok) = self.input.match_where(TokenKind::is_number)? {\n            tok!(TokenKind::Number(number) = tok);\n            start = Some(number);\n        }\n\n        // the second number is only allowed if a comma is present\n        if self.input.match_where(TokenKind::is_comma)?.is_some() {\n            if let Some(tok) = self.input.match_where(TokenKind::is_number)? {\n                tok!(TokenKind::Number(number) = tok);\n                end = Some(number);\n            }\n        }\n\n        let close_tok = self.expect_match(\"end of range `}`\", TokenKind::is_close_brace)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n        Ok(Some(RepetitionKind::Range(Range { span, start, end })))\n    }\n\n    /// Parse an item to be matched by the regular expression\n    ///\n    /// Items are the basic units of the regular expression and represent actual text to\n    /// be matched. The simplest items (`DOT`, `LITERAL`) match a single character (unless\n    /// accompanied by a repetition specifier), and a `BOUNDARY` matches a zero-width location\n    /// in the input (e.g. the beginning of a word). The non-terminal `class` item also\n    /// matches a single character, but is constructed from a more complicated specification.\n    ///\n    /// A `group` item is a sub-expression that may match anything. It is matched at this\n    /// level because it can be a component of an alternation, concatenation, or repetition.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// item -\u003e\n    ///     | DOT\n    ///     | LITERAL\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | BOUNDARY\n    ///     | group\n    ///     | class\n    /// ```\n    pub fn parse_item(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let item = self.parse_alts(vec![\n            Self::parse_dot,\n            Self::parse_literal,\n            Self::parse_digit_class,\n            Self::parse_whitespace_class,\n            Self::parse_word_class,\n            Self::parse_boundary,\n            Self::parse_group,\n            Self::parse_class,\n        ])?;\n\n        // Valid tokens to follow an item come from those productions that can consume an item,\n        // in particular groups and alternation\n        if item.is_none() {\n            match self.input.peek_kind() {\n                Some(Ok(TokenKind::CloseGroup | TokenKind::Alternate)) =\u003e Ok(None),\n                Some(Ok(_)) =\u003e Err(self.illegal_tok(\"`.`, `[`, `(`, boundary, class, or literal\")),\n                _ =\u003e Ok(None),\n            }\n        } else {\n            Ok(item)\n        }\n    }\n\n    /// Parse the \"any\" item (`.`)\n    pub fn parse_dot(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_dot)? else {\n            return Ok(None);\n        };\n\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Any,\n        }))\n    }\n\n    /// Parse a literal item (a single character)\n    pub fn parse_literal(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_literal)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Literal(c) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Literal(c),\n        }))\n    }\n\n    /// Parse a digit short class, `\\d` or `\\D`\n    pub fn parse_digit_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_digit)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Digit(negated) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Digit(negated),\n        }))\n    }\n\n    /// Parse a whitespace short class, `\\s` or `\\S`\n    pub fn parse_whitespace_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_whitespace)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Whitespace(negated) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Whitespace(negated),\n        }))\n    }\n\n    /// Parse a word character short class, `\\w` or `\\W`\n    pub fn parse_word_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_word_char)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::WordChar(negated) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::WordChar(negated),\n        }))\n    }\n\n    /// Parse a boundary item\n    ///\n    /// Boundaries have already been condensed into single tokens by the tokenizer,\n    /// but may be a single character (e.g. `$` or `^`) or several (`\\b`)\n    pub fn parse_boundary(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_boundary)? else {\n            return Ok(None);\n        };\n\n        let kind = match BoundaryKind::try_from(tok.kind) {\n            Ok(kind) =\u003e Ok(kind),\n            Err(err) =\u003e Err(self.input.error(ErrorKind::TokenConvertError(err))),\n        }?;\n\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Boundary(Boundary {\n                span: tok.span,\n                kind,\n            }),\n        }))\n    }\n\n    /// Parse a group item\n    ///\n    /// A group is usually a sub-expression that contains another entire regex. It is surrounded\n    /// by parentheses and can begin with some options that change its behaviour.\n    ///\n    /// Groups can be capturing (the text matched by the sub-expression can be retrieved\n    /// on its own), named, non-capturing, and contain flags which alter the behaviour of the\n    /// engine. For example, the case-insensitive flag will make matches within the group\n    /// case-insensitive.\n    ///\n    /// The `FLAGS` group does not contain a sub-expression, but applies the effect of the\n    /// specified flags to the current expression.\n    ///\n    /// The ignore-whitespace ('x') flag was already processed by the tokenizer and has no\n    /// effect from this stage.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// group -\u003e\n    ///     | '(' group_contents ')'\n    /// group_contents -\u003e\n    ///     | NON_CAPTURING expr\n    ///     | NON_CAPTURING_FLAGS expr\n    ///     | GROUP_NAME expr\n    ///     | FLAGS\n    /// ```\n    pub fn parse_group(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_group)? else {\n            return Ok(None);\n        };\n\n        // use a sub-parse to match the group's type and its contents, if applicable\n        let kind = self.parse_group_contents()?;\n\n        let close_tok = self.expect_match(\"end of group `)`\", TokenKind::is_close_group)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n\n        Ok(Some(Expr {\n            span,\n            kind: ExprKind::Group(Group { span, kind }),\n        }))\n    }\n\n    /// Parse the type and contents of a group\n    ///\n    /// Because the [`parse_group`][1] parser is responsible for the open and close braces\n    /// surrounding the group and therefore its span, this parser returns only the group\n    /// kind (which contains the subexpression, if applicable).\n    ///\n    /// This parser cannot return `None`, as an empty group that expects an expression\n    /// will be populated with an [`ExprKind::Empty`]\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// group_contents -\u003e\n    ///     | '?' flags? ':' expr\n    ///     | '?' flags\n    ///     | '?' 'P'? '\u003c' GROUP_NAME '\u003e' expr\n    ///     | expr\n    /// ```\n    ///\n    /// [1]: Parser::parse_group\n    pub fn parse_group_contents(\u0026mut self) -\u003e Result\u003cGroupKind\u003e {\n        let res = self\n            .parse_alts(vec![\n                Self::parse_group_with_header,\n                Self::parse_capturing_group,\n            ])?\n            // one of the group contents parsers must always produce a match\n            .expect(\"group contents should not be None\");\n\n        Ok(res)\n    }\n\n    /// Parse a group with an options header\n    ///\n    /// An options header begins with `?` and is used to specify a name or set of flags for the\n    /// group.\n    ///\n    /// Named groups are capturing groups, but instead of being identified by a\n    /// number, are also identified with a string. They begin with `?P\u003cname\u003e` or `?\u003cname\u003e`, where\n    /// `name` is the name of the sub-expression.\n    ///\n    /// A non-capturing group is not represented by a name or index; it optionally matches some\n    /// text and optionally specifies some flags. The flags set or cleared in a non-capturing\n    /// group only apply within that group.\n    ///\n    /// A flags group only specifies some flags and matches no text; flags set or cleared in a\n    /// flags group apply to their enclosing expression.\n    ///\n    /// Available flags are:\n    ///\n    /// * `i`: case-insensitive\n    /// * `m`: multi-line\n    /// * `s`: `.` matches newlines\n    /// * `R`: use `\\r\\n` when multiline mode is enabled\n    /// * `U`: swaps the meaning of `.*` and `.*?`\n    /// * `u`: enable unicode support (default)\n    /// * `x`: ignore whitespace and allow comments\n    ///\n    /// Flags are set or cleared like so:\n    ///\n    /// `ix-um`\n    ///\n    /// * Set the case-insensitive flag `i`\n    /// * Set the ignore-whitespace flag `x`\n    /// * Clear the unicode support flag `u`\n    /// * Clear the multi-line flag `m`\n    ///\n    /// ```grammar\n    /// group_contents -\u003e\n    ///     | '?' flags? ':' expr\n    ///     | '?' flags\n    ///     | '?' 'P'? '\u003c' NAME '\u003e' expr\n    /// ```\n    pub fn parse_group_with_header(\u0026mut self) -\u003e Result\u003cOption\u003cGroupKind\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_group_options)? else {\n            return Ok(None);\n        };\n\n        let group_kind = if self\n            .input\n            .match_where(TokenKind::is_open_group_name)?\n            .is_some()\n        {\n            let name_tok = self.expect_match(\"group name\", TokenKind::is_name)?;\n            tok!(TokenKind::Name(name) = name_tok);\n\n            self.expect_match(\"end of group name `\u003e`\", TokenKind::is_close_group_name)?;\n\n            let expr = self.parse_expr()?;\n            let name = StringSpan {\n                span:  name_tok.span,\n                value: name,\n            };\n\n            GroupKind::Named(NamedGroup {\n                name,\n                span: Span::wrap(\u0026open_tok.span, \u0026expr.span),\n                expr: Box::new(expr),\n            })\n        } else {\n            let flags = self.parse_flags()?;\n            if self\n                .input\n                .match_where(TokenKind::is_close_group_options)?\n                .is_some()\n            {\n                let expr = self.parse_expr()?;\n\n                GroupKind::NonCapturing(NonCapturingGroup {\n                    span: expr.span,\n                    expr: Box::new(expr),\n                    flags,\n                })\n            } else {\n                let flags = flags.unwrap_or_else(|| Flags {\n                    span:        Span::new(open_tok.span.end, open_tok.span.end),\n                    set_flags:   Vec::new(),\n                    clear_flags: Vec::new(),\n                });\n\n                GroupKind::Flags(FlagGroup { flags })\n            }\n        };\n\n        Ok(Some(group_kind))\n    }\n\n    pub fn parse_flags(\u0026mut self) -\u003e Result\u003cOption\u003cFlags\u003e\u003e {\n        let mut span = None;\n        let mut set_flags = vec![];\n        let mut clear_flags = vec![];\n        let mut clearing = false;\n\n        while let Some(tok) = self.input.match_where(TokenKind::is_flag_or_delimiter)? {\n            if let Some(s) = span {\n                span = Some(Span::wrap(\u0026s, \u0026tok.span));\n            } else {\n                span = Some(tok.span);\n            }\n\n            if tok.kind.is_flag() {\n                tok!(TokenKind::Flag(f) = tok);\n\n                if clearing {\n                    clear_flags.push(f.into())\n                } else {\n                    set_flags.push(f.into())\n                }\n            } else if tok.kind.is_flag_delimiter() {\n                if clearing {\n                    return Err(self.input.error(ErrorKind::UnexpectedToken(\n                        TokenKind::FlagDelimiter,\n                        \"end of flags `:` or `)`\".to_string(),\n                    )));\n                }\n\n                clearing = true;\n            }\n        }\n\n        if let Some(span) = span {\n            Ok(Some(Flags {\n                span,\n                set_flags,\n                clear_flags,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse a capturing group\n    ///\n    /// The matched contents of a capturing group can be referenced after the match. Named groups\n    /// are reference by a string name, whereas basic capturing groups are identified by a\n    /// sequenced number. The first capturing group is referenced by the number `1`. The number\n    /// `0` references the entire match.\n    ///\n    /// Capturing groups are not prefixed with any tokens\n    pub fn parse_capturing_group(\u0026mut self) -\u003e Result\u003cOption\u003cGroupKind\u003e\u003e {\n        // The only part of a capturing group (besides the parentheses) is the sub-expression\n        let expr = self.parse_expr()?;\n\n        // assign an incrementing index to the group\n        let index = self.group_index;\n        self.group_index += 1;\n\n        Ok(Some(GroupKind::Capturing(CapturingGroup {\n            span: expr.span,\n            index,\n            expr: Box::new(expr),\n        })))\n    }\n\n    /// Parse a character class\n    ///\n    /// Character classes match a single character from the input. The can be specified either\n    /// as a unicode class (any character belonging to a certain unicode category, or having\n    /// some other property) or as a specified class, where they can be matched with ranges and\n    /// sets of characters, or by POSIX class.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// class -\u003e\n    ///     | unicode_class\n    ///     | '[' specified_class ']'\n    /// unicode_class -\u003e\n    ///     | unicode_escape CHAR\n    ///     | unicode_escape '{' UNICODE_PROP_VALUE '}'\n    ///     | unicode_escape '{' UNICODE_PROP_NAME '=' UNICODE_PROP_VALUE '}'\n    ///     | unicode_escape '{' UNICODE_PROP_NAME '!=' UNICODE_PROP_VALUE '}'\n    /// unicode_escape -\u003e\n    ///     | '\\p'\n    ///     | '\\P'\n    /// specified_class -\u003e\n    ///     | NEGATED? spec_item+\n    /// spec_item -\u003e\n    ///     | spec_term spec_set?\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' POSIX_NAME ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    ///     | \\e\n    /// ```\n    pub fn parse_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        self.parse_alts(vec![Self::parse_specified_class, Self::parse_unicode_class])\n    }\n\n    /// Parse a unicode character class\n    ///\n    /// Unicode classes match a character with a specified property value, such as the general\n    /// category, script, script extension, block, etc.\n    ///\n    /// The short unicode class `\\pL` uses the single-character variant of the general category,\n    /// e.g. `L` for `Letter`. The longer version, `\\p{Ll}` can use a longer specification,\n    /// e.g. `Ll` for lowercase letters, `Letter` for letters, etc.\n    ///\n    /// Matching for a property other than general category uses the syntax `\\p{scx=Greek}`,\n    /// which matches a character in the greek script extension.\n    ///\n    /// The match can be negated using `\\P` instead of `\\p`, or in the property name syntax,\n    /// using `\\p{Script_Extension!=Greek}`. Double negations are treated as positive, i.e.\n    /// `\\P{sc!=Greek}` is equivalent to `\\p{sc=Greek}`.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// unicode_class -\u003e\n    ///     | UNICODE_SHORT\n    ///     | UNICODE_LONG '{' UNICODE_PROP_VALUE '}'\n    ///     | UNICODE_LONG '{' UNICODE_PROP_NAME '=' UNICODE_PROP_VALUE '}'\n    ///     | UNICODE_LONG '{' UNICODE_PROP_NAME '!=' UNICODE_PROP_VALUE '}'\n    /// ```\n    pub fn parse_unicode_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        self.parse_alts(vec![\n            Self::parse_unicode_short_class,\n            Self::parse_unicode_long_class,\n        ])\n    }\n\n    /// Parse a short-form unicode character class\n    ///\n    /// Unicode classes of the form `\\pL` are condensed into a single token by the tokenizer.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// unicode_class -\u003e\n    ///     | UNICODE_SHORT\n    /// ```\n    pub fn parse_unicode_short_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_unicode_short)? else {\n            return Ok(None);\n        };\n\n        // create a unicode class for the general category specified by the token\n        tok!(TokenKind::UnicodeShort(category, negated) = tok);\n        let unicode_class = UnicodeClass {\n            span:  tok.span,\n            name:  None,\n            value: StringSpan {\n                span:  tok.span,\n                value: format!(\"{}\", category),\n            },\n        };\n\n        // construct the class expression with the negation value from the token\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Class(Class {\n                span: tok.span,\n                negated,\n                kind: ClassKind::Unicode(unicode_class),\n            }),\n        }))\n    }\n\n    /// Parse a long-form unicode character class\n    ///\n    /// Unicode classes of the form `\\p{Property=Value}` are broken into start and end\n    /// tokens, name, value, and equality tokens, with name and equality tokens being optional.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// unicode_class -\u003e\n    ///     | UNICODE_LONG '{' NAME '}'\n    ///     | UNICODE_LONG '{' NAME '!'? '=' NAME '}'\n    /// ```\n    pub fn parse_unicode_long_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_unicode_long)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::UnicodeLong(open_negated) = open_tok);\n\n        self.expect_match(\"start of unicode property `{`\", TokenKind::is_open_brace)?;\n\n        // The first name is either the property name or value, depending on whether this is\n        // the `\\p{Value}` or `\\p{Prop=Value}` form\n        let first_name_tok = self.expect_match(\"name\", TokenKind::is_name)?;\n        tok!(TokenKind::Name(n) = first_name_tok);\n        let first_name = StringSpan {\n            span:  first_name_tok.span,\n            value: n,\n        };\n\n        let mut second_name = None;\n\n        // optionally match `=` or `!=`\n        let eq_negated = self.input.match_where(TokenKind::is_bang)?.is_some();\n        let has_eq = self.input.match_where(TokenKind::is_equal)?.is_some();\n\n        // TODO: detect a ! with no corresponding =\n\n        if has_eq {\n            let second_name_tok = self.expect_match(\"property value\", TokenKind::is_name)?;\n\n            tok!(TokenKind::Name(v) = second_name_tok);\n            second_name = Some(StringSpan {\n                span:  second_name_tok.span,\n                value: v,\n            });\n        }\n\n        let close_tok = self.expect_match(\n            \"unicode property closing brace `}`\",\n            TokenKind::is_close_brace,\n        )?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n        let kind = match second_name {\n            Some(second_name) =\u003e ClassKind::Unicode(UnicodeClass {\n                span,\n                name: Some(first_name),\n                value: second_name,\n            }),\n            None =\u003e ClassKind::Unicode(UnicodeClass {\n                span,\n                name: None,\n                value: first_name,\n            }),\n        };\n\n        let negated = open_negated != eq_negated;\n        let kind = ExprKind::Class(Class {\n            span,\n            negated,\n            kind,\n        });\n\n        Ok(Some(Expr { span, kind }))\n    }\n\n    /// Parse a specified class\n    ///\n    /// A specified class represents a set of characters which can be matched from the input.\n    /// They are specified using a combination of literals, ranges, set operations, sub-classes\n    /// and POSIX classes:\n    ///\n    /// * literals: `[abc]` matches any character `a`, `b`, or `c`\n    /// * ranges: `[a-c]` matches any character `a`, `b`, or `c`\n    /// * set difference: `[[abcdef]--[def]]` matches any character `a`, `b`, or `c`\n    /// * set intersection: `[[abcdef]\u0026\u0026[cdxyz]]` matches any character `c` or `d`\n    /// * symmetrical set difference: `[[abc]~~[bcd]]` matches any character `a` or `d`\n    /// * posix classes: `[[:alnum:]]` matches any alphanumeric character\n    ///\n    /// Classes can be negated using a `^` token at the beginning. POSIX classes can themselves\n    /// be negated using the same token at the beginning of the name:\n    ///\n    /// * `[^abc]` matches any character except `a`, `b`, and `c`\n    /// * `[[:^lower:]]` matches any character except lowercase letters\n    ///\n    /// POSIX classes are unaware of unicode properties, and so only apply to ASCII characters.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// specified_class -\u003e\n    ///     | NEGATED? spec_item+\n    /// spec_item -\u003e\n    ///     | spec_term spec_set?\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' POSIX_NAME ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    /// ```\n    pub fn parse_specified_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_bracket)? else {\n            return Ok(None);\n        };\n\n        // optionally match a negation token for the class\n        let negated = self.input.match_where(TokenKind::is_negated)?.is_some();\n\n        // match all specification items\n        let mut items = Vec::new();\n        while let Some(item) = self.parse_specified_class_item()? {\n            items.push(item);\n        }\n\n        let close_tok =\n            self.expect_match(\"end of character class `]`\", TokenKind::is_close_bracket)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n        let inner_span_start = items\n            .first()\n            .map(|item| item.span.start)\n            .unwrap_or(open_tok.span.end);\n        let inner_span_end = items\n            .last()\n            .map(|item| item.span.end)\n            .unwrap_or(close_tok.span.start);\n        let inner_span = Span::new(inner_span_start, inner_span_end);\n\n        let kind = ClassKind::Specified(SpecifiedClass {\n            items,\n            span: inner_span,\n        });\n\n        Ok(Some(Expr {\n            span,\n            kind: ExprKind::Class(Class {\n                span,\n                negated,\n                kind,\n            }),\n        }))\n    }\n\n    /// Parse a specified class item\n    ///\n    /// Class items consist of literals, ranges, POSIX classes, subclasses, and set\n    /// operations. See [`parse_specified_class`][1] for more details. To eliminate\n    /// left-recursion from the grammar, subclasses and terminal productions are matched\n    /// first before matching set operations.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_item -\u003e\n    ///     | spec_term spec_set?\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' ':' '^'? NAME ':' ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    /// ```\n    ///\n    /// [1]: Parser::parse_specified_class\n    pub fn parse_specified_class_item(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(term) = self.parse_specified_class_term()? else {\n            return Ok(None);\n        };\n\n        let with_set = self.parse_class_item_set(term)?;\n        Ok(Some(with_set))\n    }\n\n    /// Parse a specified class item, excluding set operations\n    ///\n    /// Any specification item that can be positively identified by a terminal can be\n    /// parsed here, to ensure that the grammar is not left-recursive. Set operations\n    /// can match further items to build a left-associated tree of set operations.\n    ///\n    /// See [parse_specified_class][1] for details on class items\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' ':' '^'? NAME ':' ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    /// ```\n    ///\n    /// [1]: Parser::parse_specified_class\n    pub fn parse_specified_class_term(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        self.parse_alts(vec![\n            Self::parse_class_term_literal,\n            Self::parse_class_term_digit,\n            Self::parse_class_term_whitespace,\n            Self::parse_class_term_word,\n            Self::parse_class_term_bracket,\n        ])\n    }\n\n    /// Parse a character class item beginning with a literal\n    ///\n    /// Either a literal or a literal range can be parsed here\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    /// ```\n    pub fn parse_class_term_literal(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        // match a literal, which will either be on its own or at the start\n        // of a literal range\n        let Some(start_tok) = self.input.match_where(TokenKind::is_literal)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Literal(c_start) = start_tok);\n\n        // optionally match the second half of a range\n        let spec = if self.input.match_where(TokenKind::is_range)?.is_some() {\n            let end_tok = self.expect_match(\"end of range\", TokenKind::is_literal)?;\n            tok!(TokenKind::Literal(c_end) = end_tok);\n\n            // if a range is matched, a range class specifier will be returned\n            let span = Span::wrap(\u0026start_tok.span, \u0026end_tok.span);\n            let kind = ClassSpecKind::Range(c_start, c_end);\n            ClassSpec { span, kind }\n        } else {\n            // if a range wasn't matched, then the literal class specifier will be\n            // returned on its own\n            let span = start_tok.span;\n            let kind = ClassSpecKind::Literal(c_start);\n            ClassSpec { span, kind }\n        };\n\n        Ok(Some(spec))\n    }\n\n    /// Parse a digit short class, `\\d` or `\\D`\n    pub fn parse_class_term_digit(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_digit)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Digit(negated) = tok);\n        Ok(Some(ClassSpec {\n            span: tok.span,\n            kind: ClassSpecKind::Digit(negated),\n        }))\n    }\n\n    /// Parse a whitespace short class, `\\s` or `\\S`\n    pub fn parse_class_term_whitespace(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_whitespace)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Whitespace(negated) = tok);\n        Ok(Some(ClassSpec {\n            span: tok.span,\n            kind: ClassSpecKind::Whitespace(negated),\n        }))\n    }\n\n    /// Parse a word char short class, `\\w` or `\\W`\n    pub fn parse_class_term_word(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_word_char)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::WordChar(negated) = tok);\n        Ok(Some(ClassSpec {\n            span: tok.span,\n            kind: ClassSpecKind::WordChar(negated),\n        }))\n    }\n\n    /// Parse a specified class item that begins with an opening bracket\n    ///\n    /// This includes parsing a nested class. [`parse_specified_class`][1] can't really be reused\n    /// here because it needs to consume the first bracket - here the bracket is consumed so that\n    /// the beginning of POSIX_NAME can be peeked to disambiguate the two productions; once the\n    /// branch has been determined, control can't be passed to [`parse_specified_class`][1] because\n    /// the bracket was already consumed.\n    ///\n    /// Inverting this dependency and making [`parse_specified_class`][1] assume the bracket was\n    /// already consumed doesn't work that well because that token is needed to compute the\n    /// ast node's span.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_term -\u003e\n    ///     | '[' POSIX_NAME ']'\n    ///     | '[' specified_class ']'\n    /// ```\n    ///\n    /// [1]: Parser::parse_specified_class\n    pub fn parse_class_term_bracket(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_bracket)? else {\n            return Ok(None);\n        };\n\n        // attempt to match a POSIX class name\n        let kind = if let Some(open_colon) = self.input.match_where(TokenKind::is_colon)? {\n            let negated = self.input.match_where(TokenKind::is_negated)?.is_some();\n            let name = self.expect_match(\"posix class name\", TokenKind::is_name)?;\n            let close_colon =\n                self.expect_match(\"end of posix class name `:`\", TokenKind::is_colon)?;\n\n            tok!(TokenKind::Name(name) = name);\n\n            // convert the matched name into a POSIX class item\n            let posix_kind = match PosixKind::try_from(name.as_ref()) {\n                Ok(kind) =\u003e Ok(kind),\n                Err(err) =\u003e Err(self.input.error(ErrorKind::TokenConvertError(err))),\n            }?;\n\n            let kind_span = Span::wrap(\u0026open_colon.span, \u0026close_colon.span);\n            ClassSpecKind::Posix(PosixClass {\n                span: kind_span,\n                kind: posix_kind,\n                negated,\n            })\n        } else {\n            // if a POSIX class wasn't matched, then this must be the beginning of a subclass.\n            let negated = self.input.match_where(TokenKind::is_negated)?.is_some();\n\n            // match subclass items\n            let mut items = Vec::new();\n            while let Some(item) = self.parse_specified_class_item()? {\n                items.push(item);\n            }\n\n            let inner_span_start = items\n                .first()\n                .map(|item| item.span.start)\n                .unwrap_or(open_tok.span.end);\n            let inner_span_end = items\n                .last()\n                .map(|item| item.span.end)\n                .unwrap_or(open_tok.span.end);\n            let kind_span = Span::new(inner_span_start, inner_span_end);\n            let class_kind = ClassKind::Specified(SpecifiedClass {\n                span: kind_span,\n                items,\n            });\n\n            // create a subclass class specifier\n            ClassSpecKind::Class(Class {\n                span: kind_span,\n                kind: class_kind,\n                negated,\n            })\n        };\n\n        let close_tok = self.expect_match(\"end of posix class `]`\", TokenKind::is_close_bracket)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n\n        Ok(Some(ClassSpec { span, kind }))\n    }\n\n    /// Parse a set operation in a class specification\n    ///\n    /// Set operations include:\n    ///\n    /// * difference `A--B`: members of set A that are not in set B\n    /// * symmetric difference `A~~B`: members that are not in both A and B\n    /// * intersection: `A\u0026\u0026B`: members that are in both set A and set B\n    ///\n    /// This parser accepts a [`ClassSpec`][1] as the left hand side of the operation,\n    /// and matches the right hand side itself. [`parse_specified_class_item`][2] parses\n    /// the left-hand-side before optionally parsing a `spec_set` in order to eliminate\n    /// left-recursion and create a left-associative structure.\n    ///\n    /// Multiple subsequent set operations can be matched, e.g.\n    /// `[[:ascii:]--[:upper:]--[:lower:]]`\n    ///\n    /// # Arguments\n    ///\n    /// * `start` - the left-hand-side of the operation. The parser takes ownership of it,\n    ///     but if no operator is matched, it will be returned again.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_term spec_set?\n    ///     | '\u0026\u0026' spec_term spec_set?\n    /// ```\n    ///\n    /// [1]: ClassSpec\n    /// [2]: Parser::parse_specified_class_item\n    pub fn parse_class_item_set(\u0026mut self, start: ClassSpec) -\u003e Result\u003cClassSpec\u003e {\n        // match a set operator to begin parsing the class spec. If none is found\n        // then the left hand side will be returned unchanged.\n        let set_kind = if let Some(tok) = self.input.match_where(TokenKind::is_set_operator)? {\n            tok.kind\n        } else {\n            return Ok(start);\n        };\n\n        // parse the right-hand side of the operation\n        let Some(end) = self.parse_specified_class_term()? else {\n            return Err(self.input.error(ErrorKind::UnexpectedToken(\n                set_kind,\n                \"end of set\".to_string(),\n            )));\n        };\n\n        // construct a `ClassSpecKind` depending on which operator was found\n        let span = Span::wrap(\u0026start.span, \u0026end.span);\n        let kind = match set_kind {\n            TokenKind::Symmetrical =\u003e ClassSpecKind::Symmetrical(Symmetrical {\n                span,\n                left: Box::new(start),\n                right: Box::new(end),\n            }),\n            TokenKind::Difference =\u003e ClassSpecKind::Difference(Difference {\n                span,\n                left: Box::new(start),\n                right: Box::new(end),\n            }),\n            TokenKind::Intersection =\u003e ClassSpecKind::Intersection(Intersection {\n                span,\n                left: Box::new(start),\n                right: Box::new(end),\n            }),\n            _ =\u003e unreachable!(),\n        };\n\n        let nested_set = self.parse_class_item_set(ClassSpec { span, kind })?;\n        Ok(nested_set)\n    }\n\n    fn parse_alts\u003cF, R\u003e(\u0026mut self, alts: Vec\u003cF\u003e) -\u003e Result\u003cOption\u003cR\u003e\u003e\n    where\n        F: FnMut(\u0026mut Self) -\u003e Result\u003cOption\u003cR\u003e\u003e,\n    {\n        for mut alt in alts {\n            match alt(self) {\n                Ok(None) =\u003e continue,\n                result =\u003e return result,\n            }\n        }\n\n        Ok(None)\n    }\n\n    fn illegal_tok(\u0026mut self, expect: \u0026str) -\u003e Error {\n        match self.input.next() {\n            Some(Ok(tok)) =\u003e self\n                .input\n                .error(ErrorKind::UnexpectedToken(tok.kind, expect.to_string())),\n            Some(Err(err)) =\u003e err,\n            None =\u003e self\n                .input\n                .error(ErrorKind::UnexpectedEOF(expect.to_string())),\n        }\n    }\n\n    fn expect_match\u003cF\u003e(\u0026mut self, expect: \u0026str, f: F) -\u003e Result\u003cToken\u003e\n    where\n        F: Fn(\u0026TokenKind) -\u003e bool,\n    {\n        match self.input.next() {\n            Some(Ok(tok)) if f(\u0026tok.kind) =\u003e Ok(tok),\n            Some(Ok(tok)) =\u003e Err(self\n                .input\n                .error(ErrorKind::UnexpectedToken(tok.kind, expect.to_string()))),\n            Some(Err(err)) =\u003e Err(err),\n            None =\u003e Err(self\n                .input\n                .error(ErrorKind::UnexpectedEOF(expect.to_string()))),\n        }\n    }\n\n    fn ok_or_default\u003cT: Default\u003e(\u0026mut self, res: Result\u003cT\u003e) -\u003e T {\n        match res {\n            Ok(expr) =\u003e expr,\n            Err(e) =\u003e {\n                self.errors.push(e);\n                Default::default()\n            },\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::fmt::Debug;\n\n    use super::*;\n    use crate::parse::{assert_err, assert_kind, span_token_iter, token_iter};\n    use crate::tokenize::Flag;\n\n    fn unwrap_parse\u003cT\u003e(r: Result\u003cOption\u003cT\u003e\u003e) -\u003e T\n    where\n        T: Debug,\n    {\n        let Ok(Some(thing)) = r else {\n            panic!(\"parse failed: {:?}\", r);\n        };\n\n        thing\n    }\n\n    fn get_alternation(r: Result\u003cExpr\u003e) -\u003e Alternation {\n        let Ok(expr) = r else {\n            panic!(\"parse failed\");\n        };\n        let ExprKind::Alternation(alternation) = expr.kind else {\n            panic!(\"not an alternation\");\n        };\n\n        alternation\n    }\n\n    fn get_concatenation(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Concatenation {\n        let expr = unwrap_parse(r);\n        let ExprKind::Concatenation(concatenation) = expr.kind else {\n            panic!(\"not a concatenation\");\n        };\n\n        concatenation\n    }\n\n    fn get_repetition(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Repetition {\n        let expr = unwrap_parse(r);\n        let ExprKind::Repetition(repetition) = expr.kind else {\n            panic!(\"not a repetition\");\n        };\n\n        repetition\n    }\n\n    fn get_range(r: Result\u003cOption\u003cRepetitionKind\u003e\u003e) -\u003e Range {\n        let kind = unwrap_parse(r);\n        let RepetitionKind::Range(range) = kind else {\n            panic!(\"not a range\");\n        };\n\n        range\n    }\n\n    fn get_boundary(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Boundary {\n        let expr = unwrap_parse(r);\n        let ExprKind::Boundary(boundary) = expr.kind else {\n            panic!(\"expression is not a boundary\");\n        };\n\n        boundary\n    }\n\n    fn get_group(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Group {\n        let expr = unwrap_parse(r);\n        let ExprKind::Group(group) = expr.kind else {\n            panic!(\"expression is not a group\");\n        };\n\n        group\n    }\n\n    fn get_class(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Class {\n        let expr = unwrap_parse(r);\n        let ExprKind::Class(class) = expr.kind else {\n            panic!(\"expression is not a class\");\n        };\n\n        class\n    }\n\n    fn get_class_spec(r: Result\u003cOption\u003cClassSpec\u003e\u003e) -\u003e ClassSpec {\n        let Ok(r) = r else {\n            panic!(\"parse failed\");\n        };\n\n        let Some(spec) = r else {\n            panic!(\"empty parse\");\n        };\n\n        spec\n    }\n\n    fn get_class_items(class: Class) -\u003e Vec\u003cClassSpec\u003e {\n        if let ClassKind::Specified(SpecifiedClass { items, .. }) = class.kind {\n            items\n        } else {\n            panic!(\"not a specified class\");\n        }\n    }\n\n    fn get_unicode_class(class: Class) -\u003e UnicodeClass {\n        let ClassKind::Unicode(class) = class.kind else {\n            panic!(\"class is not unicode class\");\n        };\n\n        class\n    }\n\n    #[test]\n    fn expr() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Alternate,\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::Alternate,\n            TokenKind::OpenGroup,\n            TokenKind::CloseGroup,\n            TokenKind::Alternate,\n        ]));\n\n        let alt = get_alternation(p.parse_expr());\n        assert_eq!(alt.items.len(), 4);\n        assert_kind!(alt.items[0], ExprKind::Literal('a'));\n        assert_kind!(alt.items[1], ExprKind::Concatenation(_));\n        assert_kind!(alt.items[2], ExprKind::Group(_));\n        assert_kind!(alt.items[3], ExprKind::Empty);\n\n        let ExprKind::Concatenation(Concatenation { items, .. }) = \u0026alt.items[1].kind else {\n            panic!(\"not a concatenation\");\n        };\n        assert_eq!(items.len(), 2);\n        assert_kind!(items[0], ExprKind::Literal('b'));\n        assert_kind!(items[1], ExprKind::Literal('c'));\n\n        let ExprKind::Group(Group {\n            kind: GroupKind::Capturing(group),\n            ..\n        }) = \u0026alt.items[2].kind\n        else {\n            panic!(\"not a group\");\n        };\n        assert_kind!(group.expr, ExprKind::Empty);\n    }\n\n    #[test]\n    fn concatenation() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::OpenGroup,\n            TokenKind::Literal('c'),\n            TokenKind::CloseGroup,\n        ]));\n\n        let concat = get_concatenation(p.parse_concatenation());\n        assert_eq!(concat.items.len(), 3);\n        assert_kind!(concat.items[0], ExprKind::Literal('a'));\n        assert_kind!(concat.items[1], ExprKind::Literal('b'));\n        assert_kind!(concat.items[2], ExprKind::Group(_));\n        let ExprKind::Group(Group {\n            kind: GroupKind::Capturing(group),\n            ..\n        }) = \u0026concat.items[2].kind\n        else {\n            panic!(\"not a group\");\n        };\n\n        assert!(matches!(group.expr.kind, ExprKind::Literal('c')));\n    }\n\n    #[test]\n    fn repetition() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Dot,\n            TokenKind::Question,\n            TokenKind::Literal('a'),\n            TokenKind::OpenBrace,\n            TokenKind::Number(2),\n            TokenKind::Comma,\n            TokenKind::Number(3),\n            TokenKind::CloseBrace,\n            TokenKind::Literal('b'),\n        ]));\n\n        let rep = get_repetition(p.parse_repetition());\n        assert!(matches!(rep.kind, RepetitionKind::ZeroOrOne));\n        assert!(matches!(rep.item.kind, ExprKind::Any));\n\n        let rep = get_repetition(p.parse_repetition());\n        assert!(matches!(rep.kind, RepetitionKind::Range(_)));\n        assert!(matches!(rep.item.kind, ExprKind::Literal('a')));\n\n        let expr = unwrap_parse(p.parse_repetition());\n        assert!(matches!(expr.kind, ExprKind::Literal('b')));\n\n        // TODO: detect stray repetition tokens where they don't belong\n    }\n\n    #[test]\n    fn repetition_spec() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Question,\n            TokenKind::Star,\n            TokenKind::Plus,\n            TokenKind::OpenBrace,\n            TokenKind::CloseBrace,\n            TokenKind::Dot,\n        ]));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::ZeroOrOne));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::ZeroOrMore));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::OneOrMore));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::Range(_)));\n\n        let res = p.parse_repetition_spec();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn repetition_range() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenBrace,\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Comma,\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Number(1),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Number(2),\n            TokenKind::Comma,\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Number(3),\n            TokenKind::Comma,\n            TokenKind::Number(4),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Comma,\n            TokenKind::Number(5),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Literal('a'),\n        ]));\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, None);\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, None);\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, Some(1));\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, Some(2));\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, Some(3));\n        assert_eq!(range.end, Some(4));\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, None);\n        assert_eq!(range.end, Some(5));\n\n        let res = p.parse_repetition_range();\n        assert!(matches!(\n            res,\n            Err(Error {\n                kind: ErrorKind::UnexpectedToken(TokenKind::Literal('a'), _),\n                ..\n            })\n        ));\n    }\n\n    #[test]\n    fn item() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Dot,\n            TokenKind::Literal('a'),\n            TokenKind::EndOfText,\n            TokenKind::OpenGroup,\n            TokenKind::Literal('b'),\n            TokenKind::CloseGroup,\n            TokenKind::Digit(true),\n            TokenKind::Whitespace(false),\n            TokenKind::WordChar(true),\n            TokenKind::UnicodeShort('L', true),\n            TokenKind::OpenBracket,\n            TokenKind::Literal('c'),\n            TokenKind::CloseBracket,\n            TokenKind::Star,\n        ]));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Any);\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Literal('a'));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Boundary(_));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Group(_));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Digit(true));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Whitespace(false));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::WordChar(true));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Class(_));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Class(_));\n\n        let res = p.parse_item();\n        assert_err!(res, ErrorKind::UnexpectedToken(TokenKind::Star, _));\n    }\n\n    #[test]\n    fn boundary() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::StartOfLine,\n            TokenKind::EndOfLine,\n            TokenKind::StartOfText,\n            TokenKind::EndOfText,\n            TokenKind::WordBoundary,\n            TokenKind::NonWordBoundary,\n            TokenKind::OpenGroup,\n            TokenKind::CloseGroup,\n        ]));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::StartOfLine));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::EndOfLine));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::StartOfText));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::EndOfText));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::WordBoundary));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::NonWordBoundary));\n\n        let res = p.parse_boundary();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroup,\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n            TokenKind::CloseGroupName,\n            TokenKind::Literal('b'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('c'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('d'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('e'),\n            TokenKind::OpenGroup,\n            TokenKind::CloseGroup,\n        ]));\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::Capturing(_));\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::Named(_));\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::NonCapturing(_));\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, .. }) = group.kind else {\n            panic!(\"not a non-capturing group\");\n        };\n        assert!(flags.is_none());\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::NonCapturing(_));\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, .. }) = group.kind else {\n            panic!(\"not a non-capturing group\");\n        };\n        assert!(flags.is_some());\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::Flags(_));\n\n        let res = p.parse_group();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn group_errors() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroup,\n            TokenKind::Literal('a'),\n        ]));\n\n        let res = p.parse_group();\n        assert!(matches!(\n            res,\n            Err(Error {\n                kind: ErrorKind::UnexpectedEOF(_),\n                ..\n            })\n        ));\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroup,\n            TokenKind::CloseBracket,\n        ]));\n\n        let res = p.parse_group();\n        assert!(matches!(\n            res,\n            Err(Error {\n                kind: ErrorKind::UnexpectedToken(TokenKind::CloseBracket, _),\n                ..\n            })\n        ));\n    }\n\n    #[test]\n    fn non_capturing() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, expr, .. }) = kind else {\n            panic!(\"non a non-capturing group\");\n        };\n\n        assert!(flags.is_none());\n        assert_kind!(expr, ExprKind::Concatenation(_));\n    }\n\n    #[test]\n    fn non_capturing_flags() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, expr, .. }) = kind else {\n            panic!(\"non a non-capturing group\");\n        };\n\n        assert!(flags.is_some());\n        assert_eq!(\n            flags.as_ref().unwrap().set_flags,\n            vec![FlagKind::CaseInsensitive]\n        );\n        assert_eq!(\n            flags.as_ref().unwrap().clear_flags,\n            vec![FlagKind::IgnoreWhitespace]\n        );\n        assert_kind!(expr, ExprKind::Concatenation(_));\n    }\n\n    #[test]\n    fn named_group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n            TokenKind::CloseGroupName,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('b'),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::Named(NamedGroup { name, expr, .. }) = kind else {\n            panic!(\"not a named group\");\n        };\n\n        assert_eq!(name.value, \"name\".to_string());\n        assert_kind!(expr, ExprKind::Concatenation(_));\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n            TokenKind::CloseGroupName,\n            TokenKind::CloseGroupOptions,\n        ]));\n\n        let res = p.parse_group_with_header();\n        assert_err!(\n            res,\n            ErrorKind::UnexpectedToken(TokenKind::CloseGroupOptions, _)\n        );\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n        ]));\n\n        let res = p.parse_group_with_header();\n        assert_err!(res, ErrorKind::UnexpectedEOF(_));\n    }\n\n    #[test]\n    fn flag_group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::SwapGreed),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::Flags(flags) = kind else {\n            panic!(\"not a flag group\");\n        };\n        assert_eq!(\n            flags.flags.set_flags,\n            vec![FlagKind::CaseInsensitive, FlagKind::IgnoreWhitespace],\n        );\n        assert_eq!(\n            flags.flags.clear_flags,\n            vec![FlagKind::MultiLine, FlagKind::SwapGreed],\n        );\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::FlagDelimiter,\n        ]));\n\n        let res = p.parse_group_with_header();\n        assert_err!(\n            res,\n            ErrorKind::UnexpectedToken(TokenKind::FlagDelimiter, ..)\n        );\n    }\n\n    #[test]\n    fn capturing_group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n        ]));\n        p.group_index = 4;\n\n        let kind = unwrap_parse(p.parse_capturing_group());\n        assert!(matches!(kind, GroupKind::Capturing(_)));\n        let GroupKind::Capturing(group) = kind else {\n            panic!(\"not a capturing group\");\n        };\n\n        assert!(matches!(group.expr.kind, ExprKind::Concatenation(_)));\n        assert_eq!(group.index, 4);\n        assert_eq!(p.group_index, 5);\n    }\n\n    #[test]\n    fn flags() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::CRLFMode),\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::Flag(Flag::Unicode),\n            TokenKind::CloseGroupOptions,\n        ]));\n\n        let flags = unwrap_parse(p.parse_flags());\n\n        let expected_set = vec![\n            FlagKind::IgnoreWhitespace,\n            FlagKind::MultiLine,\n            FlagKind::CRLFMode,\n            FlagKind::DotMatchesNewline,\n        ];\n        assert_eq!(expected_set.len(), flags.set_flags.len());\n        for (expected_flag, actual_flag) in expected_set.into_iter().zip(flags.set_flags) {\n            assert_eq!(expected_flag, actual_flag);\n        }\n\n        let expected_clear = vec![\n            FlagKind::CaseInsensitive,\n            FlagKind::SwapGreed,\n            FlagKind::Unicode,\n        ];\n        assert_eq!(expected_clear.len(), flags.clear_flags.len());\n        for (expected_flag, actual_flag) in expected_clear.into_iter().zip(flags.clear_flags) {\n            assert_eq!(expected_flag, actual_flag);\n        }\n    }\n\n    #[test]\n    fn class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::OpenBracket,\n            TokenKind::Negated,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::CloseBracket,\n            TokenKind::Plus,\n        ]));\n\n        let class = get_class(p.parse_class());\n        assert!(matches!(\n            class,\n            Class {\n                kind: ClassKind::Unicode(_),\n                ..\n            }\n        ));\n\n        let class = get_class(p.parse_class());\n        assert!(matches!(\n            class,\n            Class {\n                kind: ClassKind::Specified(_),\n                ..\n            }\n        ));\n\n        let res = p.parse_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn unicode_class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Letter\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::Literal('\\x5A'),\n        ]));\n\n        let class = get_unicode_class(get_class(p.parse_unicode_class()));\n        assert_eq!(class.value.value, \"L\".to_string());\n        assert!(class.name.is_none());\n\n        let class = get_unicode_class(get_class(p.parse_unicode_class()));\n        assert_eq!(class.value.value, \"Letter\".to_string());\n        assert!(class.name.is_none());\n\n        let res = p.parse_unicode_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn unicode_short_class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::UnicodeShort('L', true),\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Letter\".to_string()),\n            TokenKind::CloseBrace,\n        ]));\n\n        let class = get_class(p.parse_unicode_short_class());\n        assert!(!class.negated);\n        let u_class = get_unicode_class(class);\n        assert_eq!(u_class.value.value, \"L\".to_string());\n\n        let class = get_class(p.parse_unicode_short_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert_eq!(u_class.value.value, \"L\".to_string());\n\n        let res = p.parse_unicode_short_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn unicode_long_class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Letter\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Digit\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"sc\".to_string()),\n            TokenKind::Bang,\n            TokenKind::Equal,\n            TokenKind::Name(\"Greek\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"sc\".to_string()),\n            TokenKind::Equal,\n            TokenKind::Name(\"Greek\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"sc\".to_string()),\n            TokenKind::Bang,\n            TokenKind::Equal,\n            TokenKind::Name(\"Greek\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeShort('L', true),\n        ]));\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(!class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_none());\n        assert_eq!(u_class.value.value, \"Letter\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_none());\n        assert_eq!(u_class.value.value, \"Digit\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_some());\n        assert_eq!(u_class.name.unwrap().value, \"sc\".to_string());\n        assert_eq!(u_class.value.value, \"Greek\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_some());\n        assert_eq!(u_class.name.unwrap().value, \"sc\".to_string());\n        assert_eq!(u_class.value.value, \"Greek\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(!class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_some());\n        assert_eq!(u_class.name.unwrap().value, \"sc\".to_string());\n        assert_eq!(u_class.value.value, \"Greek\".to_string());\n\n        let res = p.parse_unicode_long_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn specified_class() {\n        let mut p = Parser::new(span_token_iter(\n            0,\n            vec![\n                (1, TokenKind::OpenBracket),\n                (1, TokenKind::Literal('a')),\n                (1, TokenKind::Literal('b')),\n                (1, TokenKind::Literal('c')),\n                (1, TokenKind::CloseBracket),\n                (1, TokenKind::OpenBracket),\n                (1, TokenKind::Negated),\n                (1, TokenKind::Literal('a')),\n                (1, TokenKind::Literal('b')),\n                (1, TokenKind::Literal('c')),\n                (1, TokenKind::CloseBracket),\n            ],\n        ));\n\n        let class = get_class(p.parse_specified_class());\n        assert!(!class.negated);\n        assert_eq!(class.span.start, 0);\n        assert_eq!(class.span.end, 5);\n        assert!(matches!(class.kind, ClassKind::Specified(_)));\n        let items = get_class_items(class);\n        assert_eq!(items.len(), 3);\n        assert!(matches!(items[0].kind, ClassSpecKind::Literal('a')));\n        assert!(matches!(items[1].kind, ClassSpecKind::Literal('b')));\n        assert!(matches!(items[2].kind, ClassSpecKind::Literal('c')));\n\n        let class = get_class(p.parse_specified_class());\n        assert!(class.negated);\n        assert_eq!(class.span.start, 5);\n        assert_eq!(class.span.end, 11);\n        assert!(matches!(class.kind, ClassKind::Specified(_)));\n        let items = get_class_items(class);\n        assert_eq!(items.len(), 3);\n        assert!(matches!(items[0].kind, ClassSpecKind::Literal('a')));\n        assert!(matches!(items[1].kind, ClassSpecKind::Literal('b')));\n        assert!(matches!(items[2].kind, ClassSpecKind::Literal('c')));\n    }\n\n    #[test]\n    fn spec_class_item() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Intersection,\n            TokenKind::Literal('\\x63'),\n            TokenKind::Symmetrical,\n            TokenKind::Literal('Q'),\n            TokenKind::CloseBracket,\n        ]));\n        let spec = get_class_spec(p.parse_specified_class_item());\n\n        assert!(matches!(spec.kind, ClassSpecKind::Symmetrical(_)));\n        let ClassSpecKind::Symmetrical(spec) = spec.kind else {\n            panic!(\"symmetrical\");\n        };\n\n        assert!(matches!(spec.left.kind, ClassSpecKind::Intersection(_)));\n        assert!(matches!(spec.right.kind, ClassSpecKind::Literal('Q')));\n\n        let ClassSpecKind::Intersection(spec) = spec.left.kind else {\n            panic!(\"intersection\");\n        };\n\n        assert!(matches!(spec.left.kind, ClassSpecKind::Range('a', 'z')));\n        assert!(matches!(spec.right.kind, ClassSpecKind::Literal('\\x63')));\n    }\n\n    #[test]\n    fn class_term() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Digit(true),\n            TokenKind::Whitespace(false),\n            TokenKind::WordChar(false),\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Name(\"alpha\".to_string()),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Literal('a'),\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n        ]));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('a')));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Range('b', 'z')));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Digit(true)));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Whitespace(false)));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::WordChar(false)));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Posix(PosixClass {\n                kind: PosixKind::Alpha,\n                ..\n            })\n        ));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Class(Class {\n                kind: ClassKind::Specified(_),\n                ..\n            })\n        ));\n    }\n\n    #[test]\n    fn class_term_literal() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Range,\n            TokenKind::Literal('c'),\n            TokenKind::Literal('d'),\n            TokenKind::Literal('-'),\n            TokenKind::CloseBracket,\n        ]));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('a')));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Range('b', 'c')));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('d')));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('-')));\n    }\n\n    #[test]\n    fn class_term_bracket() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Negated,\n            TokenKind::Name(\"xdigit\".to_string()),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::CloseBracket,\n            TokenKind::Literal('a'),\n        ]));\n\n        let spec = get_class_spec(p.parse_class_term_bracket());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Posix(PosixClass {\n                kind: PosixKind::XDigit,\n                negated: true,\n                ..\n            })\n        ));\n\n        let spec = get_class_spec(p.parse_class_term_bracket());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Class(Class {\n                kind: ClassKind::Specified(_),\n                ..\n            })\n        ));\n\n        let res = p.parse_class_term_bracket();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn class_item_set() {\n        let lhs = ClassSpec {\n            span: Span::new(2, 3),\n            kind: ClassSpecKind::Literal('c'),\n        };\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Symmetrical,\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Difference,\n            TokenKind::Literal('z'),\n        ]));\n\n        let Ok(spec) = p.parse_class_item_set(lhs) else {\n            panic!(\"parse failed\");\n        };\n        let ClassSpecKind::Difference(set) = spec.kind else {\n            panic!(\"difference set\");\n        };\n        assert!(matches!(set.left.kind, ClassSpecKind::Symmetrical(_)));\n        assert!(matches!(set.right.kind, ClassSpecKind::Literal('z')));\n\n        let ClassSpecKind::Symmetrical(set) = set.left.kind else {\n            panic!(\"symmetrical set\");\n        };\n        assert!(matches!(set.left.kind, ClassSpecKind::Literal('c')));\n        assert!(matches!(set.right.kind, ClassSpecKind::Range('a', 'z')));\n    }\n}\n","traces":[{"line":90,"address":[212624,212785,212432,212593],"length":1,"stats":{"Line":9},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":892,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":977,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":996,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1005,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1079,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1080,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1099,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1114,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1220,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1224,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1226,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1227,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1228,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1232,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1233,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1235,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1288,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1295,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1303,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1307,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1312,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1317,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1324,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1327,"address":[214544,214024,213530,214517,214997,213568,214064,213088],"length":1,"stats":{"Line":5},"fn_name":null},{"line":1331,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":1338,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1341,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1343,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[221616,220868,216944,215108,220784,215024,216816,215984,219908,220656,221744,219824,219696,217776,215856,217904,218736,217988,217028,218864,222576,221828,218948,216068],"length":1,"stats":{"Line":12},"fn_name":null},{"line":1357,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":1358,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":1359,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1361,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1363,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1365,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":351,"coverable":436},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","pretty.rs"],"content":"use aglet_pretty::{Pretty, Result, Writer};\nuse colored::Color;\n\nuse crate::parse::ast::*;\n\nconst COLOR_BOUNDARY: Option\u003cColor\u003e = Some(Color::BrightRed);\nconst COLOR_REPETITION: Option\u003cColor\u003e = Some(Color::Cyan);\nconst COLOR_MATCH_ONE: Option\u003cColor\u003e = Some(Color::Green);\nconst COLOR_CLASS_ITEM: Option\u003cColor\u003e = Some(Color::BrightYellow);\n\nimpl Pretty for Expr {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            ExprKind::Any =\u003e w.print_ast(\".\", Some(self.span), COLOR_MATCH_ONE).finish(),\n            ExprKind::Literal(c) =\u003e w\n                .print_ast(\"Literal\", Some(self.span), COLOR_MATCH_ONE)\n                .property(None, c, None)\n                .finish(),\n            ExprKind::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ExprKind::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ExprKind::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ExprKind::Empty =\u003e w.print_ast(\"Expr\", Some(self.span), None).finish(),\n            _ =\u003e w.print(\u0026self.kind),\n        }\n    }\n}\n\nimpl Pretty for ExprKind {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match self {\n            Self::Alternation(alt) =\u003e w.print(alt),\n            Self::Concatenation(concat) =\u003e w.print(concat),\n            Self::Repetition(rep) =\u003e w.print(rep),\n            Self::Any =\u003e w.print_ast(\"Any\", None, None).finish(),\n            Self::Literal(c) =\u003e w\n                .print_ast(\"Literal\", None, COLOR_MATCH_ONE)\n                .property(None, c, None)\n                .finish(),\n            Self::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", None, COLOR_MATCH_ONE)\n                .maybe_property(None, if *negated { Some(\u0026\"negated\") } else { None }, None)\n                .finish(),\n            Self::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", None, COLOR_MATCH_ONE)\n                .maybe_property(None, if *negated { Some(\u0026\"negated\") } else { None }, None)\n                .finish(),\n            Self::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", None, COLOR_MATCH_ONE)\n                .maybe_property(None, if *negated { Some(\u0026\"negated\") } else { None }, None)\n                .finish(),\n            Self::Boundary(boundary) =\u003e w.print(boundary),\n            Self::Group(group) =\u003e w.print(group),\n            Self::Class(class) =\u003e w.print(class),\n            Self::Empty =\u003e w.print_ast(\"Expr\", None, None).finish(),\n        }\n    }\n}\n\nimpl Pretty for Alternation {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let mut printer = w.print_ast(\"Alt\", Some(self.span), None);\n        for expr in \u0026self.items {\n            printer.child(None, expr);\n        }\n        printer.finish()\n    }\n}\n\nimpl Pretty for Concatenation {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let mut printer = w.print_ast(\"Concat\", Some(self.span), None);\n        for expr in \u0026self.items {\n            printer.child(None, expr);\n        }\n        printer.finish()\n    }\n}\n\nimpl Pretty for Repetition {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            RepetitionKind::ZeroOrOne =\u003e w\n                .print_ast(\"ZeroOrOne\", Some(self.span), COLOR_REPETITION)\n                .child(None, \u0026*self.item)\n                .finish(),\n            RepetitionKind::ZeroOrMore =\u003e w\n                .print_ast(\"ZeroOrMore\", Some(self.span), COLOR_REPETITION)\n                .child(None, \u0026*self.item)\n                .finish(),\n            RepetitionKind::OneOrMore =\u003e w\n                .print_ast(\"OneOrMore\", Some(self.span), COLOR_REPETITION)\n                .child(None, \u0026*self.item)\n                .finish(),\n            RepetitionKind::Range(range) =\u003e w\n                .print_ast(\"Range\", Some(self.span), COLOR_REPETITION)\n                .property(Some(\"start\"), \u0026range.start.unwrap_or(0), None)\n                .maybe_property(Some(\"end\"), range.end.as_ref(), None)\n                .child(None, \u0026*self.item)\n                .finish(),\n        }\n    }\n}\n\nimpl Pretty for Boundary {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let boundary_title = format!(\"{:?}\", self.kind);\n        w.print_ast(boundary_title.as_ref(), Some(self.span), COLOR_BOUNDARY)\n            .finish()\n    }\n}\n\nimpl Pretty for Group {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print(\u0026self.kind)\n    }\n}\n\nimpl Pretty for GroupKind {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match self {\n            Self::Capturing(capturing) =\u003e w.print(capturing),\n            Self::Named(named) =\u003e w.print(named),\n            Self::NonCapturing(non_capturing) =\u003e w.print(non_capturing),\n            Self::Flags(flags) =\u003e w.print(flags),\n            Self::Empty =\u003e w.print_ast(\"Group\", None, None).finish(),\n        }\n    }\n}\n\nimpl Pretty for CapturingGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Group\", Some(self.span), None)\n            .property(Some(\"index\"), \u0026self.index, None)\n            .child(None, \u0026*self.expr)\n            .finish()\n    }\n}\n\nimpl Pretty for NamedGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Group\", Some(self.span), None)\n            .property(Some(\"name\"), \u0026self.name.value, None)\n            .child(None, \u0026*self.expr)\n            .finish()\n    }\n}\n\nimpl Pretty for NonCapturingGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let mut printer = w.print_ast(\"Group\", Some(self.span), None);\n        if let Some(flags) = \u0026self.flags {\n            printer.child(None, flags);\n        }\n\n        printer.child(None, \u0026*self.expr).finish()\n    }\n}\n\nimpl Pretty for FlagGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print(\u0026self.flags)\n    }\n}\n\nimpl Pretty for Flags {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Flags\", Some(self.span), None)\n            .property(Some(\"set\"), \u0026self.set_flags, None)\n            .property(Some(\"clear\"), \u0026self.clear_flags, None)\n            .finish()\n    }\n}\n\nimpl Pretty for Class {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            ClassKind::Unicode(class) =\u003e w\n                .print_ast(\"UnicodeClass\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if self.negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .maybe_property(\n                    Some(\"name\"),\n                    class.name.as_ref().map(|name| \u0026name.value).as_ref(),\n                    None,\n                )\n                .property(Some(\"value\"), \u0026class.value.value, None)\n                .finish(),\n            ClassKind::Specified(class) =\u003e w\n                .print_ast(\"SpecifiedClass\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if self.negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .children(\u0026class.items)\n                .finish(),\n        }\n    }\n}\n\nimpl Pretty for ClassSpec {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            ClassSpecKind::Literal(c) =\u003e w\n                .print_ast(\"Literal\", Some(self.span), COLOR_CLASS_ITEM)\n                .property(None, c, None)\n                .finish(),\n            ClassSpecKind::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", Some(self.span), COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ClassSpecKind::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", Some(self.span), COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ClassSpecKind::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", Some(self.span), COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ClassSpecKind::Range(start, end) =\u003e w\n                .print_ast(\"Range\", Some(self.span), COLOR_CLASS_ITEM)\n                .property(Some(\"start\"), start, None)\n                .property(Some(\"end\"), end, None)\n                .finish(),\n            _ =\u003e w.print(\u0026self.kind),\n        }\n    }\n}\n\nimpl Pretty for ClassSpecKind {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match self {\n            Self::Intersection(intersection) =\u003e w.print(intersection),\n            Self::Difference(difference) =\u003e w.print(difference),\n            Self::Symmetrical(symmetrical) =\u003e w.print(symmetrical),\n            Self::Literal(c) =\u003e w\n                .print_ast(\"Literal\", None, COLOR_CLASS_ITEM)\n                .property(None, c, None)\n                .finish(),\n            Self::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", None, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            Self::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", None, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            Self::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", None, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            Self::Range(start, end) =\u003e w\n                .print_ast(\"Range\", None, COLOR_CLASS_ITEM)\n                .property(Some(\"start\"), start, None)\n                .property(Some(\"end\"), end, None)\n                .finish(),\n            Self::Posix(posix) =\u003e w.print(posix),\n            Self::Class(class) =\u003e w.print(class),\n            Self::Empty =\u003e w.print_ast(\"Empty\", None, COLOR_CLASS_ITEM).finish(),\n        }\n    }\n}\n\nimpl Pretty for Intersection {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Intersection\", Some(self.span), COLOR_CLASS_ITEM)\n            .child(None, \u0026*self.left)\n            .child(None, \u0026*self.right)\n            .finish()\n    }\n}\n\nimpl Pretty for Difference {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Difference\", Some(self.span), COLOR_CLASS_ITEM)\n            .child(None, \u0026*self.left)\n            .child(None, \u0026*self.right)\n            .finish()\n    }\n}\n\nimpl Pretty for Symmetrical {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"SymmectricalDifference\", Some(self.span), COLOR_CLASS_ITEM)\n            .child(None, \u0026*self.left)\n            .child(None, \u0026*self.right)\n            .finish()\n    }\n}\n\nimpl Pretty for PosixClass {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"PosixClass\", Some(self.span), COLOR_CLASS_ITEM)\n            .property(None, \u0026self.kind, None)\n            .finish()\n    }\n}\n","traces":[{"line":12,"address":[524528],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":13,"address":[524561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[524671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[524788,524901,524822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[524796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[524881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[524970,525644,525013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[524978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[525084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[525607,525111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[525636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[525140,525743,525183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[525148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[525254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[525706,525281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[525735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[525845,525310,525353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[525318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[525424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[525808,525451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[525837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[525475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[524641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[525920],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":51,"address":[525952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[526008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[526041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[526074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[526103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[526205,526280,526188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[526196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[526263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[526360,526950,526340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[526348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[526430,526913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[527049,526485,526465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[526473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[527012,526555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[526610,527151,526590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[526598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[526680,527114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[526715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[526748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[526778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[526804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[527216],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":82,"address":[527251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[527408,527328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[527421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[527384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[527456],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":92,"address":[527491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[527648,527568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[527661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[527624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[527696],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":102,"address":[527729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[527817,527892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[527790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[527879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[527975,528053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[527942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[528037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[528232,528145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[528109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[528216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[528335,528466,528626,528573,528291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[528299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[528406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[528521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[528610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[529110,528688],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":127,"address":[528721,528780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[528953,528875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[529136],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":135,"address":[529161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[529184],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":141,"address":[529211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[529252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[529287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[529322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[529354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[529384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[529472],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":153,"address":[529609,529654,529502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[529579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[529642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[529696],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":162,"address":[529726,529829,529875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[529803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[529862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[529920],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":171,"address":[529955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[530032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[530082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[530116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[530176],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":182,"address":[530201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[530224],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":188,"address":[530262,530428,530365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[530339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[530398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[530480],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":197,"address":[530513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[530909,530569,530603,531025,531094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[530577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[530665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[530881,530686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[530904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[530948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[231256,231248],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":208,"address":[531017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[531059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[530716,530768,531192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[530733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[530839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[531155,530866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[531184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[531280],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":227,"address":[531313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[531535,531462,531428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[531436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[531521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[531595,531638,532438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[531603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[531703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[531730,532401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[532430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[532534,531802,531759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[531767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[531873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[531900,532497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[532526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[532636,531972,531929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[531937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[532043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[532599,532070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[532628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[532099,532340,532261,532158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[532123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[532226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[532305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[531393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[532704],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":268,"address":[532737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[532794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[532828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[532862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[532986,532896,532913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[532904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[532972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[533058,533041,533941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[533049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[533120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[533904,533147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[533933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[533191,534037,533171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[533179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[533262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[534000,533289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[534029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[533333,534139,533313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[533321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[533404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[534102,533431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[534131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[533455,533491,533673,533594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[533479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[533559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[533638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[533732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[533766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[533792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[534208],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":314,"address":[534240,534373,534332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[534320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[534360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[534416],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":323,"address":[534581,534540,534448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[534528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[534568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[534624],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":332,"address":[534748,534789,534656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[534736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[534776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[534832],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":341,"address":[534959,534862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[534941],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":188},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","error.rs"],"content":"use std::{fmt, ops, result};\n\nuse aglet_text::Span;\n\nuse crate::tokenize::state::StateStack;\n\npub type Result\u003cT\u003e = result::Result\u003cT, Error\u003e;\npub type StackResult\u003cT\u003e = result::Result\u003cT, StackError\u003e;\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    pub span:  Span,\n    pub cause: ErrorCause,\n}\n\nimpl Error {\n    pub fn new(span: Span, cause: ErrorCause) -\u003e Self {\n        Error { span, cause }\n    }\n\n    pub fn is_fatal(\u0026self) -\u003e bool {\n        matches!(self.cause, ErrorCause::FatalError(_))\n    }\n\n    pub fn is_eof(\u0026self) -\u003e bool {\n        matches!(self.cause, ErrorCause::Error(ErrorKind::EndOfFile))\n    }\n\n    pub fn is_any_eof(\u0026self) -\u003e bool {\n        matches!(\n            self.cause,\n            ErrorCause::Error(ErrorKind::EndOfFile | ErrorKind::UnexpectedEOF(_))\n        )\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}) {}\", self.span, self.cause)\n    }\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub struct StackError {\n    pub error: Error,\n    pub stack: StateStack,\n}\n\nimpl StackError {\n    pub fn from_error(error: Error, stack: StateStack) -\u003e Self {\n        StackError { error, stack }\n    }\n}\n\nimpl fmt::Display for StackError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}) {}\", self.span, self.cause)\n    }\n}\n\nimpl ops::Deref for StackError {\n    type Target = Error;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.error\n    }\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum ErrorCause {\n    #[error(\"{0}\")]\n    Error(#[from] ErrorKind),\n\n    #[error(\"fatal error: {0}\")]\n    FatalError(#[from] FatalErrorKind),\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum ErrorKind {\n    #[error(\"end of file\")]\n    EndOfFile,\n\n    #[error(\"unexpected end of file: {0}\")]\n    UnexpectedEOF(String),\n\n    #[error(\"unexpected `{0}`\")]\n    UnexpectedChar(char),\n\n    #[error(\"invalid hex digit `{0}`\")]\n    InvalidHexDigit(char),\n\n    #[error(\"invalid character code `{0}`\")]\n    InvalidCharCode(String),\n\n    #[error(\"unrecognized escape sequence: \\\\{0}\")]\n    UnrecognizedEscape(char),\n\n    #[error(\"unrecognized flag: {0}\")]\n    UnrecognizedFlag(char),\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum FatalErrorKind {\n    #[error(\"state stack is empty\")]\n    EmptyStateStack,\n\n    #[error(\"internal state error: {0}\")]\n    InternalStateError(StateError),\n\n    #[error(\"not implemented\")]\n    NotImplemented,\n}\n\nimpl From\u003cStateError\u003e for ErrorCause {\n    fn from(value: StateError) -\u003e Self {\n        ErrorCause::FatalError(value.into())\n    }\n}\n\nimpl From\u003cStateError\u003e for FatalErrorKind {\n    fn from(err: StateError) -\u003e Self {\n        FatalErrorKind::InternalStateError(err)\n    }\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum StateError {\n    #[error(\"no state on tokenizer stack\")]\n    NoStateOnStack,\n\n    #[error(\"cannot pop final state from tokenizer stack\")]\n    PoppedFinalState,\n}\n","traces":[{"line":17,"address":[201072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[201136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[5037141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[5037168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[5037178],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[5037248],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[201272,201285],"length":1,"stats":{"Line":8},"fn_name":null},{"line":31,"address":[201258,201283],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[201328],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":39,"address":[201349,201451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[201536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[201616],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":57,"address":[201646,201728,201801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[201888],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":115,"address":[201904],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":116,"address":[201929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[201968],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":122,"address":[201980],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":18},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","mod.rs"],"content":"pub mod error;\nmod pretty;\nmod state;\npub mod token;\npub mod tokenizer;\n\npub use error::{Error, ErrorCause, ErrorKind, FatalErrorKind, Result};\npub use token::{Flag, Token, TokenKind};\npub use tokenizer::Tokenizer;\n\n#[cfg(test)]\nmacro_rules! assert_next_tok {\n    ( $tokenizer:expr , $kind:pat ) =\u003e {\n        let next = $tokenizer.next();\n        if !matches!(next, Some(Ok(Token { kind: $kind, .. }))) {\n            panic!(\"{:?} does not match token {}\", next, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_next_err {\n    ( $tokenizer:expr , $kind:pat ) =\u003e {\n        let next = $tokenizer.next();\n        if !matches!(\n            next,\n            Some(Err(Error {\n                cause: ErrorCause::Error($kind),\n                ..\n            }))\n        ) {\n            panic!(\"{:?} does not match error {}\", next, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_next_none {\n    ( $tokenizer:expr ) =\u003e {\n        let next = $tokenizer.next();\n        if !next.is_none() {\n            panic!(\"{:?} is not None\", next);\n        }\n    };\n}\n\n#[cfg(test)]\npub(crate) fn assert_tokens(mut tr: Tokenizer, tokens: Vec\u003cTokenKind\u003e) {\n    let total_expected = tokens.len();\n    let mut count = 0;\n    for (i, expected) in tokens.iter().enumerate() {\n        let actual = tr\n            .next()\n            .expect(\u0026format!(\n                \"ran out of tokens; expecting {:?} ({})\",\n                expected, i\n            ))\n            .unwrap_or_else(|err| {\n                panic!(\"received error {:?}; expecting {:?} ({})\", err, expected, i)\n            })\n            .kind;\n\n        assert_eq!(expected, \u0026actual, \"failed to match token {}\", i);\n        count += 1;\n    }\n\n    assert_eq!(total_expected, count);\n    assert_next_none!(tr);\n}\n\n#[cfg(test)]\npub(crate) use assert_next_err;\n#[cfg(test)]\npub(crate) use assert_next_none;\n#[cfg(test)]\npub(crate) use assert_next_tok;\n","traces":[{"line":48,"address":[441490,440317,439344],"length":1,"stats":{"Line":1},"fn_name":"assert_tokens"},{"line":49,"address":[439465,439386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[439473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[439485,439839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[440936,439879,440846,440768],"length":1,"stats":{"Line":8},"fn_name":null},{"line":53,"address":[440328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[440564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[278448,278893],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":59,"address":[278782,278594,278683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[440892,440968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[441263,441035],"length":1,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[441221,441413,441439],"length":1,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[439905,439741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[439971,440155,440049],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","pretty.rs"],"content":"use aglet_pretty::{Pretty, Result, Writer};\nuse colored::Color;\n\nuse crate::tokenize::error::{Error, StackError};\nuse crate::tokenize::state::State;\nuse crate::tokenize::token::*;\n\nconst COLOR_BOUNDARY: Option\u003cColor\u003e = Some(Color::BrightRed);\nconst COLOR_REPETITION: Option\u003cColor\u003e = Some(Color::Cyan);\nconst COLOR_MATCH_ONE: Option\u003cColor\u003e = Some(Color::Green);\nconst COLOR_CLASS_ITEM: Option\u003cColor\u003e = Some(Color::BrightYellow);\nconst COLOR_ERROR: Option\u003cColor\u003e = Some(Color::Red);\n\nimpl Pretty for TokenStack {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let stack = Some(format!(\"\\t\\u{2192} {:?}\", self.stack));\n        let top_state = self.stack.get().map(|state| *state).ok();\n\n        self.token.pretty_print(stack, top_state, w)\n    }\n}\n\nimpl Pretty for Token {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        self.pretty_print(None, None, w)\n    }\n}\n\nimpl Pretty for StackError {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let stack = Some(format!(\"\\t\\u{2192} {:?}\", self.stack));\n        w.print_token(\"Error\", Some(self.span), stack, COLOR_ERROR)\n            .property(None, \u0026self.cause.to_string(), None)\n            .finish()\n    }\n}\n\nimpl Pretty for Error {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_token(\"Error\", Some(self.span), None, COLOR_ERROR)\n            .property(None, \u0026self.cause.to_string(), None)\n            .finish()\n    }\n}\n\nimpl Token {\n    fn pretty_print(\n        \u0026self,\n        stack: Option\u003cString\u003e,\n        top_state: Option\u003cState\u003e,\n        w: \u0026mut Writer\u003c'_\u003e,\n    ) -\u003e Result {\n        match \u0026self.kind {\n            TokenKind::Literal(c) =\u003e w\n                .print_token(\n                    \"Literal\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .property(None, c, None)\n                .finish(),\n            TokenKind::Digit(negated) =\u003e w\n                .print_token(\n                    \"Digit\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::Whitespace(negated) =\u003e w\n                .print_token(\n                    \"Whitespace\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::WordChar(negated) =\u003e w\n                .print_token(\n                    \"WordChar\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::Dot =\u003e w\n                .print_token(\"Dot\", Some(self.span), stack, COLOR_MATCH_ONE)\n                .finish(),\n            TokenKind::Alternate =\u003e w\n                .print_token(\"Alternate\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::StartOfLine =\u003e w\n                .print_token(\"StartOfLine\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::EndOfLine =\u003e w\n                .print_token(\"EndOfLine\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::StartOfText =\u003e w\n                .print_token(\"StartOfText\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::EndOfText =\u003e w\n                .print_token(\"EndOfText\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::WordBoundary =\u003e w\n                .print_token(\"WordBoundary\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::NonWordBoundary =\u003e w\n                .print_token(\"NonWordBoundary\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::OpenBrace =\u003e w\n                .print_token(\n                    \"OpenBrace\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Range)) {\n                        COLOR_REPETITION\n                    } else if matches!(top_state, Some(State::UnicodeProperties)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        None\n                    },\n                )\n                .finish(),\n            TokenKind::CloseBrace =\u003e w\n                .print_token(\n                    \"CloseBrace\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Range)) {\n                        COLOR_REPETITION\n                    } else if matches!(top_state, Some(State::UnicodeProperties)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        None\n                    },\n                )\n                .finish(),\n            TokenKind::Number(value) =\u003e w\n                .print_token(\"Number\", Some(self.span), stack, COLOR_REPETITION)\n                .property(None, value, None)\n                .finish(),\n            TokenKind::Comma =\u003e w\n                .print_token(\"Comma\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::Question =\u003e w\n                .print_token(\"Question\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::Star =\u003e w\n                .print_token(\"Star\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::Plus =\u003e w\n                .print_token(\"Plus\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::OpenGroup =\u003e w\n                .print_token(\"OpenGroup\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::CloseGroup =\u003e w\n                .print_token(\"CloseGroup\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::OpenGroupOptions =\u003e w\n                .print_token(\"OpenGroupOptions\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::CloseGroupOptions =\u003e w\n                .print_token(\"CloseGroupOptions\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::OpenGroupName =\u003e w\n                .print_token(\"OpenGroupName\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::CloseGroupName =\u003e w\n                .print_token(\"CloseGroupName\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::Flag(flag) =\u003e w\n                .print_token(\"Flag\", Some(self.span), stack, None)\n                .property(None, flag, None)\n                .finish(),\n            TokenKind::FlagDelimiter =\u003e w\n                .print_token(\"FlagDelimiter\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::OpenBracket =\u003e w\n                .print_token(\"OpenBracket\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::CloseBracket =\u003e w\n                .print_token(\"CloseBracket\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Colon =\u003e w\n                .print_token(\"Colon\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Negated =\u003e w\n                .print_token(\"Negated\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Range =\u003e w\n                .print_token(\"Range\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Symmetrical =\u003e w\n                .print_token(\"Symmetrical\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Difference =\u003e w\n                .print_token(\"Difference\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Intersection =\u003e w\n                .print_token(\"Intersection\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::UnicodeShort(category, negated) =\u003e w\n                .print_token(\"UnicodeShort\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .property(None, category, None)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::UnicodeLong(negated) =\u003e w\n                .print_token(\"UnicodeLong\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::Equal =\u003e w\n                .print_token(\"Equal\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Bang =\u003e w\n                .print_token(\"Bang\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Name(name) =\u003e w\n                .print_token(\n                    \"Name\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::ClassName | State::UnicodeProperties)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        None\n                    },\n                )\n                .property(None, name, None)\n                .finish(),\n        }\n    }\n}\n","traces":[{"line":15,"address":[552753,552336,552784],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":16,"address":[552369,552441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[547573,547568],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":19,"address":[552672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[552800],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":25,"address":[552817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[202642,202000],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":31,"address":[202033,202100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[202209,202588,202490,202272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[202438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[202996,202688],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":40,"address":[202950,202869,202729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[202829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[552864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[552908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[552944,558500,558577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[552964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[558475,553000,558421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[558477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[558462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[558557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[553036,558725,558854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[553056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[558646,553092,558700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[558702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[558687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[558785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[558812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[558846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[558998,559127,553128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[553148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[558919,558973,553184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[558975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[558960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[559058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[559085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[559119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[559271,553220,559400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[553240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[559246,559192,553276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[559248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[559233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[559331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[559358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[559392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[553358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[553322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[553505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[553461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[553633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[553597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[553772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[553736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[553911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[553875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[554050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[554014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[554189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[554153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[554328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[554292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[559619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[554421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[559543,554457,559465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[559530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[559545,559594,559506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[559596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[559586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[559850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[554493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[554529,559696,559774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[559761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[559737,559776,559825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[559827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[559817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[554719,554575,554631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[554595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[554699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[554827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[554791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[554966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[554930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[555105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[555069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[555244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[555208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[555391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[555347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[555527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[555483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[555663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[555619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[555799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[555755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[555935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[555891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[556071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[556027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[556163,556303,556226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[556182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[556283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[556419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[556375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[556547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[556511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[556686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[556650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[556825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[556789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[556964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[556928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[557103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[557067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[557242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[557206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[557381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[557345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[557520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[557484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[557623,557693,557781,559969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[557657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[557761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[557831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[557858,559927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[559961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[557938,557888,560063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[557902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[558009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[560026,558036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[560055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[558102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[558066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[558241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[558205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[558334,560220,560297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[558354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[560128,560195,558390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[560197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[560187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[560277],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":140},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","state.rs"],"content":"use std::fmt;\n\nuse crate::tokenize::error::StateError;\n\n#[derive(Clone, PartialEq, Eq)]\npub struct StateStack {\n    pub stack: Vec\u003cStateFlags\u003e,\n}\n\nimpl StateStack {\n    pub(crate) fn new() -\u003e Self {\n        StateStack {\n            stack: vec![StateFlags::default()],\n        }\n    }\n\n    pub(crate) fn push(\u0026mut self, state: State) {\n        let flags = self.stack.last().map(|sf| sf.flags).unwrap_or_default();\n\n        self.stack.push(StateFlags { state, flags });\n    }\n\n    pub(crate) fn swap(\u0026mut self, state: State) -\u003e Result\u003cState, StateError\u003e {\n        let former = self.stack.pop().ok_or(StateError::NoStateOnStack)?;\n        let flags = former.flags;\n\n        self.stack.push(StateFlags { state, flags });\n        Ok(former.state)\n    }\n\n    pub(crate) fn pop(\u0026mut self) -\u003e Result\u003cState, StateError\u003e {\n        if self.stack.len() == 1 {\n            return Err(StateError::PoppedFinalState);\n        }\n\n        self.stack\n            .pop()\n            .map(|sf| sf.state)\n            .ok_or(StateError::NoStateOnStack)\n    }\n\n    pub(crate) fn pop_all(\u0026mut self) -\u003e Result\u003c(), StateError\u003e {\n        if self.stack.len() == 1 {\n            return Err(StateError::PoppedFinalState);\n        }\n\n        self.stack.clear();\n        self.stack.push(StateFlags::default());\n\n        Ok(())\n    }\n\n    pub(crate) fn flags(\u0026self) -\u003e Result\u003c\u0026Flags, StateError\u003e {\n        let top = self.stack.last().ok_or(StateError::NoStateOnStack)?;\n\n        Ok(\u0026top.flags)\n    }\n\n    pub(crate) fn flags_mut(\u0026mut self) -\u003e Result\u003c\u0026mut Flags, StateError\u003e {\n        let top = self.stack.last_mut().ok_or(StateError::NoStateOnStack)?;\n\n        Ok(\u0026mut top.flags)\n    }\n\n    pub(crate) fn get(\u0026self) -\u003e Result\u003c\u0026State, StateError\u003e {\n        self.stack\n            .last()\n            .map(|sf| \u0026sf.state)\n            .ok_or(StateError::NoStateOnStack)\n    }\n}\n\nimpl fmt::Debug for StateStack {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut list = f.debug_list();\n        self.stack.iter().for_each(|sf| {\n            list.entry(\u0026sf);\n        });\n\n        list.finish()\n    }\n}\n\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq)]\npub enum State {\n    #[default]\n    Main,\n    GroupOptions,\n    Class,\n    ClassName,\n    Range,\n    UnicodeProperties,\n}\n\n#[derive(Default, Clone, Copy, PartialEq, Eq)]\npub struct Flags {\n    pub(crate) unset_flags:  bool,\n    pub(crate) ignore_space: bool,\n}\n\nimpl fmt::Debug for Flags {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut list = f.debug_list();\n        if self.ignore_space {\n            list.entry(\u0026'x');\n        }\n\n        list.finish()\n    }\n}\n\n#[derive(Default, Clone, Copy, PartialEq, Eq)]\npub struct StateFlags {\n    state: State,\n    flags: Flags,\n}\n\nimpl fmt::Debug for StateFlags {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:?}\", self.state)?;\n        if self.flags.ignore_space {\n            write!(f, \"(x)\")?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[209817,209568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[209592,209794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[209840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[209865],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[209922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[209968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[210259,209993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[210196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[210212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[210244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[210320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[210334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[210345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[210372,210435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[580148,580112],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":39,"address":[210430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[210480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[210494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[210505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[210527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[210532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[210595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[210624],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[210756,210654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[210742],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[210800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[210932,210830],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[210918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[210976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[211043,211006],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[580160,580168],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":69,"address":[211038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[211072],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":75,"address":[211091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[211107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[580190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[211149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[211184],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":103,"address":[211202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[211217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[211244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[211223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[211280],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":120,"address":[211313,211478,211372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[211470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[211297,211506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[211499],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":47},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","token.rs"],"content":"use std::convert::TryFrom;\nuse std::fmt;\n\nuse aglet_text::Span;\n\nuse crate::tokenize::error::ErrorKind;\nuse crate::tokenize::state::StateStack;\n\n#[derive(Clone, PartialEq, Eq)]\npub struct Token {\n    pub span: Span,\n    pub kind: TokenKind,\n}\n\nimpl fmt::Debug for Token {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_tuple(\"tok\")\n            .field(\u0026self.span)\n            .field(\u0026self.kind)\n            .finish()\n    }\n}\n\nimpl Token {\n    pub fn new_with_offsets(kind: TokenKind, start: usize, end: usize) -\u003e Self {\n        Self {\n            span: Span::new(start, end),\n            kind,\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum Flag {\n    /// `i`: Letters match regardless of case\n    CaseInsensitive,\n\n    /// `m`: `^` and `$` match the beginning and end of a line\n    MultiLine,\n\n    /// `s`: allow `.` to match `\\n`\n    DotMatchesNewline,\n\n    /// `R`: use `\\r\\n` when multi-line mode is enabled\n    CRLFMode,\n\n    /// `U`: swap the meaning of `x*` and `x*?`\n    SwapGreed,\n\n    /// `u`: enable unicode support\n    Unicode,\n\n    /// `x`: ignore whitespace and enable line comments (beginning with `#`)\n    IgnoreWhitespace,\n}\n\nimpl TryFrom\u003cchar\u003e for Flag {\n    type Error = ErrorKind;\n\n    fn try_from(value: char) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            'i' =\u003e Ok(Self::CaseInsensitive),\n            'm' =\u003e Ok(Self::MultiLine),\n            's' =\u003e Ok(Self::DotMatchesNewline),\n            'R' =\u003e Ok(Self::CRLFMode),\n            'U' =\u003e Ok(Self::SwapGreed),\n            'u' =\u003e Ok(Self::Unicode),\n            'x' =\u003e Ok(Self::IgnoreWhitespace),\n            c =\u003e Err(ErrorKind::UnrecognizedFlag(c)),\n        }\n    }\n}\n\nimpl Flag {\n    pub fn is_flag_char(c: char) -\u003e bool {\n        match c {\n            'i' | 'm' | 's' | 'R' | 'U' | 'u' | 'x' =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_ignore_whitespace(\u0026self) -\u003e bool {\n        matches!(self, Self::IgnoreWhitespace)\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum TokenKind {\n    /// A literal character to be matched, or as part of a character class\n    Literal(char),\n\n    /// Digit character class `\\d`--or negated as `\\D`--either to be matched\n    /// or as a subclass in a specified character class (e.g. `[\\d]`).\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    Digit(bool),\n\n    /// Whitespace character class `\\s`--or negated as `\\S`--either to be matched\n    /// or as a subclass in a specified character class (e.g., `[\\s]`).\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    Whitespace(bool),\n\n    /// Word character class `\\w`--or negated as `\\W`--either to be matched\n    /// or as a subclass in a specified character class (e.g., `[\\w]`).\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    WordChar(bool),\n\n    /// \"Any\" character class `.` matching any input character\n    Dot,\n\n    /// Alternation operator `|` introducing another possible match\n    Alternate,\n\n    // Boundaries ==================================================\n    /// Start of line anchor `^`\n    StartOfLine,\n\n    /// End of line anchor `$`\n    EndOfLine,\n\n    /// Start of text anchor `\\A`\n    StartOfText,\n\n    /// End of text anchor `\\z`\n    EndOfText,\n\n    /// Word boundary `\\b`\n    WordBoundary,\n\n    /// Non-word boundary `\\B`\n    NonWordBoundary,\n\n    // Repetition ==================================================\n    /// Open brace `{` starting a specified repetition range (e.g. `.{1, 2}`)\n    OpenBrace,\n\n    /// Close brace `}` ending a specified repetition range (e.g. `.{1, 2}`)\n    CloseBrace,\n\n    /// A number inside a specified repetition range (e.g. `.{1, 2}`)\n    ///\n    /// # Items\n    ///\n    /// * `0` - value of the number\n    Number(usize),\n\n    /// Comma separating the start and end of a repetition range (e.g. `.{1, 2}`)\n    Comma,\n\n    /// Zero-or-one repetition `?`\n    Question,\n\n    /// Zero-or-more repetition `*`\n    Star,\n\n    /// One-or-more repetition `+`\n    Plus,\n\n    // Groups ==================================================\n    /// Beginning of a group `(`\n    OpenGroup,\n\n    /// End of a group `)`\n    CloseGroup,\n\n    /// Start of group options `?` in e.g. `(?\u003cname\u003e...)`\n    OpenGroupOptions,\n\n    /// End of group options `:` in e.g. `(?isx:...)`\n    CloseGroupOptions,\n\n    /// Start of group name `\u003c` or `P\u003c` in e.g. `(?P\u003cname\u003e...)`\n    OpenGroupName,\n\n    /// End of group name `\u003e` in e.g. `(?\u003cname\u003e...)`\n    CloseGroupName,\n\n    /// Flags in group options or a non-capturing flags group (e.g. `(?i-x)`)\n    Flag(Flag),\n\n    /// Delimiter character `-` between flags to be set and flags to be cleared (e.g. `(?i-x)`)\n    FlagDelimiter,\n\n    // Character classes ==================================================\n    /// Open bracket `[` beginning a specified character class or a posix class\n    /// (e.g. `[a-z]`, `[[:alpha:]]`])\n    OpenBracket,\n\n    /// Close bracket `]` ending a specified character class or a posix class\n    /// (e.g. `[a-z]`, `[[:alpha:]]`)\n    CloseBracket,\n\n    /// Surrounding token `:` for named posix classes (e.g. `[[:alpha:]]`)\n    Colon,\n\n    /// Negation marker `^` negating a specified character class or a posix class\n    /// (e.g. `[^a-z]`, `[[:^alpha:]]`)\n    Negated,\n\n    /// Character range operator `-` for specified classes (e.g. `[a-z]`)\n    Range,\n\n    /// Symmetrical difference set operator `~~` for specified classes (e.g. `[a-d~~c-f]`)\n    Symmetrical,\n\n    /// Difference set operator `--` for specified classes (e.g. `[a-z--h-l]`)\n    Difference,\n\n    /// Intersection set operator `\u0026\u0026` for specified classes (e.g. `[a-d\u0026\u0026c-f]`)\n    Intersection,\n\n    /// Short unicode character class `\\uL`--or negated as `\\UL`--to be matched (not\n    /// available in specified character classes).\n    ///\n    /// # Items\n    ///\n    /// * `0` - single-character unicode General Category specified (e.g. `L` for Letter)\n    /// * `1` - whether the class is negated\n    UnicodeShort(char, bool),\n\n    /// Beginning of a long unicode character class specifier `\\p{`--or negated as `\\P{`--to\n    /// be matched (not available in specified character classes). e.g. `\\p{sc=Greek}`\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    UnicodeLong(bool),\n\n    /// Equal sign `=` in a unicode class specifier (e.g. `\\u{sc=Greek}`)\n    Equal,\n\n    /// Negation operator in a unicode class specifier (e.g. `\\u{sc!=Greek}`)\n    Bang,\n\n    // General ==================================================\n    /// Group and class names, and unicode property names and values\n    ///\n    /// # Items\n    ///\n    /// * `0` - name\n    Name(String),\n}\n\nimpl TokenKind {\n    #[inline]\n    pub fn is_literal(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Literal(_))\n    }\n\n    #[inline]\n    pub fn is_digit(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Digit(_))\n    }\n\n    #[inline]\n    pub fn is_whitespace(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Whitespace(_))\n    }\n\n    #[inline]\n    pub fn is_word_char(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::WordChar(_))\n    }\n\n    #[inline]\n    pub fn is_dot(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Dot)\n    }\n\n    #[inline]\n    pub fn is_alternate(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Alternate)\n    }\n\n    #[inline]\n    pub fn is_start_of_line(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::StartOfLine)\n    }\n\n    #[inline]\n    pub fn is_end_of_line(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::EndOfLine)\n    }\n\n    #[inline]\n    pub fn is_start_of_text(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::StartOfText)\n    }\n\n    #[inline]\n    pub fn is_end_of_text(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::EndOfText)\n    }\n\n    #[inline]\n    pub fn is_word_boundary(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::WordBoundary)\n    }\n\n    #[inline]\n    pub fn is_non_word_boundary(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::NonWordBoundary)\n    }\n\n    #[inline]\n    pub fn is_boundary(\u0026self) -\u003e bool {\n        match self {\n            TokenKind::StartOfLine\n            | TokenKind::EndOfLine\n            | TokenKind::StartOfText\n            | TokenKind::EndOfText\n            | TokenKind::WordBoundary\n            | TokenKind::NonWordBoundary =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    #[inline]\n    pub fn is_open_brace(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenBrace)\n    }\n\n    #[inline]\n    pub fn is_close_brace(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseBrace)\n    }\n\n    #[inline]\n    pub fn is_number(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Number(_))\n    }\n\n    #[inline]\n    pub fn is_comma(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Comma)\n    }\n\n    #[inline]\n    pub fn is_question(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Question)\n    }\n\n    #[inline]\n    pub fn is_star(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Star)\n    }\n\n    #[inline]\n    pub fn is_plus(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Plus)\n    }\n\n    #[inline]\n    pub fn is_open_group(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenGroup)\n    }\n\n    #[inline]\n    pub fn is_close_group(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseGroup)\n    }\n\n    #[inline]\n    pub fn is_open_group_options(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenGroupOptions)\n    }\n\n    #[inline]\n    pub fn is_close_group_options(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseGroupOptions)\n    }\n\n    #[inline]\n    pub fn is_open_group_name(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenGroupName)\n    }\n\n    #[inline]\n    pub fn is_close_group_name(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseGroupName)\n    }\n\n    #[inline]\n    pub fn is_flag(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Flag(_))\n    }\n\n    #[inline]\n    pub fn is_flag_delimiter(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::FlagDelimiter)\n    }\n\n    #[inline]\n    pub fn is_flag_or_delimiter(\u0026self) -\u003e bool {\n        self.is_flag() || self.is_flag_delimiter()\n    }\n\n    #[inline]\n    pub fn is_open_bracket(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenBracket)\n    }\n\n    #[inline]\n    pub fn is_close_bracket(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseBracket)\n    }\n\n    #[inline]\n    pub fn is_colon(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Colon)\n    }\n\n    #[inline]\n    pub fn is_negated(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Negated)\n    }\n\n    #[inline]\n    pub fn is_range(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Range)\n    }\n\n    #[inline]\n    pub fn is_symmetrical(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Symmetrical)\n    }\n\n    #[inline]\n    pub fn is_difference(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Difference)\n    }\n\n    #[inline]\n    pub fn is_intersection(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Intersection)\n    }\n\n    #[inline]\n    pub fn is_set_operator(\u0026self) -\u003e bool {\n        match self {\n            TokenKind::Symmetrical | TokenKind::Difference | TokenKind::Intersection =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    #[inline]\n    pub fn is_unicode_short(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::UnicodeShort(_, _))\n    }\n\n    #[inline]\n    pub fn is_unicode_long(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::UnicodeLong(_))\n    }\n\n    #[inline]\n    pub fn is_bang(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Bang)\n    }\n\n    #[inline]\n    pub fn is_equal(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Equal)\n    }\n\n    #[inline]\n    pub fn is_name(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Name(_))\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct TokenStack {\n    pub token: Token,\n    pub stack: StateStack,\n}\n\nmacro_rules! tok {\n    ( $kind:pat = $tok:ident) =\u003e {\n        let $kind = $tok.kind else {\n            panic!(\n                \"token `{}` does not match pattern `{}`\",\n                stringify!($tok.kind),\n                stringify!($kind)\n            );\n        };\n    };\n}\n\npub(crate) use tok;\n","traces":[{"line":16,"address":[560368],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":17,"address":[560419,560387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[560415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[560480,560693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[560533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[560720],"length":1,"stats":{"Line":3},"fn_name":"try_from"},{"line":61,"address":[560740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[560842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[560870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[560895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[560920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[560945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[560970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[560995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[560785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[561024],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[561032],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[561112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[561105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[561136],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[561141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":85,"coverable":116},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","tokenizer.rs"],"content":"use std::convert::TryInto;\n\nuse aglet_text::Cursor;\n\nuse crate::tokenize::error::*;\nuse crate::tokenize::state::*;\nuse crate::tokenize::token::*;\n#[cfg(test)]\nuse crate::tokenize::{assert_next_err, assert_next_none, assert_next_tok};\n\n/// Tokenizer for a regular expression\npub struct Tokenizer\u003c'a\u003e {\n    cursor:          Cursor\u003c'a\u003e,\n    state:           StateStack,\n    last_token_kind: Option\u003cTokenKind\u003e,\n    is_eof:          bool,\n}\n\nimpl\u003c'a\u003e Tokenizer\u003c'a\u003e {\n    /// Create a new regular expression tokenizer\n    ///\n    /// # Arguments\n    ///\n    /// * `input` - A string-like object that contains the entire regular\n    ///     expression to be tokenized\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use aglet_regex::tokenize;\n    /// let _ = tokenize::Tokenizer::new(\"[a-z-]{1, 4}\");\n    /// let _ = tokenize::Tokenizer::new(\"^hello, world$\");\n    /// ```\n    pub fn new\u003cC: Into\u003cCursor\u003c'a\u003e\u003e\u003e(cursor: C) -\u003e Self {\n        Tokenizer {\n            cursor:          cursor.into(),\n            state:           StateStack::new(),\n            last_token_kind: None,\n            is_eof:          false,\n        }\n    }\n\n    /// Get the next token from the input. A token includes both the kind of the\n    /// token along with the kind's associated data (e.g. a literal includes the\n    /// literal value) and the span over which the token was found in the input.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use aglet_regex::tokenize::*;\n    /// use aglet_regex::tokenize::token::Flag;\n    /// let mut tr = Tokenizer::new(\"(?x-i)\");\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::OpenGroup, 0, 1)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::OpenGroupOptions, 1, 2)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::Flag(Flag::IgnoreWhitespace), 2, 3)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::FlagDelimiter, 3, 4)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::Flag(Flag::CaseInsensitive), 4, 5)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::CloseGroup, 5, 6)),\n    /// );\n    /// ```\n    pub fn next_token(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // short-circuit the token matching code if the tokenizer has already been marked EOF\n        if self.is_eof {\n            return self.err(ErrorKind::EndOfFile);\n        }\n\n        let res = self.next_token_inner();\n\n        if let Err(err) = \u0026res {\n            if err.is_fatal() || err.is_any_eof() {\n                self.is_eof = true;\n            }\n        }\n\n        res\n    }\n\n    /// Get the next token from the input, along with the current state stack.\n    ///\n    /// When a state is added to the stack during an iteration, then the stack including the new\n    /// state will be returned. When a state is popped, then the stack will be returned as it was\n    /// before the iteration (i.e. will include the popped state). This is to group the terminating\n    /// token with the state it ends in the output.\n    ///\n    /// # Example\n    ///\n    /// For the regular expression:\n    ///\n    /// `[ab].+`\n    ///\n    /// The stacks returned with each token will be:\n    ///\n    /// * `[` [Main, Class]\n    /// * 'a' [Main, Class]\n    /// * 'b' [Main, Class]\n    /// * `]` [Main, Class]\n    /// * `.` [Main]\n    /// * `+` [Main]\n    ///\n    /// If this function always returned the state stack as it was _after_ each iteration, then\n    /// the result would be:\n    ///\n    /// * `[` [Main, Class]\n    /// * 'a' [Main, Class]\n    /// * 'b' [Main, Class]\n    /// * `]` [Main]\n    /// * `.` [Main]\n    /// * `+` [Main]\n    ///\n    /// disconnecting the closing bracket from the class state. This only really impacts the\n    /// colorization of pretty-printed token lists when, for example, a brace can be colorized as\n    /// part of a repetition or a unicode class. The open brace is always part of one state or the\n    /// other, but the close brace would never have that associated information.\n    pub fn next_token_stack(\u0026mut self) -\u003e StackResult\u003cTokenStack\u003e {\n        let (token, stack) = {\n            let stack_before = self.state.clone();\n            let token = self\n                .next_token()\n                .map_err(|e| StackError::from_error(e, stack_before.clone()))?;\n\n            if stack_before.stack.len() \u003e self.state.stack.len() {\n                (token, stack_before)\n            } else {\n                (token, self.state.clone())\n            }\n        };\n\n        Ok(TokenStack { token, stack })\n    }\n\n    /// Create an iterator over\n    pub fn into_token_stack_iter(self) -\u003e TokenStackIterator\u003c'a\u003e {\n        TokenStackIterator { tokenizer: self }\n    }\n\n    /// Get the next token from the input\n    fn next_token_inner(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let token = match self.state.get() {\n            Ok(State::Main) =\u003e self.next_token_main(),\n            Ok(State::GroupOptions) =\u003e self.next_token_group_options(),\n            Ok(State::Class) =\u003e self.next_token_class(),\n            Ok(State::ClassName) =\u003e self.next_token_class_name(),\n            Ok(State::Range) =\u003e self.next_token_range(),\n            Ok(State::UnicodeProperties) =\u003e self.next_token_unicode_properties(),\n            Err(err) =\u003e self.fatal_err(err.into()),\n        };\n\n        if let Ok(tok) = token.as_ref() {\n            self.last_token_kind = Some(tok.kind.clone());\n        }\n\n        token\n    }\n\n    /// Get a token in the `Main` state\n    ///\n    /// This state is used to tokenize the majority of a regular expression -\n    /// most literals, boundaries, repeaters, etc. are parsed here, being the\n    /// default parser for the input. Only groups, certain escapes, certain\n    /// repetitions, and character classes are parsed in a different state;\n    /// even then, groups fall back on the main state once their headers have\n    /// been parsed.\n    fn next_token_main(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // If the ignore_whitespace flag is set, try to skip any whitespace\n        // before reading the next token in the main state\n        let flags = self.flags()?;\n        if flags.ignore_space {\n            self.skip_whitespace();\n        }\n\n        match self.cursor.next() {\n            Some('^') =\u003e self.tok_kind(TokenKind::StartOfLine),\n            Some('$') =\u003e self.tok_kind(TokenKind::EndOfLine),\n            Some('.') =\u003e self.tok_kind(TokenKind::Dot),\n            Some('?') =\u003e self.tok_kind(TokenKind::Question),\n            Some('*') =\u003e self.tok_kind(TokenKind::Star),\n            Some('+') =\u003e self.tok_kind(TokenKind::Plus),\n            Some('|') =\u003e self.tok_kind(TokenKind::Alternate),\n\n            // The `(` token enters a group state - if it's just a capturing group\n            // (e.g. `(xyz)`) then just another `Main` state is used to parse the sub-expression.\n            // The group might have a header that starts with `?` (e.g. `(?P\u003cname\u003exyz)`), in which\n            // case enter the `Group` state to tokenize it before optionally returning to the\n            // `Main` state.\n            Some('(') if matches!(self.cursor.first(), Some('?')) =\u003e {\n                self.push_state(State::GroupOptions);\n                self.tok_kind(TokenKind::OpenGroup)\n            },\n            Some('(') =\u003e {\n                self.push_state(State::Main);\n                self.tok_kind(TokenKind::OpenGroup)\n            },\n\n            // The group state swaps to the main state as soon as its header\n            // has been parsed; so this state is responsible for matching the\n            // `)` token and popping the state\n            Some(')') =\u003e match self.state.pop() {\n                Ok(_) =\u003e self.tok_kind(TokenKind::CloseGroup),\n                Err(StateError::PoppedFinalState) =\u003e self.tok_kind(TokenKind::CloseGroup),\n                Err(err) =\u003e self.fatal_err(err.into()),\n            },\n\n            // The `[` token pushes the character class state, e.g. `[a-z]`\n            Some('[') =\u003e {\n                self.push_state(State::Class);\n                self.tok_kind(TokenKind::OpenBracket)\n            },\n\n            // The class state is responsible for matching these and popping the class state.\n            // If one is found here, it'll be a parse error, but the token can still be matched\n            Some(']') =\u003e self.tok_kind(TokenKind::CloseBracket),\n\n            // The `{` token pushes the range state, e.g. `{1,3}`\n            Some('{') =\u003e {\n                self.push_state(State::Range);\n                self.tok_kind(TokenKind::OpenBrace)\n            },\n\n            // The range state is responsible for matching these and popping the state.\n            // If one is found here, it'll be a parse error, but the token can still be matched\n            Some('}') =\u003e self.tok_kind(TokenKind::CloseBrace),\n\n            // escape sequences can be a single character after a backslash,\n            // or a more complicated unicode escape e.g. `\\x{01A1}`\n            Some('\\\\') =\u003e self.parse_escape_sequence_main(),\n\n            // All other input characters are literals\n            Some(c) =\u003e self.tok_kind(TokenKind::Literal(c)),\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `Group` state\n    ///\n    /// This state matches the header of a group, represented by a single\n    /// token. This could be a non-capturing marker, some flags, a group name,\n    /// etc.\n    ///\n    /// Before this function returns, the `Group` state will be swapped with\n    /// another `Main` state, in case there is an expression inside the group\n    /// that needs to be matched\n    fn next_token_group_options(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        if matches!(self.last_token_kind, Some(TokenKind::OpenGroupName)) {\n            let name = self.parse_id();\n            if !name.is_empty() {\n                return self.tok_kind(TokenKind::Name(name));\n            }\n        }\n\n        match self.cursor.next() {\n            Some('?') =\u003e self.tok_kind(TokenKind::OpenGroupOptions),\n            Some(':') =\u003e {\n                self.swap_state(State::Main)?;\n                self.tok_kind(TokenKind::CloseGroupOptions)\n            },\n            Some('P') if matches!(self.cursor.first(), Some('\u003c')) =\u003e {\n                self.cursor.skip(1);\n                self.tok_kind(TokenKind::OpenGroupName)\n            },\n            Some('\u003c') =\u003e self.tok_kind(TokenKind::OpenGroupName),\n            Some('\u003e') =\u003e {\n                self.swap_state(State::Main)?;\n                self.tok_kind(TokenKind::CloseGroupName)\n            },\n            Some('-') =\u003e {\n                {\n                    let flags = self.flags_mut()?;\n                    flags.unset_flags = true;\n                }\n\n                self.tok_kind(TokenKind::FlagDelimiter)\n            },\n            Some(')') =\u003e {\n                let is_flag_group = matches!(\n                    self.last_token_kind,\n                    Some(TokenKind::Flag(_) | TokenKind::FlagDelimiter)\n                );\n\n                if is_flag_group {\n                    let ignore_space = self.flags()?.ignore_space;\n                    self.pop_state()?;\n\n                    {\n                        let flags = self.flags_mut()?;\n                        flags.ignore_space = ignore_space;\n                    }\n                } else {\n                    self.pop_state()?;\n                }\n\n                self.tok_kind(TokenKind::CloseGroup)\n            },\n            Some(c) if Flag::is_flag_char(c) =\u003e {\n                let flag: Flag = c.try_into().unwrap();\n\n                {\n                    let flags = self.flags_mut()?;\n                    if flag.is_ignore_whitespace() {\n                        flags.ignore_space = !flags.unset_flags;\n                    }\n                }\n\n                self.tok_kind(TokenKind::Flag(flag))\n            },\n            Some(c) if c.is_alphabetic() =\u003e self.err(ErrorKind::UnrecognizedFlag(c)),\n            Some(c) =\u003e self.err(ErrorKind::UnexpectedChar(c)),\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `Class` state\n    ///\n    /// This state matches elaborated character classes between `[` and `]`\n    /// brackets, which can include ranges, differences, unions, etc.\n    fn next_token_class(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // If the ignore_whitespace flag is set, skip any whitespace and\n        // comments before matching the next class token\n        let flags = self.flags()?;\n        if flags.ignore_space {\n            self.skip_whitespace();\n        }\n\n        match self.cursor.next() {\n            // `-` at the end of the class (e.g. `-]`) is just a literal\n            Some('-') if matches!(self.cursor.first(), Some(']')) =\u003e {\n                self.tok_kind(TokenKind::Literal('-'))\n            },\n            // `--` is the difference token\n            Some('-') if matches!(self.cursor.first(), Some('-')) =\u003e {\n                self.cursor.skip(1);\n                self.tok_kind(TokenKind::Difference)\n            },\n            // `-` following a literal is a range token (e.g. `a-`)\n            Some('-') if matches!(self.last_token_kind, Some(TokenKind::Literal(_))) =\u003e {\n                self.tok_kind(TokenKind::Range)\n            },\n            // In any other case, `-` is just a literal\n            Some('-') =\u003e self.tok_kind(TokenKind::Literal('-')),\n            // `[:` begins a named class, e.g. `[:alpha:]`\n            Some('[') if matches!(self.cursor.first(), Some(':')) =\u003e {\n                self.push_state(State::ClassName);\n                self.tok_kind(TokenKind::OpenBracket)\n            },\n            // If not part of `[:`, `[` just begins a new sub-class\n            Some('[') =\u003e {\n                self.push_state(State::Class);\n                self.tok_kind(TokenKind::OpenBracket)\n            },\n            // `]` ends a class name or a character class and pops its own state\n            Some(']') =\u003e {\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBracket)\n            },\n            // `^` at the beginning of a character class is a negation\n            Some('^') if matches!(self.last_token_kind, Some(TokenKind::OpenBracket)) =\u003e {\n                self.tok_kind(TokenKind::Negated)\n            },\n            // `\u0026\u0026` is an intersection token\n            Some('\u0026') if matches!(self.cursor.first(), Some('\u0026')) =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Intersection)\n            },\n            // `~~` is a symmetrical difference token\n            Some('~') if matches!(self.cursor.first(), Some('~')) =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Symmetrical)\n            },\n            // Special characters can be escaped in classes\n            Some('\\\\') =\u003e self.parse_escape_sequence_class(),\n            // All other characters are just literals\n            Some(c) =\u003e self.tok_kind(TokenKind::Literal(c)),\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Read a named class within a character class\n    ///\n    /// A named class can be used in lieu of a more detailed character class\n    /// for clarity, e.g. `[[:alpha:]]` instead of `[a-zA-Z]`. These classes\n    /// are different from unicode classes (e.g. `\\p{alpha}`) and are only\n    /// stand-ins for relatively simple character classes:\n    ///\n    /// * `[[:alnum:]]` - `[0-9a-zA-Z]`\n    /// * `[[:alpha:]]` - `[a-zA-Z]`\n    /// * `[[:ascii:]]` - `[\\x00-\\x7F]`\n    /// * `[[:blank:]]` - `[\\t ]`\n    /// * `[[:cntrl:]]` - `[\\x00-\\x1F\\x7F]`\n    /// * `[[:digit:]]` - `[0-9]`\n    /// * `[[:graph:]]` - `[!-^]`\n    /// * `[[:lower:]]` - `[a-z]`\n    /// * `[[:print:]]` - `[ -~]`\n    /// * `[[:punct:]]` - `[!-/:-@\\[-\\`{-~]`\n    /// * `[[:space:]]` - `[\\t\\n\\v\\f\\r ]`\n    /// * `[[:upper:]]` - `[A-Z]`\n    /// * `[[:word:]]` - `[0-9a-zA-Z_]`\n    /// * `[[:xdigit:]]` - `[0-9a-fA-F]`\n    fn next_token_class_name(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        match self.cursor.first() {\n            Some(']') =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBracket)\n            },\n            Some(':') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Colon)\n            },\n            Some('^') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Negated)\n            },\n            Some(c) if unicode_ident::is_xid_start(c) =\u003e {\n                let name = self.parse_id();\n                self.tok_kind(TokenKind::Name(name))\n            },\n            // Misplaced id characters shouldn't pop the state; there's probably more\n            // valid posix class tokens to find\n            Some(c) if unicode_ident::is_xid_continue(c) =\u003e {\n                self.cursor.bump();\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            Some(c) =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `Range` state\n    ///\n    /// A range is a special kind of repetition operator specifying a minimum\n    /// and maximum number of characters to match - e.g. `.\\{3,5}`\n    fn next_token_range(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // Whitespace is always skipped in a range, because it cannot be\n        // significant to what is matched. Anything between braces, numbers,\n        // and commas is insignificant, but within numbers, whitespace is\n        // not tolerated\n        self.skip_whitespace();\n\n        match self.cursor.first() {\n            // The end of the range pops its own state\n            Some('}') =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBrace)\n            },\n            // A comma separates the start and end for the range\n            Some(',') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Comma)\n            },\n            Some(c) if c.is_numeric() =\u003e self.parse_number(),\n            Some(c) =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `UnicodeProperties` state\n    ///\n    /// UnicodeProperties is a special character class that matches characters\n    /// based on their unicode class, language, etc.\n    ///\n    /// Properties can be specified with one character shorthand, e.g.:\n    ///\n    /// * \\pN - matches unicode numbers\n    /// * \\PN - matches anything except unicode numbers\n    ///\n    /// However, this state is only used once a brace is introduced to the\n    /// pattern. Braces can be used for more control, e.g.:\n    ///\n    /// * \\p{Lu} - matches an uppercase letter\n    /// * \\p{sc=Greek} - matches a letter in the Greek character set\n    fn next_token_unicode_properties(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // Whitespace is always skipped here, because whitespace cannot\n        // be relevant to what is matched\n        self.skip_whitespace();\n\n        match self.cursor.first() {\n            Some('{') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::OpenBrace)\n            },\n            Some('=') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Equal)\n            },\n            Some('!') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Bang)\n            },\n            // `}` ends `UnicodeProperties` state and pops its own state\n            Some('}') =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBrace)\n            },\n            // Alphanumeric characters get added to `item` to be returned\n            // as either property name or value tokens\n            Some(c) if unicode_ident::is_xid_start(c) =\u003e {\n                let name = self.parse_id();\n                self.tok_kind(TokenKind::Name(name))\n            },\n            // Anything that looks like it was supposed to be part of an ID is an unexpected char,\n            // but the state won't be popped because there could be more class tokens to find\n            Some(c) if unicode_ident::is_xid_continue(c) =\u003e {\n                self.cursor.bump();\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            // Anything weirder that doesn't belong in a class specifier should create an error\n            // _and_ pop the state so that a different mode can look for valid tokens\n            Some(c) =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    #[inline]\n    fn push_state(\u0026mut self, state: State) {\n        self.state.push(state)\n    }\n\n    #[inline]\n    fn swap_state(\u0026mut self, state: State) -\u003e Result\u003cState\u003e {\n        self.state\n            .swap(state)\n            .map_err(|err| self.raw_err(err.into()))\n    }\n\n    #[inline]\n    fn pop_state(\u0026mut self) -\u003e Result\u003cState\u003e {\n        self.state.pop().map_err(|err| self.raw_err(err.into()))\n    }\n\n    #[inline]\n    fn pop_all_states(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.state.pop_all().map_err(|err| self.raw_err(err.into()))\n    }\n\n    /// Get an immutable copy of the state flags\n    #[inline]\n    fn flags(\u0026mut self) -\u003e Result\u003c\u0026Flags\u003e {\n        let span = self.cursor.span();\n        let res = self.state.flags();\n\n        match res {\n            Ok(flags) =\u003e Ok(flags),\n            Err(err) =\u003e Err(Error::new(span, err.into())),\n        }\n    }\n\n    /// Get a mutable copy of the state flags\n    #[inline]\n    fn flags_mut(\u0026mut self) -\u003e Result\u003c\u0026mut Flags\u003e {\n        let span = self.cursor.span();\n        let res = self.state.flags_mut();\n\n        match res {\n            Ok(flags) =\u003e Ok(flags),\n            Err(err) =\u003e Err(Error::new(span, err.into())),\n        }\n    }\n\n    /// Skip whitespace and comments in the input\n    ///\n    /// Any whitespace, or anything following a `#` character up to a newline\n    /// will be skipped. This is mostly used when the `ignore_whitespace` flag\n    /// is set for the main and class states; but it's also used in states where\n    /// whitespace is not significant in any case (e.g. in ranges).\n    ///\n    /// # Examples\n    ///\n    /// The input:\n    ///\n    /// `a b c\\nd e f #this is a comment\\ng h i`\n    ///\n    /// will be replaced with\n    ///\n    /// `abcdefghi`\n    fn skip_whitespace(\u0026mut self) {\n        // Keep track of whether a comment is being skipped; this will cause\n        // every character except a newline to be skipped, instead of only\n        // whitespace and `#` characters.\n        let mut skipping_comment = false;\n        loop {\n            match self.cursor.first() {\n                // Terminate comment skipping once a newline is seen\n                Some('\\n') if skipping_comment =\u003e skipping_comment = false,\n                // Skip all whitespace, or any character if in a comment\n                Some(c) if c.is_whitespace() || skipping_comment =\u003e (),\n                // Enter a comment when `#` is encountered\n                Some('#') =\u003e skipping_comment = true,\n                // In any other case, all whitespace has been skipped\n                _ =\u003e break,\n            }\n\n            self.cursor.skip(1);\n        }\n    }\n\n    /// Match an escape sequence in the `Main` state\n    ///\n    /// This matches some anchors, literals, boundaries, and character classes\n    /// which are represented as simple one-letter escape sequences. Unicode\n    /// classes are also parsed here, as well as hexadecimal numerical escapes.\n    fn parse_escape_sequence_main(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        match self.cursor.next() {\n            Some('A') =\u003e self.tok_kind(TokenKind::StartOfText),\n            Some('z') =\u003e self.tok_kind(TokenKind::EndOfText),\n            Some('b') =\u003e self.tok_kind(TokenKind::WordBoundary),\n            Some('B') =\u003e self.tok_kind(TokenKind::NonWordBoundary),\n            Some('a') =\u003e self.tok_kind(TokenKind::Literal('\\x07')),\n            Some('f') =\u003e self.tok_kind(TokenKind::Literal('\\x0C')),\n            Some('t') =\u003e self.tok_kind(TokenKind::Literal('\\t')),\n            Some('n') =\u003e self.tok_kind(TokenKind::Literal('\\n')),\n            Some('r') =\u003e self.tok_kind(TokenKind::Literal('\\r')),\n            Some('v') =\u003e self.tok_kind(TokenKind::Literal('\\x0B')),\n            Some('d') =\u003e self.tok_kind(TokenKind::Digit(false)),\n            Some('D') =\u003e self.tok_kind(TokenKind::Digit(true)),\n            Some('s') =\u003e self.tok_kind(TokenKind::Whitespace(false)),\n            Some('S') =\u003e self.tok_kind(TokenKind::Whitespace(true)),\n            Some('w') =\u003e self.tok_kind(TokenKind::WordChar(false)),\n            Some('W') =\u003e self.tok_kind(TokenKind::WordChar(true)),\n            // Parse a unicode class, whether a simple one-character escape\n            // sequence or a braced expression\n            Some('p') =\u003e self.parse_unicode(false),\n            // Parse a negated unicode class, whether a simple one-character\n            // escape sequence or a braced expression\n            Some('P') =\u003e self.parse_unicode(true),\n            // Parse a hex escape, which is a numerical representation of a\n            // single literal character (e.g. \\x7F)\n            Some(c) if Tokenizer::is_hex_escape(\u0026c) =\u003e self.parse_hex(c),\n            // Certain special characters can be escaped to a literal (e.g., \\})\n            Some(c) if Tokenizer::escapes_to_literal_main(\u0026c) =\u003e {\n                self.tok_kind(TokenKind::Literal(c))\n            },\n            // Everything else is an invalid escape sequence\n            Some(c) =\u003e self.err(ErrorKind::UnrecognizedEscape(c)),\n            // In lieu of an end of file error, we know that an errant \\ exists\n            // in the input, so use a more specific error\n            None =\u003e self.err(ErrorKind::UnexpectedChar('\\\\')),\n        }\n    }\n\n    /// Parse a hex escape sequence to create a literal\n    ///\n    /// Hex sequences without braces can match 2, 4, or 8 hexadecimal digits\n    /// as a literal:\n    ///\n    /// * \\x7F\n    /// * \\u007F\n    /// * \\U0000007F\n    ///\n    /// Any of these sequences can be surrounded by braces to match any number\n    /// of digits. Any number that doesn't represent a valid codepoint will be\n    /// rejected.\n    ///\n    /// * \\x{007F}\n    /// * \\u{0000007F}\n    /// * \\U{7F}\n    fn parse_hex(\u0026mut self, ident: char) -\u003e Result\u003cToken\u003e {\n        let mut number = String::new();\n        let bounded = self.cursor.matches('{');\n\n        let digits = match (bounded, ident) {\n            (true, _) =\u003e 8,\n            (_, 'x') =\u003e 2,\n            (_, 'u') =\u003e 4,\n            (_, 'U') =\u003e 8,\n            _ =\u003e panic!(\"accepted unknown hex escape specifier `{}`\", ident),\n        };\n\n        for _ in 0..digits {\n            match self.cursor.next() {\n                Some(c) if c.is_ascii_hexdigit() =\u003e number.push(c),\n                Some('}') if bounded =\u003e break,\n                Some(c) =\u003e return self.err(ErrorKind::InvalidHexDigit(c)),\n                None =\u003e {\n                    return self.err(ErrorKind::UnexpectedEOF(String::from(\n                        \"expected end of hex literal\",\n                    )))\n                },\n            };\n        }\n\n        let value = u32::from_str_radix(\u0026number, 16)\n            .unwrap_or_else(|_| panic!(\"accepted invalid hex string: {}\", number));\n        let c = char::from_u32(value)\n            .ok_or_else(|| self.raw_err(ErrorKind::InvalidCharCode(number).into()))?;\n\n        self.tok_kind(TokenKind::Literal(c))\n    }\n\n    /// Parse a unicode character class, either as a simple one-character\n    /// escape sequence or as a braced expression\n    ///\n    /// As a one-character escape, the class represents a single-character\n    /// general category (e.g., N for Numeric). The braced expression can\n    /// specify the same general category, as well as other properties:\n    ///\n    /// * `\\p{Alphabetic}` or `\\p{alpha}`: alphabetic class\n    /// * `\\p{Letter}` or `\\pL`: letter class\n    /// * `\\p{script!=Greek}` or `\\p{sc!=Greek}` or `\\P{sc=Greek}`:\n    ///     negated match of the Greek script\n    fn parse_unicode(\u0026mut self, negated: bool) -\u003e Result\u003cToken\u003e {\n        // Check for a braced expression and enter the `UnicodeProperties` state\n        if let Some('{') = self.cursor.first() {\n            self.push_state(State::UnicodeProperties);\n            return self.tok_kind(TokenKind::UnicodeLong(negated));\n        }\n\n        // Otherwise, it's a single-character class\n        match self.cursor.next() {\n            Some(c) if c.is_ascii_alphabetic() =\u003e {\n                self.tok_kind(TokenKind::UnicodeShort(c, negated))\n            },\n            Some(c) =\u003e self.err(ErrorKind::UnexpectedChar(c)),\n            None =\u003e self.err(ErrorKind::UnexpectedEOF(String::from(\n                \"expected single-character unicode general category\",\n            ))),\n        }\n    }\n\n    /// Read a valid identifier using the XID_START and XID_CONTINUE classes from the unicode\n    /// identifiers and syntax annex #31.\n    ///\n    /// Characters will be read from the stream so long as they belong to the XID_CONTINUE category,\n    /// except for the first character, which must belong to the XID_START category (a subgroup\n    /// of XID_CONTINUE). This allows, for example, numbers to appear in the identifier except in\n    /// the starting position.\n    fn parse_id(\u0026mut self) -\u003e String {\n        let mut id = String::new();\n        let mut first = true;\n        loop {\n            match self.cursor.first() {\n                Some(c) if first \u0026\u0026 unicode_ident::is_xid_start(c) =\u003e id.push(c),\n                Some(c) if !first \u0026\u0026 unicode_ident::is_xid_continue(c) =\u003e id.push(c),\n                _ =\u003e break,\n            }\n\n            self.cursor.bump();\n            first = false;\n        }\n\n        id\n    }\n\n    /// Parse an escape sequence in the `Class` state\n    ///\n    /// Escape sequences in the class state differ from the main state in that\n    /// the anchors and boundaries don't count, and the literal escapes are\n    /// different.\n    ///\n    /// The class escapes still match (e.g. \\s, \\w), and a subset of the same\n    /// literals (e.g. \\], \\^) as well as some escapes not valid in the `Main`\n    /// state (e.g. \\\u0026, \\-) can be escaped here.\n    fn parse_escape_sequence_class(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        match self.cursor.next() {\n            Some('s') =\u003e self.tok_kind(TokenKind::Whitespace(false)),\n            Some('S') =\u003e self.tok_kind(TokenKind::Whitespace(true)),\n            Some('d') =\u003e self.tok_kind(TokenKind::Digit(false)),\n            Some('D') =\u003e self.tok_kind(TokenKind::Digit(true)),\n            Some('w') =\u003e self.tok_kind(TokenKind::WordChar(false)),\n            Some('W') =\u003e self.tok_kind(TokenKind::WordChar(true)),\n            // Parse a hex escape, which is a numerical representation of a\n            // single literal character (e.g. \\x7F)\n            Some(c) if Tokenizer::is_hex_escape(\u0026c) =\u003e self.parse_hex(c),\n            Some(c) if Tokenizer::escapes_to_literal_class(\u0026c) =\u003e {\n                self.tok_kind(TokenKind::Literal(c))\n            },\n            Some(c) =\u003e self.err(ErrorKind::UnrecognizedEscape(c)),\n            None =\u003e self.err(ErrorKind::UnexpectedChar('\\\\')),\n        }\n    }\n\n    /// Parse a number in the `Range` state\n    ///\n    /// This is specifically for tokenizing numbers withing a character range,\n    /// e.g. `.{3,5}`\n    fn parse_number(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let mut number = String::new();\n        loop {\n            match self.cursor.first() {\n                // Any numeric character is added to the current number\n                Some(c) if c.is_numeric() =\u003e {\n                    self.cursor.bump();\n                    number.push(c);\n                },\n                // Otherwise just break\n                Some(_) =\u003e break,\n                None =\u003e {\n                    self.pop_all_states()?;\n                    break;\n                },\n            }\n        }\n\n        // This function is only for parsing the number, so a number should\n        // always be the output. Parse the input as an unsigned integer\n        let value = number\n            .parse::\u003cusize\u003e()\n            .unwrap_or_else(|_| panic!(\"accepted invalid number: {}\", number));\n\n        self.tok_kind(TokenKind::Number(value))\n    }\n\n    /// Check whether a character can be escaped in the `Main` state\n    fn escapes_to_literal_main(c: \u0026char) -\u003e bool {\n        matches!(\n            c,\n            '^' | '$' | '.' | '?' | '*' | '+' | '|' | '(' | ')' | '[' | ']' | '{' | '}' | '\\\\'\n        )\n    }\n\n    /// Check whether a character can be escaped in the `Class` state\n    fn escapes_to_literal_class(c: \u0026char) -\u003e bool {\n        matches!(c, '^' | '\u0026' | '~' | '-' | '[' | ']' | ':' | '\\\\')\n    }\n\n    /// Check whether a character is the beginning of a hex escape sequence\n    /// (e.g. in `\\x7F`, `\\u007F`, `\\x{12AB}`, etc.)\n    fn is_hex_escape(c: \u0026char) -\u003e bool {\n        matches!(c, 'x' | 'u' | 'U')\n    }\n\n    fn tok_kind(\u0026mut self, kind: TokenKind) -\u003e Result\u003cToken\u003e {\n        Ok(self.cursor.map_span(|span| Token { span, kind }))\n    }\n\n    #[inline]\n    fn err\u003cT\u003e(\u0026mut self, kind: ErrorKind) -\u003e Result\u003cT\u003e {\n        Err(self.raw_err(kind.into()))\n    }\n\n    fn fatal_err\u003cT\u003e(\u0026mut self, kind: FatalErrorKind) -\u003e Result\u003cT\u003e {\n        Err(self.raw_err(kind.into()))\n    }\n\n    #[inline]\n    fn raw_err(\u0026mut self, cause: ErrorCause) -\u003e Error {\n        self.cursor.map_span(|span| Error { span, cause })\n    }\n}\n\nimpl\u003c'a\u003e Iterator for Tokenizer\u003c'a\u003e {\n    type Item = Result\u003cToken\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let res = self.next_token();\n\n        if let Err(err) = \u0026res {\n            if err.is_eof() {\n                return None;\n            }\n        }\n\n        Some(res)\n    }\n}\n\npub struct TokenStackIterator\u003c'a\u003e {\n    tokenizer: Tokenizer\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e Iterator for TokenStackIterator\u003c'a\u003e {\n    type Item = StackResult\u003cTokenStack\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let res = self.tokenizer.next_token_stack();\n\n        if let Err(err) = \u0026res {\n            if err.is_eof() {\n                return None;\n            }\n        }\n\n        Some(res)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tokenize::assert_tokens;\n\n    #[test]\n    fn simple_main() {\n        // Check the basic tokens in the main state\n        let tr = Tokenizer::new(r\"a^$.?*+|()]}\");\n        assert_tokens(\n            tr,\n            vec![\n                TokenKind::Literal('a'),\n                TokenKind::StartOfLine,\n                TokenKind::EndOfLine,\n                TokenKind::Dot,\n                TokenKind::Question,\n                TokenKind::Star,\n                TokenKind::Plus,\n                TokenKind::Alternate,\n                TokenKind::OpenGroup,\n                TokenKind::CloseGroup,\n                TokenKind::CloseBracket,\n                TokenKind::CloseBrace,\n            ],\n        );\n    }\n\n    #[test]\n    fn extra_group_end() {\n        let tr = Tokenizer::new(r\"a))\");\n        let expected = vec![\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn expected_group_end() {\n        let mut tr = Tokenizer::new(r\"(\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n    }\n\n    #[test]\n    fn simple_escapes() {\n        let tr = Tokenizer::new(r\"\\A\\z\\b\\B\\a\\f\\t\\n\\r\\v\\d\\D\\s\\S\\w\\W\");\n        let expected = vec![\n            TokenKind::StartOfText,\n            TokenKind::EndOfText,\n            TokenKind::WordBoundary,\n            TokenKind::NonWordBoundary,\n            TokenKind::Literal('\\x07'),\n            TokenKind::Literal('\\x0C'),\n            TokenKind::Literal('\\t'),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('\\r'),\n            TokenKind::Literal('\\x0B'),\n            TokenKind::Digit(false),\n            TokenKind::Digit(true),\n            TokenKind::Whitespace(false),\n            TokenKind::Whitespace(true),\n            TokenKind::WordChar(false),\n            TokenKind::WordChar(true),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn literal_escapes() {\n        // Check all the literal escapes in the main state\n        let tr = Tokenizer::new(r\"\\^\\$\\.\\?\\*\\+\\|\\(\\)\\[\\]\\{\\}\\\\\");\n        let expected = vec![\n            TokenKind::Literal('^'),\n            TokenKind::Literal('$'),\n            TokenKind::Literal('.'),\n            TokenKind::Literal('?'),\n            TokenKind::Literal('*'),\n            TokenKind::Literal('+'),\n            TokenKind::Literal('|'),\n            TokenKind::Literal('('),\n            TokenKind::Literal(')'),\n            TokenKind::Literal('['),\n            TokenKind::Literal(']'),\n            TokenKind::Literal('{'),\n            TokenKind::Literal('}'),\n            TokenKind::Literal('\\\\'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn main_escape_errors() {\n        let mut tr = Tokenizer::new(r\"\\:\");\n        assert_next_err!(tr, ErrorKind::UnrecognizedEscape(':'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\\");\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('\\\\'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\p\");\n        assert_next_err!(tr, ErrorKind::UnexpectedEOF(_));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\u00\");\n        assert_next_err!(tr, ErrorKind::UnexpectedEOF(_));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\u00t\");\n        assert_next_err!(tr, ErrorKind::InvalidHexDigit('t'));\n        assert_next_none!(tr);\n\n        // 0xD83F is part of a surrogate pair, and is not a valid codepoint\n        let mut tr = Tokenizer::new(r\"\\uD83F\");\n        assert_next_err!(tr, ErrorKind::InvalidCharCode(_));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn class_escape_errors() {\n        let mut tr = Tokenizer::new(r\"[\\*\");\n        assert_next_tok!(tr, TokenKind::OpenBracket);\n        assert_next_err!(tr, ErrorKind::UnrecognizedEscape('*'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"[\\\");\n        assert_next_tok!(tr, TokenKind::OpenBracket);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('\\\\'));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn basic_group() {\n        // Check basic group functionality\n        let tr = Tokenizer::new(r\"(a)b\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('b'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn non_capturing_group() {\n        // Test a non-capturing group\n        let tr = Tokenizer::new(r\"(?:ab)\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn named_group() {\n        // Test a named group\n        let tr = Tokenizer::new(r\"(?P\u003cname\u003e\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(String::from(\"name\")),\n            TokenKind::CloseGroupName,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn group_errors() {\n        // This used to create an unexpected EOF error because the group name was all one token.\n        // now, the parser should handle this error as the group is not complete\n        let mut tr = Tokenizer::new(r\"(?P\u003cname\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_tok!(tr, TokenKind::Name(_));\n        assert_next_none!(tr);\n\n        // This will now create an error, as the tokenizer will keep trying to build the name\n        // until a non-identifier character is found\n        let mut tr = Tokenizer::new(r\"(?P\u003cname%\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_tok!(tr, TokenKind::Name(_));\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('%'));\n\n        // Different requirements for the first character in a name\n        let mut tr = Tokenizer::new(r\"(?P\u003c4name\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('4'));\n        assert_next_tok!(tr, TokenKind::Name(_));\n\n        let mut tr = Tokenizer::new(r\"(?P\u003cname4\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_tok!(tr, TokenKind::Name(_));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"(?q\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_err!(tr, ErrorKind::UnrecognizedFlag('q'));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn flag_group() {\n        // Test a flags group\n        let tr = Tokenizer::new(r\"(?isUx)\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn non_capturing_flag_group() {\n        // Test a non-capturing flags group\n        let tr = Tokenizer::new(r\"(?mx:a)b\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('b'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn flag_parse() {\n        // Test the flags tokens in a variety of configurations\n        let tr = Tokenizer::new(r\"(?is-Ux)(?-iU:)(?sx-)\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::CloseGroupOptions,\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::FlagDelimiter,\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn linear_flag_settings() {\n        // Test that flag ignore_whitespace settings escape the group\n        let tr = Tokenizer::new(\" a\\nb(?x) a\\nb(?-x) a\\nb\");\n        let expected = vec![\n            TokenKind::Literal(' '),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('b'),\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal(' '),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('b'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn nested_flag_settings() {\n        // Test that ignore_whitespace can be limited to group scope\n        let tr = Tokenizer::new(\"(?x: \\nz(?-x: \\ny) \\nx) \\nw\");\n\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('z'),\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal(' '),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('y'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('x'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal(' '),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('w'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn comment_skip() {\n        // Test that ignore_whitespace will skip comments\n        let tr = Tokenizer::new(\"(?x)#skip this comment\\na$\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('a'),\n            TokenKind::EndOfLine,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn simple_class() {\n        // Test basic class tokens\n        let tr = Tokenizer::new(r\"[^-^a-z-]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Negated,\n            TokenKind::Literal('-'),\n            TokenKind::Literal('^'),\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Literal('-'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn posix_class() {\n        let tr = Tokenizer::new(r\"[:a:][[:a:]a-z]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Name(String::from(\"a\")),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn class_names_and_differences() {\n        // Test named classes and some difference operators\n        let tr = Tokenizer::new(r\"[x[aA0~~[:^lower:]--[:alnum:]]\u0026\u0026a-z]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Literal('x'),\n            TokenKind::OpenBracket,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('A'),\n            TokenKind::Literal('0'),\n            TokenKind::Symmetrical,\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Negated,\n            TokenKind::Name(String::from(\"lower\")),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::Difference,\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Name(String::from(\"alnum\")),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n            TokenKind::Intersection,\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn named_classes_and_bad_negations() {\n        // Test that named class negation works correctly\n        let tr = Tokenizer::new(r\"[[^:abc:]][:abc:]]]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Negated,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn class_escapes() {\n        // Check that class escapes work correctly\n        let tr = Tokenizer::new(r\"[\\^\\\u0026\u0026~\\~\\]\\[[\\:a:]\\s\\W\\D\\--]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Literal('^'),\n            TokenKind::Literal('\u0026'),\n            TokenKind::Literal('\u0026'),\n            TokenKind::Literal('~'),\n            TokenKind::Literal('~'),\n            TokenKind::Literal(']'),\n            TokenKind::Literal('['),\n            TokenKind::OpenBracket,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::Whitespace(false),\n            TokenKind::WordChar(true),\n            TokenKind::Digit(true),\n            TokenKind::Literal('-'),\n            TokenKind::Literal('-'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn range() {\n        // Check that basic ranges work correctly with whitespace skipping\n        let tr = Tokenizer::new(r\"{ 1 , 234 }{,}\");\n        let expected = vec![\n            TokenKind::OpenBrace,\n            TokenKind::Number(1),\n            TokenKind::Comma,\n            TokenKind::Number(234),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Comma,\n            TokenKind::CloseBrace,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn range_errors() {\n        let mut tr = Tokenizer::new(r\"{:\");\n        assert_next_tok!(tr, TokenKind::OpenBrace);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar(':'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"{1a\");\n        assert_next_tok!(tr, TokenKind::OpenBrace);\n        assert_next_tok!(tr, TokenKind::Number(1));\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('a'));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn basic_unicode() {\n        // Check unbraced hex escapes\n        let tr = Tokenizer::new(r\"\\x7F1\\u4E2AE\\U0000007F0\");\n        let expected = vec![\n            TokenKind::Literal('\\x7F'),\n            TokenKind::Literal('1'),\n            TokenKind::Literal('\\u{4E2A}'),\n            TokenKind::Literal('E'),\n            TokenKind::Literal('\\x7F'),\n            TokenKind::Literal('0'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn braced_unicode_x() {\n        // Check that braced hex escapes work with \\x\n        let tr = Tokenizer::new(r\"\\x{1}\\x{12}\\x{123}\\x{1234}\\x{12345}\");\n        let expected = vec![\n            TokenKind::Literal('\\x01'),\n            TokenKind::Literal('\\x12'),\n            TokenKind::Literal('\\u{0123}'),\n            TokenKind::Literal('\\u{1234}'),\n            TokenKind::Literal('\\u{012345}'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn braced_unicode_u() {\n        // Check that braced hex escapes work with \\u\n        let tr = Tokenizer::new(r\"\\u{1}\\u{12}\\u{123}\\u{1234}\\u{12345}\");\n        let expected = vec![\n            TokenKind::Literal('\\x01'),\n            TokenKind::Literal('\\x12'),\n            TokenKind::Literal('\\u{0123}'),\n            TokenKind::Literal('\\u{1234}'),\n            TokenKind::Literal('\\u{012345}'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn braced_unicode_upper_u() {\n        // Check that braced hex escapes work with \\U\n        let tr = Tokenizer::new(r\"\\U{1}\\U{12}\\U{123}\\U{1234}\\U{12345}\");\n        let expected = vec![\n            TokenKind::Literal('\\x01'),\n            TokenKind::Literal('\\x12'),\n            TokenKind::Literal('\\u{0123}'),\n            TokenKind::Literal('\\u{1234}'),\n            TokenKind::Literal('\\u{012345}'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn unicode_properties() {\n        // Check that unicode property classes work\n        let tr = Tokenizer::new(r\"\\pL\\PN\\p{Mn}\\P{sc!=Greek}\");\n        let expected = vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::UnicodeShort('N', true),\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(String::from(\"Mn\")),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(String::from(\"sc\")),\n            TokenKind::Bang,\n            TokenKind::Equal,\n            TokenKind::Name(String::from(\"Greek\")),\n            TokenKind::CloseBrace,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn iter_basic() {\n        let tr = Tokenizer::new(r\"a(b[c-d]{1,2})$\");\n        let kinds = tr\n            .filter_map(|tok_result| tok_result.map(|tok| tok.kind).ok())\n            .collect::\u003cVec\u003cTokenKind\u003e\u003e();\n\n        assert_eq!(\n            kinds,\n            vec![\n                TokenKind::Literal('a'),\n                TokenKind::OpenGroup,\n                TokenKind::Literal('b'),\n                TokenKind::OpenBracket,\n                TokenKind::Literal('c'),\n                TokenKind::Range,\n                TokenKind::Literal('d'),\n                TokenKind::CloseBracket,\n                TokenKind::OpenBrace,\n                TokenKind::Number(1),\n                TokenKind::Comma,\n                TokenKind::Number(2),\n                TokenKind::CloseBrace,\n                TokenKind::CloseGroup,\n                TokenKind::EndOfLine,\n            ]\n        );\n    }\n\n    #[test]\n    fn iter_error() {\n        let mut tr = Tokenizer::new(r\"{\\\");\n        assert_next_tok!(tr, TokenKind::OpenBrace);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('\\\\'));\n        assert_next_none!(tr);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":279,"coverable":359},{"path":["/","home","carson","projects","aglet","aglet-test","src","main.rs"],"content":"use color_eyre::eyre::{Report, WrapErr};\nuse thiserror::Error;\n\nfn main() -\u003e Result\u003c(), Report\u003e {\n    color_eyre::install()?;\n\n    let stuff = do_thing()?;\n    println!(\"stuff: {}\", stuff);\n    Ok(())\n}\n\nfn do_thing() -\u003e Result\u003cString, Report\u003e {\n    other_thing()?;\n    let stuff = std::fs::read_to_string(\"fake_file\").wrap_err(\"Failed to open file\")?;\n\n    Ok(stuff.to_uppercase())\n}\n\nfn other_thing() -\u003e Result\u003cString, Report\u003e {\n    Err(CustomError::AnError(String::from(\"this is an error\")).into())\n}\n\n#[derive(Error, Debug)]\npub enum CustomError {\n    #[error(\"this is an error: {0}\")]\n    AnError(String),\n}\n","traces":[{"line":4,"address":[354414,353952],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":5,"address":[354060,353959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[354219,354095,354004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[354305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[354381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[355005,354448],"length":1,"stats":{"Line":0},"fn_name":"do_thing"},{"line":13,"address":[354713,354465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[354743,354836,354591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[354919,354815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[355040],"length":1,"stats":{"Line":0},"fn_name":"other_thing"},{"line":20,"address":[355054],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","carson","projects","aglet","aglet-text","src","cursor.rs"],"content":"use std::convert::From;\nuse std::mem;\nuse std::str::Chars;\n\nuse crate::Span;\n\npub struct Cursor\u003c'a\u003e {\n    src: Chars\u003c'a\u003e,\n    tok: Chars\u003c'a\u003e,\n    n:   usize,\n    t:   usize,\n}\n\nimpl\u003c'a\u003e Cursor\u003c'a\u003e {\n    pub fn new\u003cT: Into\u003c\u0026'a str\u003e\u003e(src: T) -\u003e Self {\n        let chars = src.into().chars();\n        Cursor {\n            src: chars.clone(),\n            tok: chars,\n            n:   0,\n            t:   0,\n        }\n    }\n\n    pub fn first(\u0026self) -\u003e Option\u003cchar\u003e {\n        self.src.clone().next()\n    }\n\n    pub fn second(\u0026self) -\u003e Option\u003cchar\u003e {\n        self.src.clone().skip(1).next()\n    }\n\n    pub fn next(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        match self.src.next() {\n            Some(c) =\u003e {\n                self.n += 1;\n                Some(c)\n            },\n            _ =\u003e None,\n        }\n    }\n\n    pub fn skip(\u0026mut self, n: usize) {\n        for _ in 0..n {\n            self.bump();\n        }\n    }\n\n    pub fn bump(\u0026mut self) {\n        match self.src.next() {\n            Some(_) =\u003e self.n += 1,\n            _ =\u003e (),\n        }\n    }\n\n    pub fn span(\u0026self) -\u003e Span {\n        Span::new(self.t, self.n)\n    }\n\n    pub fn take_span(\u0026mut self) -\u003e Span {\n        let span = Span::new(self.t, self.n);\n        self.t = self.n;\n\n        span\n    }\n\n    pub fn text(\u0026self) -\u003e String {\n        self.tok.clone().take(self.n - self.t).collect::\u003cString\u003e()\n    }\n\n    pub fn take_text(\u0026mut self) -\u003e String {\n        let mut next_tok = self.src.clone();\n        mem::swap(\u0026mut next_tok, \u0026mut self.tok);\n        let text = next_tok.take(self.n - self.t).collect::\u003cString\u003e();\n        self.t = self.n;\n\n        text\n    }\n\n    pub fn map\u003cB, F\u003e(\u0026mut self, f: F) -\u003e B\n    where\n        F: FnOnce(Span, String) -\u003e B,\n    {\n        let span = self.span();\n        let text = self.take_text();\n\n        f(span, text)\n    }\n\n    pub fn map_span\u003cB, F\u003e(\u0026mut self, f: F) -\u003e B\n    where\n        F: FnOnce(Span) -\u003e B,\n    {\n        f(self.take_span())\n    }\n\n    pub fn matches(\u0026mut self, c: char) -\u003e bool {\n        match self.first() {\n            Some(found) if found == c =\u003e {\n                self.skip(1);\n                true\n            },\n            _ =\u003e false,\n        }\n    }\n\n    pub fn reset(\u0026mut self) {\n        self.tok = self.src.clone();\n        self.t = self.n;\n    }\n}\n\nimpl\u003c'a, T: Into\u003c\u0026'a str\u003e\u003e From\u003cT\u003e for Cursor\u003c'a\u003e {\n    fn from(value: T) -\u003e Self {\n        Cursor::new(value)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[165360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[165369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[165408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[165417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[165456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[165470],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[165509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[165521,165567,165577],"length":1,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[165571],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[165543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[165616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[165634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[165710],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[165728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[165742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[165818,165781],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[165856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[165861],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[165888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[165902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[165930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[165952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[166087,165984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[166128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[166160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[166180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[166311,166199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[166298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[422992,423173,422949,422768,422973,423197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":97,"address":[166352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[166373],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[166411,166438],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[166446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[166456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[166427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[166480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[166494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[166512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":50},{"path":["/","home","carson","projects","aglet","aglet-text","src","error.rs"],"content":"#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"invalid input filename: {0}\")]\n    InvalidFilename(std::path::PathBuf),\n    #[error(\"io error: {0}\")]\n    IOError(#[from] std::io::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-text","src","lib.rs"],"content":"mod cursor;\nmod error;\nmod source_map;\nmod span;\n\nuse std::default::Default;\n\npub use cursor::Cursor;\npub use error::Error;\npub use source_map::{FileId, SourceFile, SourceMap};\npub use span::{FilePosition, FileSpan, Span};\n\npub trait DefaultWithSpan\nwhere\n    Self: Default,\n{\n    fn default_with_span(span: Span) -\u003e Self;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-text","src","source_map.rs"],"content":"use std::collections::HashMap;\nuse std::fs;\nuse std::path::Component::Normal;\nuse std::path::Path;\n\nuse crate::span::{FilePosition, FileSpan, Span};\nuse crate::Error;\n\npub type FileId = u32;\n\n#[derive(Debug, Clone)]\npub struct SourceFile {\n    pub prefix:   String,\n    pub filename: String,\n    pub src:      String,\n    pub lines:    Vec\u003cusize\u003e,\n}\n\nimpl SourceFile {\n    pub fn load_file(path: \u0026Path) -\u003e Result\u003cSelf, Error\u003e {\n        let prefix = String::from(\n            path.canonicalize()?\n                .parent()\n                .map(|p| p.to_path_buf())\n                .unwrap_or_default()\n                .to_str()\n                .ok_or_else(|| Error::InvalidFilename(path.to_path_buf()))?,\n        );\n\n        let filename = String::from(match path.components().last() {\n            Some(Normal(p)) =\u003e p\n                .to_str()\n                .ok_or_else(|| Error::InvalidFilename(path.to_path_buf())),\n            _ =\u003e Err(Error::InvalidFilename(path.to_path_buf())),\n        }?);\n\n        let src = fs::read_to_string(path)?;\n\n        Ok(SourceFile::new_from_source(prefix, filename, src))\n    }\n\n    pub fn new_from_source(prefix: String, filename: String, src: String) -\u003e Self {\n        let lines = SourceFile::map_lines(\u0026src);\n\n        Self {\n            prefix,\n            filename,\n            src,\n            lines,\n        }\n    }\n\n    pub fn file_position_from_offset(\u0026self, offset: \u0026usize) -\u003e Option\u003cFilePosition\u003e {\n        self.lines\n            .iter()\n            .enumerate()\n            .rev()\n            .find(|(_, start_offset)| start_offset \u003c= \u0026offset)\n            .map(|(line, start_offset)| FilePosition {\n                offset: *offset,\n                line:   line + 1,\n                column: offset - start_offset + 1,\n            })\n    }\n\n    fn map_lines(src: \u0026str) -\u003e Vec\u003cusize\u003e {\n        src.lines()\n            .scan(0, |state, line| {\n                let res = Some(*state);\n                *state = *state + line.len() + 1;\n                res\n            })\n            .collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct SourceMap {\n    next_id: FileId,\n    files:   HashMap\u003cFileId, SourceFile\u003e,\n}\n\nimpl SourceMap {\n    pub fn new() -\u003e Self {\n        Self {\n            next_id: 0,\n            files:   HashMap::new(),\n        }\n    }\n\n    pub fn add_file(\u0026mut self, file: SourceFile) -\u003e FileId {\n        let id = self.next_id;\n        self.next_id += 1;\n\n        self.files.insert(id, file);\n        id\n    }\n\n    pub fn get_span(\u0026self, file_id: \u0026FileId, span: \u0026Span) -\u003e Option\u003cFileSpan\u003e {\n        let source = self.files.get(file_id)?;\n        let start = source.file_position_from_offset(\u0026span.start)?;\n        let end = source.file_position_from_offset(\u0026span.end)?;\n\n        Some(FileSpan {\n            file_id: *file_id,\n            start,\n            end,\n        })\n    }\n\n    pub fn get_file(\u0026self, file_id: \u0026FileId) -\u003e Option\u003c\u0026SourceFile\u003e {\n        self.files.get(file_id)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_file_init() {\n        let input = vec![\"abcd\", \"\", \"efgh\"].join(\"\\n\");\n        let file = SourceFile::new_from_source(\n            \"\u003ctest\u003e\".to_string(),\n            \"test_file\".to_string(),\n            input.clone(),\n        );\n\n        assert_eq!(file.prefix, \"\u003ctest\u003e\".to_string());\n        assert_eq!(file.filename, \"test_file\".to_string());\n        assert_eq!(file.src, input);\n        assert_eq!(file.lines, vec![0, 5, 6]);\n    }\n\n    #[test]\n    fn test_file_positions() {\n        let input = vec![\n            \"01234\", // 0-5\n            \"67\",    // 6-8\n            \"\",      // 9\n            \"012\",   // 10-12\n        ]\n        .join(\"\\n\");\n        let file = SourceFile::new_from_source(\"\".to_string(), \"\u003ctest\u003e\".to_string(), input);\n\n        let pos = file.file_position_from_offset(\u00263).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 3);\n        assert_eq!(pos.line, 1);\n        assert_eq!(pos.column, 4);\n\n        let pos = file.file_position_from_offset(\u00265).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 5);\n        assert_eq!(pos.line, 1);\n        assert_eq!(pos.column, 6);\n\n        let pos = file.file_position_from_offset(\u00267).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 7);\n        assert_eq!(pos.line, 2);\n        assert_eq!(pos.column, 2);\n\n        let pos = file.file_position_from_offset(\u002611).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 11);\n        assert_eq!(pos.line, 4);\n        assert_eq!(pos.column, 2);\n    }\n}\n","traces":[{"line":20,"address":[573126,571136,573033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[168835,169034,168888,168451,168691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[580416,580438],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":27,"address":[580464,580487],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":30,"address":[572378,573114,572238,571979,572473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[169403,169318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[226832,226855],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":34,"address":[169296,169459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[170055,169782,169718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[169894,170127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[170702,170736,170352],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[170391,170460],"length":1,"stats":{"Line":8},"fn_name":null},{"line":53,"address":[170752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[170845,170787,170878],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[170835],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[170868],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[227036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[227103,227052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[227173,227073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[170912],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[170944],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[227216],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":69,"address":[227271],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[227405,227288],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[171008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[171022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[171072,171354,171381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[171097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[171264,171127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[171165,171335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[171392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[171570,171464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[171589,171530,171687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[171707,171628,171440,171901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[171757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[171755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[171920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[171934],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":38},{"path":["/","home","carson","projects","aglet","aglet-text","src","span.rs"],"content":"use std::default::Default;\nuse std::fmt;\n\nuse crate::source_map::FileId;\n\n#[derive(Copy, Clone, PartialEq, Eq)]\npub struct Span {\n    pub start: usize,\n    pub end:   usize,\n}\n\nimpl Span {\n    pub fn new(start: usize, end: usize) -\u003e Self {\n        Self { start, end }\n    }\n\n    pub fn wrap(start: \u0026Span, end: \u0026Span) -\u003e Self {\n        Span {\n            start: start.start,\n            end:   end.end,\n        }\n    }\n}\n\nimpl fmt::Debug for Span {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}-{}\", self.start, self.end)\n    }\n}\n\nimpl fmt::Display for Span {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}-{}\", self.start, self.end)\n    }\n}\n\nimpl Default for Span {\n    fn default() -\u003e Self {\n        Self { start: 0, end: 0 }\n    }\n}\n\npub struct FileSpan {\n    pub file_id: FileId,\n    pub start:   FilePosition,\n    pub end:     FilePosition,\n}\n\nimpl fmt::Debug for FileSpan {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(\n            f,\n            \"\u003cfile_id {}\u003e {:?}-{:?}\",\n            self.file_id, self.start, self.end\n        )\n    }\n}\n\nimpl fmt::Display for FileSpan {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}-{}\", self.start, self.end)\n    }\n}\n\npub struct FilePosition {\n    pub offset: usize,\n    pub line:   usize,\n    pub column: usize,\n}\n\nimpl fmt::Debug for FilePosition {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}:{}[{}]\", self.line, self.column, self.offset)\n    }\n}\n\nimpl fmt::Display for FilePosition {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}:{}\", self.line, self.column)\n    }\n}\n","traces":[{"line":13,"address":[575712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[160032],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[1011354],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[160045],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[1011392],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":27,"address":[160156,160193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[575984],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":33,"address":[1011660,1011697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[160496],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":51,"address":[1011832,1011943,1011995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[160784],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":61,"address":[160860,160897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[160976],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":73,"address":[161062,161159,161000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[161264],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":79,"address":[161384,161285,161347],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":16}]};
        var previousData = {"files":[{"path":["/","home","carson","projects","aglet","aglet","src","commands","mod.rs"],"content":"pub mod regex;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet","src","commands","regex.rs"],"content":"use std::path::PathBuf;\n\nuse aglet_pretty::{ColorWhen, PrettyPrintSettings, PrettyPrinter};\nuse aglet_regex::{Parser, Tokenizer};\nuse aglet_text::SourceFile;\nuse clap::Args;\nuse colored::control::ShouldColorize;\nuse colored::Colorize;\nuse eyre::{eyre, Result};\nuse itertools::Itertools;\n\nuse crate::{CliInput, Input};\n\n#[derive(Debug, Args)]\npub struct RegexArgs {\n    /// Print the token stream\n    #[arg(short, long)]\n    tokens: bool,\n\n    /// Print the resulting abstract syntax tree\n    #[arg(short, long)]\n    ast: bool,\n\n    /// Display the span of each token or AST node\n    #[arg(short, long)]\n    spans: bool,\n\n    /// Include metadata column for each token or AST node\n    #[arg(short, long)]\n    meta: bool,\n\n    /// Remove alignment spacing in the spans column\n    #[arg(long)]\n    no_align: bool,\n\n    /// Disable colour output\n    #[arg(long)]\n    no_color: bool,\n\n    /// Force color output\n    #[arg(long)]\n    force_color: bool,\n\n    /// Use test mode - generate test output or test input data.\n    ///\n    /// Implies --no_color, --no_align, --ast, and --tokens\n    #[arg(short = 'T', long)]\n    test: bool,\n\n    /// Output file\n    #[arg(short, long)]\n    out: Option\u003cPathBuf\u003e,\n}\n\npub fn run(input: Input, args: RegexArgs) -\u003e Result\u003c()\u003e {\n    let is_stdin = input.is_stdin();\n    let iter = SectionIterator::new(Box::new(input), !is_stdin);\n\n    let color_supported = ShouldColorize::from_env().should_colorize();\n    let color_when = match (color_supported, args.no_color, args.force_color) {\n        (true, false, false) =\u003e ColorWhen::Auto,\n        (_, _, true) =\u003e ColorWhen::Always,\n        _ =\u003e ColorWhen::Never,\n    };\n    let printer_settings = PrettyPrintSettings::default()\n        .indent(\"\\u{254E}   \".bright_black().to_string().as_ref())\n        .color_when(color_when)\n        .align(!args.no_align)\n        .include_spans(args.spans);\n\n    if is_stdin \u0026\u0026 (!args.tokens \u0026\u0026 !args.ast) {\n        println!(\"Warning: no output options used (try --ast or --tokens)\");\n    }\n\n    for section in iter {\n        let section = section?;\n        let printer_settings = printer_settings.clone().source(section.source.clone());\n        run_section(\u0026section, \u0026printer_settings, is_stdin, \u0026args)?;\n    }\n\n    Ok(())\n}\n\nfn run_section(\n    section: \u0026InputSection,\n    printer_settings: \u0026PrettyPrintSettings,\n    is_stdin: bool,\n    args: \u0026RegexArgs,\n) -\u003e Result\u003c()\u003e {\n    if !is_stdin {\n        println!(\"{}\\n\", section.source.src);\n    }\n\n    if args.tokens {\n        print_tokens(section, printer_settings.clone(), args)?;\n    }\n\n    if args.ast {\n        print_ast(section, printer_settings.clone())?;\n    }\n\n    Ok(())\n}\n\nfn print_tokens(\n    section: \u0026InputSection,\n    printer_settings: PrettyPrintSettings,\n    args: \u0026RegexArgs,\n) -\u003e Result\u003c()\u003e {\n    let mut printer = PrettyPrinter::new(printer_settings);\n\n    let tokenizer = Tokenizer::new(section.source.src.as_ref());\n    if args.meta {\n        for token_stack in tokenizer.into_token_stack_iter() {\n            match token_stack {\n                Ok(stack) =\u003e {\n                    printer.print(\u0026stack)?;\n                },\n                Err(stack_error) =\u003e {\n                    printer.print(\u0026stack_error)?;\n                },\n            }\n        }\n    } else {\n        for token in tokenizer {\n            match token {\n                Ok(tok) =\u003e {\n                    printer.print(\u0026tok)?;\n                },\n                Err(e) =\u003e {\n                    printer.print(\u0026e)?;\n                },\n            }\n        }\n    }\n\n    println!(\"TOKENS:\\n{}\\n\", printer.finish()?);\n\n    Ok(())\n}\n\nfn print_ast(section: \u0026InputSection, printer_settings: PrettyPrintSettings) -\u003e Result\u003c()\u003e {\n    let mut printer = PrettyPrinter::new(printer_settings);\n\n    let tokens = Tokenizer::new(section.source.src.as_ref()).collect_vec();\n    let parse_result = Parser::new(tokens.into_iter()).parse();\n    println!(\"AST:\\n{}\\n\", printer.print(\u0026parse_result.ast)?.finish()?);\n    if parse_result.errors.len() \u003e 0 {\n        println!(\n            \"PARSE ERR:\\n{}\\n\",\n            parse_result.errors.into_iter().join(\"\\n\")\n        );\n    }\n\n    Ok(())\n}\n\nstruct InputSection {\n    source: SourceFile,\n    tests:  Vec\u003cTestKind\u003e,\n}\n\nenum TestKind {\n    TokenTest(String),\n    AstTest(String),\n}\n\nstruct SectionIterator {\n    input:        CliInput,\n    last_section: Option\u003cInputSection\u003e,\n    allow_tests:  bool,\n}\n\nimpl SectionIterator {\n    fn new(input: CliInput, allow_tests: bool) -\u003e Self {\n        Self {\n            input: condense_input(input),\n            last_section: None,\n            allow_tests,\n        }\n    }\n\n    fn next_section(\u0026mut self) -\u003e Result\u003cOption\u003cInputSection\u003e\u003e {\n        loop {\n            let data = self.next_block()?;\n\n            if data.len() == 0 {\n                return Ok(self.last_section.take());\n            }\n\n            let header = data[0].to_lowercase();\n            if self.allow_tests \u0026\u0026 header.starts_with(\"token\") {\n                self.add_test(TestKind::TokenTest(data[1..].join(\"\\n\")))?;\n            } else if self.allow_tests \u0026\u0026 header.starts_with(\"ast\") {\n                self.add_test(TestKind::AstTest(data[1..].join(\"\\n\")))?;\n            } else {\n                let section = self.start_section(data.join(\"\\n\"));\n                if section.is_some() {\n                    return Ok(section);\n                }\n                if !self.allow_tests {\n                    return Ok(self.last_section.take());\n                }\n            }\n        }\n    }\n\n    fn next_block(\u0026mut self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let data = self\n            .input\n            .by_ref()\n            .take_while(|line| match line {\n                Ok(line) =\u003e line.len() \u003e 0,\n                _ =\u003e true,\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        Ok(data)\n    }\n\n    fn add_test(\u0026mut self, test: TestKind) -\u003e Result\u003c()\u003e {\n        let Some(section) = \u0026mut self.last_section else {\n            return Err(eyre!(\"no section for test\"));\n        };\n\n        section.tests.push(test);\n        Ok(())\n    }\n\n    fn start_section(\u0026mut self, input: String) -\u003e Option\u003cInputSection\u003e {\n        self.last_section.replace(InputSection {\n            source: SourceFile::new_from_source(\"\".to_string(), \"\u003cstdin\u003e\".to_string(), input),\n            tests:  Vec::new(),\n        })\n    }\n}\n\nimpl Iterator for SectionIterator {\n    type Item = Result\u003cInputSection\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        match self.next_section() {\n            Ok(Some(section)) =\u003e Some(Ok(section)),\n            Ok(None) =\u003e None,\n            Err(err) =\u003e Some(Err(err)),\n        }\n    }\n}\n\nfn condense_input(input: CliInput) -\u003e CliInput {\n    let input = input\n        .scan(None, |last_len: \u0026mut Option\u003cusize\u003e, item| {\n            match (item, *last_len) {\n                (Ok(line), Some(len)) =\u003e {\n                    let should_filter = line.len() == 0 \u0026\u0026 len == 0;\n                    *last_len = Some(line.len());\n                    Some((should_filter, Ok(line)))\n                },\n                (Ok(line), None) =\u003e {\n                    *last_len = Some(line.len());\n                    Some((false, Ok(line)))\n                },\n                (res, _) =\u003e {\n                    *last_len = None;\n                    Some((false, res))\n                },\n            }\n        })\n        .filter_map(|(should_filter, item)| if should_filter { None } else { Some(item) });\n\n    Box::new(input)\n}\n\n#[cfg(test)]\nmod tests {\n    use itertools::Itertools;\n\n    use super::*;\n\n    #[test]\n    fn test_condense_input() {\n        let input = vec![\n            Ok(\"line 1\".to_string()),\n            Ok(\"line 2\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"line 3\".to_string()),\n            Ok(\"line 4\".to_string()),\n            Err(eyre!(\"err 1\")),\n            Err(eyre!(\"err 2\")),\n            Ok(\"\".to_string()),\n            Err(eyre!(\"err 3\")),\n            Ok(\"\".to_string()),\n            Ok(\"\".to_string()),\n        ]\n        .into_iter();\n\n        let expected = vec![\n            Ok(\"line 1\".to_string()),\n            Ok(\"line 2\".to_string()),\n            Ok(\"\".to_string()),\n            Ok(\"line 3\".to_string()),\n            Ok(\"line 4\".to_string()),\n            Err(eyre!(\"err 1\")),\n            Err(eyre!(\"err 2\")),\n            Ok(\"\".to_string()),\n            Err(eyre!(\"err 3\")),\n            Ok(\"\".to_string()),\n        ];\n\n        let actual = condense_input(Box::new(input)).collect_vec();\n        assert_eq!(expected.len(), actual.len());\n\n        for (expected, actual) in expected.into_iter().zip(actual) {\n            if let (Ok(expected), Ok(actual)) = (\u0026expected, \u0026actual) {\n                assert_eq!(expected, actual);\n            } else if let (Err(expected), Err(actual)) = (\u0026expected, \u0026actual) {\n                assert_eq!(expected.to_string(), actual.to_string());\n            } else {\n                panic!(\"can't compare {:?} and {:?}\", expected, actual);\n            }\n        }\n    }\n\n    #[test]\n    fn test_input_iter() {\n        let input = vec![\n            \"abc\",\n            \"def\",\n            \"\",\n            \"\",\n            \"TOKENS:\",\n            \"token test\",\n            \"data\",\n            \"\",\n            \"ghi\",\n            \"jkl\",\n            \"\",\n            \"TOKENS ===\",\n            \"\",\n            \"AST ===\",\n            \"ast data\",\n        ]\n        .into_iter()\n        .map(|line| Ok(line.to_string()) as Result\u003cString\u003e);\n\n        let mut iter = SectionIterator::new(Box::new(input), true);\n\n        let section = iter.next().unwrap().unwrap();\n        assert_eq!(section.source.src, \"abc\\ndef\".to_string());\n        assert_eq!(section.tests.len(), 1);\n        assert!(matches!(section.tests[0], TestKind::TokenTest(_)));\n        let TestKind::TokenTest(data) = \u0026section.tests[0] else {\n            panic!(\"not a token test\");\n        };\n        assert_eq!(data, \"token test\\ndata\");\n\n        let section = iter.next().unwrap().unwrap();\n        assert_eq!(section.source.src, \"ghi\\njkl\");\n        assert_eq!(section.tests.len(), 2);\n        assert!(matches!(section.tests[0], TestKind::TokenTest(_)));\n        let TestKind::TokenTest(data) = \u0026section.tests[0] else {\n            panic!(\"not a token test\");\n        };\n        assert_eq!(data, \"\");\n        assert!(matches!(section.tests[1], TestKind::AstTest(_)));\n        let TestKind::AstTest(data) = \u0026section.tests[1] else {\n            panic!(\"not an ast test\");\n        };\n        assert_eq!(data, \"ast data\");\n\n        let section = iter.next();\n        assert!(section.is_none());\n    }\n\n    #[test]\n    fn test_input_iter_no_tests() {\n        let input = vec![\"abc\", \"def\", \"\"]\n            .into_iter()\n            .map(|line| Ok(line.to_string()) as Result\u003cString\u003e);\n\n        let mut iter = SectionIterator::new(Box::new(input), false);\n        let section = iter.next();\n        assert!(section.is_some());\n\n        let input = vec![\n            \"abc\",\n            \"def\",\n            \"\",\n            \"TOKENS:\",\n            \"misinterpreted\",\n            \"test data\",\n            \"\",\n        ]\n        .into_iter()\n        .map(|line| Ok(line.to_string()));\n\n        let mut iter = SectionIterator::new(Box::new(input), false);\n\n        let section = iter.next();\n        assert!(section.is_some());\n        let Some(Ok(section)) = section else {\n            panic!(\"error reading section\");\n        };\n        assert_eq!(section.source.src, \"abc\\ndef\".to_string());\n        assert_eq!(section.tests.len(), 0);\n\n        let section = iter.next();\n        assert!(section.is_some());\n        let Some(Ok(section)) = section else {\n            panic!(\"error reading section\");\n        };\n        assert_eq!(section.source.src, \"TOKENS:\\nmisinterpreted\\ntest data\");\n        assert_eq!(section.tests.len(), 0);\n\n        let section = iter.next();\n        assert!(section.is_none());\n    }\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":44,"coverable":95},{"path":["/","home","carson","projects","aglet","aglet","src","lib.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet","src","main.rs"],"content":"mod commands;\n\nuse std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::PathBuf;\n\nuse clap::{Parser, Subcommand};\nuse commands::regex::RegexArgs;\nuse eyre::Result;\n\n#[derive(Parser, Debug)]\n#[command(name = \"aglet\")]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n\n    /// Input file. Uses stdin if omitted\n    #[arg(short, long)]\n    input: Option\u003cPathBuf\u003e,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Tools for inspecting and debugging regular expressions\n    #[command(name = \"regex\")]\n    Regex(RegexArgs),\n}\n\ntype CliInput = Box\u003cdyn Iterator\u003cItem = Result\u003cString\u003e\u003e\u003e;\n\nfn main() -\u003e Result\u003c()\u003e {\n    color_eyre::install()?;\n\n    let args = Cli::parse();\n\n    let input = Input::new(args.input)?;\n    match args.command {\n        Commands::Regex(args) =\u003e commands::regex::run(input, args),\n    }?;\n\n    Ok(())\n}\n\npub struct Input {\n    input:    CliInput,\n    filename: String,\n    is_stdin: bool,\n}\n\nimpl Input {\n    pub fn new(input_path: Option\u003cPathBuf\u003e) -\u003e Result\u003cSelf\u003e {\n        let input = if let Some(input_path) = input_path {\n            let file = File::open(input_path.clone())?;\n            let iter = io::BufReader::new(file)\n                .lines()\n                .map(|res| res.map_err(|err| err.into()));\n\n            Self {\n                input:    Box::new(iter) as CliInput,\n                filename: input_path.to_string_lossy().to_string(),\n                is_stdin: false,\n            }\n        } else {\n            let iter = std::io::stdin()\n                .lines()\n                .map(|res| res.map_err(|err| err.into()));\n\n            Self {\n                input:    Box::new(iter) as CliInput,\n                filename: \"\u003cstdin\u003e\".to_string(),\n                is_stdin: true,\n            }\n        };\n\n        Ok(input)\n    }\n\n    #[inline]\n    pub fn is_stdin(\u0026self) -\u003e bool {\n        self.is_stdin\n    }\n\n    #[inline]\n    pub fn filename(\u0026self) -\u003e \u0026str {\n        \u0026self.filename\n    }\n}\n\nimpl Iterator for Input {\n    type Item = Result\u003cString\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.input.next()\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","home","carson","projects","aglet","aglet-derive","src","default_with_span.rs"],"content":"use proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{Data, DataStruct, DeriveInput, Ident, Type};\n\npub fn impl_default_with_span(input: DeriveInput) -\u003e TokenStream {\n    let type_name = input.ident;\n    if let Data::Struct(data) = input.data {\n        impl_for_struct(type_name, data)\n    } else if let Data::Enum(_) = input.data {\n        impl_with_no_span(type_name)\n    } else {\n        panic!(\"can only derive DefaultAst for structs and enums\");\n    }\n}\n\nfn impl_for_struct(type_name: Ident, data: DataStruct) -\u003e TokenStream {\n    if let Some((index, field)) = find_span_field(data.fields) {\n        if let Some(span_name) = field.ident {\n            impl_with_named_span(type_name, span_name)\n        } else {\n            impl_with_numbered_span(type_name, index)\n        }\n    } else {\n        impl_with_no_span(type_name)\n    }\n}\n\nfn find_span_field(fields: syn::Fields) -\u003e Option\u003c(usize, syn::Field)\u003e {\n    fields\n        .into_iter()\n        .enumerate()\n        .filter(|(_, field)| {\n            let is_named_span = field\n                .ident\n                .as_ref()\n                .map(|name| name == \"span\")\n                .unwrap_or_default();\n            let is_span_type = type_is_span(\u0026field.ty);\n\n            is_named_span || is_span_type\n        })\n        .next()\n}\n\nfn type_is_span(ty: \u0026Type) -\u003e bool {\n    let Type::Path(path) = ty else {\n        return false;\n    };\n\n    if path.path.is_ident(\"Span\") {\n        return true;\n    }\n\n    let Some(last_segment) = path.path.segments.last() else {\n        return false;\n    };\n\n    return last_segment.ident == \"Span\";\n}\n\nfn impl_with_named_span(type_name: Ident, span_name: Ident) -\u003e TokenStream {\n    let s = quote! {\n        impl aglet_text::DefaultWithSpan for #type_name {\n            fn default_with_span(span: aglet_text::Span) -\u003e Self {\n                let mut result: Self = core::default::Default::default();\n                result.#span_name = span;\n                result\n            }\n        }\n    };\n\n    s.into()\n}\n\nfn impl_with_numbered_span(type_name: Ident, index: usize) -\u003e TokenStream {\n    let s = quote! {\n        impl aglet_text::DefaultWithSpan for #type_name {\n            fn default_with_span(span: aglet_text::Span) -\u003e Self {\n                let mut result: Self = core::default::Default::default();\n                result.#index = span;\n                result\n            }\n        }\n    };\n\n    s.into()\n}\n\nfn impl_with_no_span(type_name: Ident) -\u003e TokenStream {\n    let s = quote! {\n        impl aglet_text::DefaultWithSpan for #type_name {\n            fn default_with_span(_: aglet_text::Span) -\u003e Self {\n                core::default::Default::default()\n            }\n        }\n    };\n\n    s.into()\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":51},{"path":["/","home","carson","projects","aglet","aglet-derive","src","lib.rs"],"content":"mod default_with_span;\n\nuse proc_macro::TokenStream;\nuse syn::{parse_macro_input, DeriveInput};\n\n#[proc_macro_derive(DefaultWithSpan)]\npub fn default_with_span(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    default_with_span::impl_default_with_span(input)\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","carson","projects","aglet","aglet-ingest","src","lib.rs"],"content":"mod position;\nmod span;\n\npub use position::Position;\npub use span::Span;\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-ingest","src","position.rs"],"content":"#[derive(Copy, Clone)]\npub struct Position {\n    pub idx: usize,\n    pub line: u32,\n    pub col: u32,\n}\n\nimpl Position {\n    pub fn new() -\u003e Self {\n        Position {\n            idx: 0,\n            line: 1,\n            col: 1,\n        }\n    }\n\n    pub fn set(\u0026mut self, other: Position) {\n        self.idx = other.idx;\n        self.line = other.line;\n        self.col = other.col;\n    }\n\n    pub fn advance(\u0026mut self, c: char) {\n        self.idx += 1;\n\n        if c == '\\n' {\n            self.line += 1;\n            self.col = 1;\n        } else {\n            self.col += 1;\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-ingest","src","span.rs"],"content":"use crate::position::Position;\n\npub struct Span\u003c'a\u003e {\n    pub text: \u0026'a str,\n    pub start: Position,\n    pub end: Position,\n}\n\nimpl \u003c'a\u003e Span\u003c'a\u003e {\n    pub fn new(text: \u0026'a str) -\u003e Self {\n        Span {\n            text,\n            start: Position::new(),\n            end: Position::new(),\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","ast_printer.rs"],"content":"use std::fmt::{self, Write};\n\nuse aglet_text::Span;\nuse colored::{Color, Colorize};\n\nuse crate::{Pretty, Result, Writer};\n\nconst DEFAULT_COLOR: Color = Color::White;\nconst PARAMETER_COLOR: Color = Color::TrueColor {\n    r: 150,\n    g: 150,\n    b: 150,\n};\n\n/// Printer for an abstract syntax tree\n///\n/// Tree nodes can be printed with properties and children, with children being\n/// printed indented as another node.\n///\n/// # Example\n///\n/// An alternation node with two literal children might be printed like this:\n///\n/// ```ast\n/// (Alternation\n///     (Literal value='a')\n///     (Literal value='b'))\n/// ```\npub struct AstPrinter\u003c'a, 'b: 'a\u003e {\n    writer: \u0026'a mut Writer\u003c'b\u003e,\n    result: Result,\n}\n\nimpl\u003c'a, 'b: 'a\u003e AstPrinter\u003c'a, 'b\u003e {\n    /// Begin printing an AST node - its name will be printed, and its span will be added\n    /// to the output at this stage.\n    ///\n    /// To keep spans aligned with their nodes, all children should either also be printed\n    /// with this printer, or the caller that adds the children needs to supply a span\n    /// (or `None`) for each child printed which isn't a node.\n    pub fn new(\n        writer: \u0026'a mut Writer\u003c'b\u003e,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e Self {\n        let result = Ok(()).and_then(|_| {\n            if writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(writer, \"({}\", name.color(color))?;\n            } else {\n                write!(writer, \"({}\", name)?;\n            }\n\n            Ok(())\n        });\n\n        writer.add_span(span);\n\n        AstPrinter { writer, result }\n    }\n\n    /// Add a property to the node.\n    ///\n    /// Properties are printed on the same line as the node, and can optionally be\n    /// prefixed with a name.\n    pub fn property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: \u0026impl fmt::Debug,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        self.result = self.result.and_then(|_| {\n            let name_text = if let Some(name) = name {\n                format!(\"{}=\", name)\n            } else {\n                String::new()\n            };\n\n            if self.writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(\n                    self.writer,\n                    \" {}{}\",\n                    name_text.color(PARAMETER_COLOR).italic(),\n                    format!(\"{:?}\", value).color(color)\n                )?;\n            } else {\n                write!(self.writer, \" {}{:?}\", name_text, value)?;\n            }\n\n            Ok(())\n        });\n\n        self\n    }\n\n    /// Maybe add a property to the node.\n    ///\n    /// The property will be added if `value` is not `None`. The property is printed\n    /// on the same line as the node and can be optionally prefixed with a name.\n    pub fn maybe_property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: Option\u003c\u0026impl fmt::Debug\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        if let Some(value) = value {\n            self.property(name, value, color)\n        } else {\n            self\n        }\n    }\n\n    /// Add a child to the node.\n    ///\n    /// The child will be recursively pretty printed at a higher level of indentation.\n    /// Children are printed on a new line and so should add a value to `w.spans`\n    /// and to `w.meta` if applicable.\n    pub fn child(\u0026mut self, name: Option\u003c\u0026str\u003e, item: \u0026impl Pretty) -\u003e \u0026mut Self {\n        self.result = self.result.and_then(|_| {\n            write!(self.writer, \"\\n\")?;\n\n            self.writer.level += 1;\n            if let Some(name) = name {\n                write!(self.writer, \"{}: \", name)?;\n            }\n\n            item.print(self.writer)?;\n            self.writer.level -= 1;\n\n            Ok(())\n        });\n\n        self\n    }\n\n    /// Add multiple children to the node\n    ///\n    /// Children will be recursively printed at a higher level of indentation.\n    /// Children are printed on a new line and so should use [`Writer.add_span()`][1]\n    /// and [`Writer.add_meta()`][2] if appliccable\n    ///\n    /// [1]: crate::writer::Writer::add_span\n    /// [2]: crate::writer::Writer::add_meta\n    pub fn children(\u0026mut self, items: \u0026Vec\u003cimpl Pretty\u003e) -\u003e \u0026mut Self {\n        for item in items {\n            self.child(None, item);\n        }\n\n        self\n    }\n\n    /// Finish the AST node.\n    ///\n    /// Writes the closing `)` of the node and returns the result of printing all of its\n    /// parts. If errors occurred, only the first will be returned (an no printing will have\n    /// taken place since it occurred).\n    pub fn finish(\u0026mut self) -\u003e Result {\n        self.result.and_then(|_| {\n            write!(self.writer, \")\")?;\n            Ok(())\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use aglet_text::Span;\n\n    use super::*;\n    use crate::{ColorWhen, PrettyPrintSettings, PrettyPrinter};\n\n    struct Expr {\n        kind: ExprKind,\n    }\n\n    impl Pretty for Expr {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            w.print(\u0026self.kind)\n        }\n    }\n\n    enum ExprKind {\n        Add(Add),\n        Number(Number),\n    }\n\n    impl Pretty for ExprKind {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            match self {\n                Self::Add(add) =\u003e w.print(add),\n                Self::Number(number) =\u003e w.print(number),\n            }\n        }\n    }\n\n    struct Add {\n        span:  Span,\n        left:  Box\u003cExpr\u003e,\n        right: Box\u003cExpr\u003e,\n    }\n\n    impl Pretty for Add {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            w.print_ast(\"Add\", Some(self.span), None)\n                .child(None, \u0026*self.left)\n                .child(None, \u0026*self.right)\n                .finish()\n        }\n    }\n\n    struct Number {\n        span:  Span,\n        value: i32,\n    }\n\n    impl Pretty for Number {\n        fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n            w.print_ast(\"Number\", Some(self.span), None)\n                .property(Some(\"value\"), \u0026self.value, None)\n                .finish()\n        }\n    }\n\n    #[test]\n    fn print_ast() {\n        // 10 + -1 + 6\n        // 0   4   8\n        let expr = Expr {\n            kind: ExprKind::Add(Add {\n                span:  Span::new(0, 11),\n                left:  Box::new(Expr {\n                    kind: ExprKind::Add(Add {\n                        span:  Span::new(0, 7),\n                        left:  Box::new(Expr {\n                            kind: ExprKind::Number(Number {\n                                span:  Span::new(0, 2),\n                                value: 10,\n                            }),\n                        }),\n                        right: Box::new(Expr {\n                            kind: ExprKind::Number(Number {\n                                span:  Span::new(5, 7),\n                                value: -1,\n                            }),\n                        }),\n                    }),\n                }),\n                right: Box::new(Expr {\n                    kind: ExprKind::Number(Number {\n                        span:  Span::new(10, 11),\n                        value: 6,\n                    }),\n                }),\n            }),\n        };\n\n        let mut printer = PrettyPrinter::new(\n            PrettyPrintSettings::default()\n                .align(false)\n                .include_meta(false)\n                .color_when(ColorWhen::Never),\n        );\n\n        let expected = concat!(\n            \"0 - 11:\\t(Add\\n\",\n            \"0 - 7:\\t  (Add\\n\",\n            \"0 - 2:\\t    (Number value=10)\\n\",\n            \"5 - 7:\\t    (Number value=-1))\\n\",\n            \"10 - 11:\\t  (Number value=6))\"\n        );\n\n        let out = printer.print(\u0026expr).expect(\"print failed\").finish();\n        assert!(out.is_ok());\n        let out = out.unwrap();\n        assert_eq!(expected, out);\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":24,"coverable":45},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","error.rs"],"content":"use std::fmt;\n\npub type Result = std::result::Result\u003c(), Error\u003e;\n\n#[derive(thiserror::Error, Debug, Clone, Copy)]\npub enum Error {\n    #[error(\"format error: {0}\")]\n    FormatError(#[from] fmt::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","lib.rs"],"content":"mod ast_printer;\nmod error;\nmod span_printer;\nmod token_printer;\nmod writer;\n\nuse std::{iter, result};\n\nuse aglet_text::{SourceFile, Span};\nuse ast_printer::AstPrinter;\nuse colored::control::ShouldColorize;\nuse colored::{Color, Colorize};\npub use error::*;\npub use span_printer::SpanPrinter;\nuse token_printer::TokenPrinter;\npub use writer::Writer;\n\nconst EXTRA_COLOR: Color = Color::TrueColor {\n    r: 150,\n    g: 150,\n    b: 150,\n};\n\n/// Pretty printer for parser data\n///\n/// The debug trait doesn't allow for pretty-printing outside of its struct,\n/// tuple, etc. printers. To print an AST without a lot of extraneous closing\n/// braces on their own lines, this separate pretty-printer provides the auto\n/// indentation for custom printers.\n///\n/// Printers can also supply text spans for each printed line, which will be\n/// displayed to the left of the main structure, as well as metadata which will\n/// be displayed to the right.\npub struct PrettyPrinter {\n    settings: PrettyPrintSettings,\n    main:     String,\n    spans:    Vec\u003cOption\u003cSpan\u003e\u003e,\n    meta:     Vec\u003cOption\u003cString\u003e\u003e,\n}\n\nimpl PrettyPrinter {\n    pub fn new(settings: PrettyPrintSettings) -\u003e Self {\n        let main = String::new();\n\n        Self {\n            settings,\n            main,\n            spans: Vec::new(),\n            meta: Vec::new(),\n        }\n    }\n\n    /// Print a pretty-printable structure\n    ///\n    /// The output string is kept internally until [`finish`](PrettyPrinter::finish) is\n    /// called, because while a nested structure like an AST only requires one call to\n    /// `print`, a list of structures like `tokens` requires many prints. Storing the\n    /// output as internal state across `print` invocations allows the printer to maintain\n    /// column widths until the entire dataset has been processed.\n    pub fn print(\u0026mut self, item: \u0026impl Pretty) -\u003e result::Result\u003c\u0026Self, Error\u003e {\n        let mut writer = Writer::new(\u0026mut self.main, \u0026mut self.spans, \u0026mut self.meta)\n            .with_indent(\u0026self.settings.indent);\n        match self.settings.color_when {\n            ColorWhen::Always =\u003e {\n                writer.use_color = true;\n            },\n            ColorWhen::Never =\u003e {\n                writer.use_color = false;\n            },\n            _ =\u003e (),\n        };\n\n        item.print(\u0026mut writer)?;\n\n        Ok(self)\n    }\n\n    /// Finish printing a dataset and return the formatted results\n    pub fn finish(\u0026self) -\u003e result::Result\u003cString, Error\u003e {\n        let use_color = match self.settings.color_when {\n            ColorWhen::Always =\u003e true,\n            ColorWhen::Auto =\u003e ShouldColorize::from_env().should_colorize(),\n            ColorWhen::Never =\u003e false,\n        };\n\n        // each span is transformed into a tuple of two formatted positions in order to\n        // align them in the output (`start` aligned to the left, `end` to the right,\n        // with the dash separating them in the center)\n        let span_lines = self\n            .spans\n            .iter()\n            .map(|maybe_span| {\n                maybe_span.as_ref().map(|span| {\n                    self.settings\n                        .source\n                        .as_ref()\n                        .and_then(|file| {\n                            let filename = file.filename.clone();\n                            let start = file.file_position_from_offset(\u0026span.start);\n                            let end = file.file_position_from_offset(\u0026span.end);\n\n                            start.and_then(|start| end.map(|end| (filename, start, end)))\n                        })\n                        .map(|(filename, start, end)| {\n                            (format!(\"{} {:?}\", filename, start), format!(\"{:?}\", end))\n                        })\n                        .unwrap_or_else(|| (format!(\"{:?}\", span.start), format!(\"{:?}\", span.end)))\n                })\n            })\n            // spans are optional, so chain them with a never-ending string of `None`\n            // so that the main output isn't cut short if they're missing\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // calculate the maximum width of the start and end spans to align the entire set\n        // to the same width\n        let (max_start, max_end) = if self.settings.align {\n            span_lines\n                .iter()\n                .fold((0, 0), |(acc_left, acc_right), line| {\n                    let (left, right) = line\n                        .as_ref()\n                        .map(|(l, r)| (l.len(), r.len()))\n                        .unwrap_or((acc_left, acc_right));\n                    (usize::max(left, acc_left), usize::max(right, acc_right))\n                })\n        } else {\n            // if the align setting is turned off, using 0 as a width has the same effect as\n            // not using alignment formatting at all\n            (0, 0)\n        };\n\n        // colored strings interfere with alignment, so the clean length (without any terminal\n        // color/style markers) of each line of the main column is added as context\n        let main_lines = self\n            .main\n            .lines()\n            .map(|line| (line, len_clean(line)))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let max_main = main_lines.iter().map(|(_, len)| *len).max().unwrap_or(0);\n\n        // span and meta lines are optional, so chain them with a neverending stream of `None`\n        // so they don't cut the output short if they're missing.\n        let span_lines = span_lines.into_iter().chain(iter::repeat(None));\n        let meta_lines = self.meta.iter().chain(iter::repeat(\u0026None));\n\n        Ok(main_lines\n            .into_iter()\n            .zip(span_lines)\n            .zip(meta_lines)\n            .map(|(((main, main_len), span), meta)| {\n                let span_column = if self.settings.include_spans {\n                    // format each span line into aligned columns. Terminal colors are added after\n                    // formatting, so the `{:\u003cmax_start$}` formatters are fine here (plus each\n                    // line is colored in the same way so they shouldn't interfere regardless)\n                    span.map(|(span_left, span_right)| {\n                        format!(\"{:\u003cmax_start$} - {:\u003emax_end$}:\\t\", span_left, span_right)\n                    })\n                    // colorize the span column if applicable\n                    .map(|span| {\n                        if use_color {\n                            span.color(EXTRA_COLOR).to_string()\n                        } else {\n                            span\n                        }\n                    })\n                    // account for lines with no span information\n                    .unwrap_or_else(|| {\n                        if self.settings.align {\n                            // if alignment is being used, output enough spaces to maintain\n                            // the column width (the max start and end width, plus 3 for \" - \")\n                            format!(\"{}:\\t\", \" \".repeat(max_start + max_end + 3))\n                        } else {\n                            String::new()\n                        }\n                    })\n                } else {\n                    String::new()\n                };\n\n                let main_column = if self.settings.include_meta {\n                    // Using `{:\u003cmax_main$}` doesn't account for the invisible formatting\n                    // characters, so the right number of spaces for alignment need to be\n                    // manually output for the main column data\n                    format!(\"{}{}\", main, \" \".repeat(max_main - main_len))\n                } else {\n                    main.to_string()\n                };\n\n                let meta_column = if self.settings.include_meta {\n                    meta.as_ref()\n                        .map(|meta| {\n                            if use_color {\n                                meta.color(EXTRA_COLOR).to_string()\n                            } else {\n                                meta.to_string()\n                            }\n                        })\n                        .unwrap_or_else(|| String::new())\n                } else {\n                    String::new()\n                };\n\n                // final output of all three columns. Some may be empty\n                format!(\"{}{}{}\", span_column, main_column, meta_column)\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\"))\n    }\n}\n\n/// Clean length of a string potentially containing terminal color markers\nfn len_clean(string: \u0026str) -\u003e usize {\n    enum State {\n        Count,\n        Match,\n        Filter,\n    }\n\n    let mut result = 0;\n    let mut state = State::Count;\n\n    // count each character not part of the terminal formatting syntax.\n    // terminal formatting is done with the sequence `\\x1b[`, a series of\n    // color/style options expressed as bytes, and `m`.\n    for c in string.chars() {\n        match state {\n            // count each character until the beginning of a format sequence `\\x1b` is\n            // encountered, and then switch to the match state to confirm the beginning\n            // of a sequence by finding `[`\n            State::Count =\u003e {\n                if c == '\\x1b' {\n                    state = State::Match;\n                    continue;\n                }\n\n                result += 1;\n            },\n            // the beginning of a format sequence `\\x1b` has been found, but unless it\n            // is immediately followed by `[` a format sequence has not been found; so\n            // either match it here or allow `\\x1b` to be counted. If a sequence has been\n            // found, switch to the filter state to ignore all characters in the sequence.\n            State::Match =\u003e {\n                if c == '[' {\n                    state = State::Filter;\n                    continue;\n                }\n\n                // count `\\x1b` and whatever was found after it\n                result += 2;\n            },\n            // ignore all bytes in a format sequence until the terminating byte `m`\n            // has been found\n            State::Filter =\u003e {\n                if c == 'm' {\n                    state = State::Count;\n                }\n            },\n        }\n    }\n\n    result\n}\n\n#[derive(Debug, Clone)]\npub struct PrettyPrintSettings {\n    source:        Option\u003cSourceFile\u003e,\n    align:         bool,\n    include_spans: bool,\n    include_meta:  bool,\n    color_when:    ColorWhen,\n    indent:        String,\n}\n\nimpl PrettyPrintSettings {\n    /// Add a source file to include line/column number information with spans\n    pub fn source(mut self, source: SourceFile) -\u003e Self {\n        self.source = Some(source);\n        self\n    }\n\n    /// Control whether the pretty printer should align its output columns\n    /// with extra spaces to ensure they line up visually.\n    pub fn align(mut self, value: bool) -\u003e Self {\n        self.align = value;\n        self\n    }\n\n    /// Control whether spans are printed in a column to the left of the main output\n    pub fn include_spans(mut self, value: bool) -\u003e Self {\n        self.include_spans = value;\n        self\n    }\n\n    /// Control whether optional metadata is printed in a column to the right of the main output\n    pub fn include_meta(mut self, value: bool) -\u003e Self {\n        self.include_meta = value;\n        self\n    }\n\n    /// Control whether output is printed in color\n    pub fn color_when(mut self, value: ColorWhen) -\u003e Self {\n        self.color_when = value;\n        self\n    }\n\n    /// Control how nested structures are indented in the output.\n    pub fn indent(mut self, value: \u0026str) -\u003e Self {\n        self.indent = value.to_string();\n        self\n    }\n}\n\nimpl Default for PrettyPrintSettings {\n    fn default() -\u003e Self {\n        Self {\n            source:        None,\n            align:         true,\n            include_spans: true,\n            include_meta:  true,\n            color_when:    ColorWhen::Auto,\n            indent:        \"  \".to_string(),\n        }\n    }\n}\n\n/// When to print output in color\n#[derive(Debug, Clone, Copy)]\npub enum ColorWhen {\n    /// Force output coloring\n    Always,\n\n    /// Use colored output when the terminal supports it, and/or delegate the decision to\n    /// the `CLICOLOR_FORCE`, `NO_COLOR`, and `CLICOLOR` environment variables\n    Auto,\n\n    // Turn off output colorin\n    Never,\n}\n\n/// Support pretty-printing\npub trait Pretty {\n    /// Pretty-print a value to a [`Writer`](crate::Writer)\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result;\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":58,"coverable":104},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","span_printer.rs"],"content":"pub trait SpanPrinter {\n    fn print_with_span(\u0026self, source: \u0026str);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","token_printer.rs"],"content":"use std::fmt::{self, Write};\n\nuse aglet_text::Span;\nuse colored::{Color, Colorize};\n\nuse crate::{Result, Writer};\n\nconst DEFAULT_COLOR: Color = Color::White;\nconst PARAMETER_COLOR: Color = Color::TrueColor {\n    r: 150,\n    g: 150,\n    b: 150,\n};\n\n///Printer for a tokenizer token\n///\n/// Tokens can optionally be printed with properties. They are printed all on one\n/// line, with no nesting components.\n///\n/// # Example\n///\n/// A literal token might be printed like this:\n///\n/// ```tok\n/// [Literal value='a']\n/// ```\npub struct TokenPrinter\u003c'a, 'b: 'a\u003e {\n    writer: \u0026'a mut Writer\u003c'b\u003e,\n    result: Result,\n}\n\nimpl\u003c'a, 'b: 'a\u003e TokenPrinter\u003c'a, 'b\u003e {\n    /// Begin printing the token = its name will be printed, and its span will be added\n    /// to the output at this stage. If the caller is printing the tokenizer's state stack\n    /// along with the token, it can be passed here as well and it will be printed\n    /// in the metadata column.\n    pub fn new(\n        writer: \u0026'a mut Writer\u003c'b\u003e,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        stack: Option\u003cString\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e Self {\n        let result = Ok(()).and_then(|_| {\n            if writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(writer, \"[{}\", name.color(color))?;\n            } else {\n                write!(writer, \"[{}\", name)?;\n            }\n\n            Ok(())\n        });\n\n        writer.add_span(span);\n        writer.add_meta(stack);\n\n        TokenPrinter { writer, result }\n    }\n\n    /// Add a property to the token.\n    ///\n    /// Properties can be optionally prefixed with a name\n    pub fn property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: \u0026impl fmt::Debug,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        self.result = self.result.and_then(|_| {\n            let name_text = if let Some(name) = name {\n                format!(\"{}=\", name)\n            } else {\n                String::new()\n            };\n\n            if self.writer.use_color {\n                let color = color.unwrap_or(DEFAULT_COLOR);\n                write!(\n                    self.writer,\n                    \" {}{}\",\n                    name_text.color(PARAMETER_COLOR),\n                    format!(\"{:?}\", value).color(color)\n                )?;\n            } else {\n                write!(self.writer, \" {}{:?}\", name_text, value)?;\n            }\n\n            Ok(())\n        });\n\n        self\n    }\n\n    /// Maybe add a property to the token.\n    ///\n    /// The property will be added if `value` is not `None`. It can be optionally\n    /// prefixed with a property name.\n    pub fn maybe_property(\n        \u0026mut self,\n        name: Option\u003c\u0026str\u003e,\n        value: Option\u003c\u0026impl fmt::Debug\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e \u0026mut Self {\n        if let Some(value) = value {\n            self.property(name, value, color)\n        } else {\n            self\n        }\n    }\n\n    /// Finish printing the token\n    ///\n    /// Writes the closing `]` of the token and and returns the result of printing all of\n    /// its parts. If errors occurred, only the first will be returned (and no printing will\n    /// have taken place since it occurred).\n    pub fn finish(\u0026mut self) -\u003e Result {\n        self.result.and_then(|_| {\n            write!(self.writer, \"]\\n\")?;\n            Ok(())\n        })\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","carson","projects","aglet","aglet-pretty","src","writer.rs"],"content":"use std::fmt::{self, Write};\n\nuse aglet_text::Span;\nuse colored::control::ShouldColorize;\nuse colored::Color;\n\nuse crate::{AstPrinter, Pretty, Result, TokenPrinter};\n\n/// Writer for pretty-printing parser structures\n///\n/// The writer keeps track of the indentation of nested structures, as well as\n/// spans and metadata that should be reported along with the main output.\npub struct Writer\u003c'a\u003e {\n    buf:                  \u0026'a mut (dyn Write + 'a),\n    spans:                \u0026'a mut Vec\u003cOption\u003cSpan\u003e\u003e,\n    meta:                 \u0026'a mut Vec\u003cOption\u003cString\u003e\u003e,\n    on_newline:           bool,\n    indent:               String,\n    pub(crate) level:     u32,\n    pub(crate) use_color: bool,\n}\n\nimpl\u003c'a\u003e Writer\u003c'a\u003e {\n    pub fn new\u003cT\u003e(\n        buf: \u0026'a mut T,\n        spans: \u0026'a mut Vec\u003cOption\u003cSpan\u003e\u003e,\n        meta: \u0026'a mut Vec\u003cOption\u003cString\u003e\u003e,\n    ) -\u003e Self\n    where\n        T: Write + 'a,\n    {\n        Self {\n            buf,\n            spans,\n            meta,\n            on_newline: true,\n            indent: \"\\t\".to_string(),\n            level: 0,\n            use_color: ShouldColorize::from_env().should_colorize(),\n        }\n    }\n\n    /// Set the indentation style\n    ///\n    /// The provided string will be repeated by the number of indents\n    /// for any indented lines in the output\n    pub fn with_indent(mut self, indent: \u0026str) -\u003e Self {\n        self.indent = indent.to_string();\n        self\n    }\n\n    /// Print the indentation for the current level\n    pub fn print_indent(\u0026mut self) -\u003e fmt::Result {\n        for _ in 0..self.level {\n            self.buf.write_str(self.indent.as_str())?;\n        }\n\n        Ok(())\n    }\n\n    /// Create an printer for a nested abstract syntax tree structure.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - the display name of the AST node\n    /// * `span` - the text span of the node's origin in the input\n    /// * `color` - the color to print the node's name in\n    pub fn print_ast\u003c'b\u003e(\n        \u0026'b mut self,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e AstPrinter\u003c'b, 'a\u003e {\n        AstPrinter::new(self, name, span, color)\n    }\n\n    /// Create a printer for a token stream.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - the display name of the token\n    /// * `span` - the text span of the token's origin in the input\n    /// * `stack` - the state stack information when the token was produced\n    /// * `color` - the color to print the token's name in\n    pub fn print_token\u003c'b\u003e(\n        \u0026'b mut self,\n        name: \u0026str,\n        span: Option\u003cSpan\u003e,\n        stack: Option\u003cString\u003e,\n        color: Option\u003cColor\u003e,\n    ) -\u003e TokenPrinter\u003c'b, 'a\u003e {\n        TokenPrinter::new(self, name, span, stack, color)\n    }\n\n    /// Pretty-print a structure\n    pub fn print(\u0026mut self, item: \u0026impl Pretty) -\u003e Result {\n        item.print(self)\n    }\n\n    /// Add a span to the output\n    pub fn add_span(\u0026mut self, span: Option\u003cSpan\u003e) {\n        self.spans.push(span);\n    }\n\n    /// Add a line of metadata to the output\n    pub fn add_meta(\u0026mut self, meta: Option\u003cString\u003e) {\n        self.meta.push(meta);\n    }\n}\n\nimpl Write for Writer\u003c'_\u003e {\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e fmt::Result {\n        for line in s.split_inclusive('\\n') {\n            if self.on_newline {\n                self.print_indent()?;\n            }\n\n            self.on_newline = line.ends_with('\\n');\n            self.buf.write_str(line)?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":29},"fn_name":null}],"covered":23,"coverable":27},{"path":["/","home","carson","projects","aglet","aglet-regex","src","error.rs"],"content":"use crate::{parse, tokenize};\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"tokenizer error: {0}\")]\n    TokenizerError(#[from] tokenize::Error),\n\n    #[error(\"parser error: {0}\")]\n    ParserError(#[from] parse::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-regex","src","lib.rs"],"content":"pub mod error;\npub mod parse;\npub mod tokenize;\n\npub use error::Error;\npub use parse::ast::ParseResult;\npub use parse::Parser;\npub use tokenize::{Token, Tokenizer};\n\npub fn tokenize\u003cS: AsRef\u003cstr\u003e\u003e(input: \u0026str) -\u003e Result\u003cVec\u003cToken\u003e, tokenize::Error\u003e {\n    let tr = Tokenizer::new(input);\n    tr.collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n}\n\npub fn parse\u003cS: AsRef\u003cstr\u003e\u003e(input: \u0026str) -\u003e ParseResult {\n    let tr = Tokenizer::new(input);\n    let p = Parser::new(tr);\n    p.parse()\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","ast.rs"],"content":"use std::convert::TryFrom;\nuse std::default::Default;\n\nuse aglet_derive::DefaultWithSpan;\nuse aglet_text::Span;\n\nuse crate::parse::error;\nuse crate::tokenize::{self, TokenKind};\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct ParseResult {\n    pub ast:    Expr,\n    pub errors: Vec\u003cerror::Error\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Expr {\n    pub span: Span,\n    pub kind: ExprKind,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum ExprKind {\n    Alternation(Alternation),\n    Concatenation(Concatenation),\n    Repetition(Repetition),\n    Any,\n    Literal(char),\n    Digit(bool),\n    Whitespace(bool),\n    WordChar(bool),\n    Boundary(Boundary),\n    Group(Group),\n    Class(Class),\n    #[default]\n    Empty,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Alternation {\n    pub span:  Span,\n    pub items: Vec\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Concatenation {\n    pub span:  Span,\n    pub items: Vec\u003cExpr\u003e,\n}\n\n#[derive(Debug)]\npub struct Repetition {\n    pub span: Span,\n    pub kind: RepetitionKind,\n    pub item: Box\u003cExpr\u003e,\n}\n\n#[derive(Debug)]\npub enum RepetitionKind {\n    ZeroOrOne,\n    ZeroOrMore,\n    OneOrMore,\n    Range(Range),\n}\n\nimpl TryFrom\u003cTokenKind\u003e for RepetitionKind {\n    type Error = error::TokenConvertError;\n\n    fn try_from(value: TokenKind) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            TokenKind::Question =\u003e Ok(Self::ZeroOrOne),\n            TokenKind::Star =\u003e Ok(Self::ZeroOrMore),\n            TokenKind::Plus =\u003e Ok(Self::OneOrMore),\n            _ =\u003e Err(error::TokenConvertError::InvalidTokenForRepetition(value)),\n        }\n    }\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Range {\n    pub span:  Span,\n    pub start: Option\u003cusize\u003e,\n    pub end:   Option\u003cusize\u003e,\n}\n\n#[derive(Debug)]\npub struct Boundary {\n    pub span: Span,\n    pub kind: BoundaryKind,\n}\n\n#[derive(Debug)]\npub enum BoundaryKind {\n    StartOfLine,\n    EndOfLine,\n    StartOfText,\n    EndOfText,\n    WordBoundary,\n    NonWordBoundary,\n}\n\nimpl TryFrom\u003cTokenKind\u003e for BoundaryKind {\n    type Error = error::TokenConvertError;\n\n    fn try_from(value: TokenKind) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            TokenKind::StartOfLine =\u003e Ok(Self::StartOfLine),\n            TokenKind::EndOfLine =\u003e Ok(Self::EndOfLine),\n            TokenKind::StartOfText =\u003e Ok(Self::StartOfText),\n            TokenKind::EndOfText =\u003e Ok(Self::EndOfText),\n            TokenKind::WordBoundary =\u003e Ok(Self::WordBoundary),\n            TokenKind::NonWordBoundary =\u003e Ok(Self::NonWordBoundary),\n            _ =\u003e Err(error::TokenConvertError::InvalidTokenForBoundary(value)),\n        }\n    }\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Group {\n    pub span: Span,\n    pub kind: GroupKind,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum GroupKind {\n    Capturing(CapturingGroup),\n    Named(NamedGroup),\n    NonCapturing(NonCapturingGroup),\n    Flags(FlagGroup),\n    #[default]\n    Empty,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct CapturingGroup {\n    pub span:  Span,\n    pub index: usize,\n    pub expr:  Box\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct NamedGroup {\n    pub span: Span,\n    pub name: StringSpan,\n    pub expr: Box\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct NonCapturingGroup {\n    pub span:  Span,\n    pub flags: Option\u003cFlags\u003e,\n    pub expr:  Box\u003cExpr\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct FlagGroup {\n    pub flags: Flags,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Flags {\n    pub span:        Span,\n    pub set_flags:   Vec\u003cFlagKind\u003e,\n    pub clear_flags: Vec\u003cFlagKind\u003e,\n}\n\n#[derive(Debug, PartialEq)]\npub enum FlagKind {\n    CaseInsensitive,\n    MultiLine,\n    DotMatchesNewline,\n    CRLFMode,\n    SwapGreed,\n    Unicode,\n    IgnoreWhitespace,\n}\n\nimpl From\u003ctokenize::Flag\u003e for FlagKind {\n    fn from(value: tokenize::Flag) -\u003e Self {\n        match value {\n            tokenize::Flag::CaseInsensitive =\u003e Self::CaseInsensitive,\n            tokenize::Flag::MultiLine =\u003e Self::MultiLine,\n            tokenize::Flag::DotMatchesNewline =\u003e Self::DotMatchesNewline,\n            tokenize::Flag::CRLFMode =\u003e Self::CRLFMode,\n            tokenize::Flag::SwapGreed =\u003e Self::SwapGreed,\n            tokenize::Flag::Unicode =\u003e Self::Unicode,\n            tokenize::Flag::IgnoreWhitespace =\u003e Self::IgnoreWhitespace,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Class {\n    pub span:    Span,\n    pub negated: bool,\n    pub kind:    ClassKind,\n}\n\n#[derive(Debug)]\npub enum ClassKind {\n    Unicode(UnicodeClass),\n    Specified(SpecifiedClass),\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct UnicodeClass {\n    pub span:  Span,\n    pub name:  Option\u003cStringSpan\u003e,\n    pub value: StringSpan,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct SpecifiedClass {\n    pub span:  Span,\n    pub items: Vec\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct ClassSpec {\n    pub span: Span,\n    pub kind: ClassSpecKind,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum ClassSpecKind {\n    Intersection(Intersection),\n    Difference(Difference),\n    Symmetrical(Symmetrical),\n    Literal(char),\n    Digit(bool),\n    Whitespace(bool),\n    WordChar(bool),\n    Range(char, char),\n    Posix(PosixClass),\n    Class(Class),\n    #[default]\n    Empty,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Intersection {\n    pub span:  Span,\n    pub left:  Box\u003cClassSpec\u003e,\n    pub right: Box\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Difference {\n    pub span:  Span,\n    pub left:  Box\u003cClassSpec\u003e,\n    pub right: Box\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct Symmetrical {\n    pub span:  Span,\n    pub left:  Box\u003cClassSpec\u003e,\n    pub right: Box\u003cClassSpec\u003e,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct PosixClass {\n    pub span:    Span,\n    pub kind:    PosixKind,\n    pub negated: bool,\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub enum PosixKind {\n    AlNum,\n    Alpha,\n    Ascii,\n    Blank,\n    Cntrl,\n    Digit,\n    Graph,\n    Lower,\n    Print,\n    Punct,\n    Space,\n    Upper,\n    Word,\n    XDigit,\n    #[default]\n    Unknown,\n}\n\nimpl TryFrom\u003c\u0026str\u003e for PosixKind {\n    type Error = error::TokenConvertError;\n\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            \"alnum\" =\u003e Ok(Self::AlNum),\n            \"alpha\" =\u003e Ok(Self::Alpha),\n            \"ascii\" =\u003e Ok(Self::Ascii),\n            \"blank\" =\u003e Ok(Self::Blank),\n            \"cntrl\" =\u003e Ok(Self::Cntrl),\n            \"digit\" =\u003e Ok(Self::Digit),\n            \"graph\" =\u003e Ok(Self::Graph),\n            \"lower\" =\u003e Ok(Self::Lower),\n            \"print\" =\u003e Ok(Self::Print),\n            \"punct\" =\u003e Ok(Self::Punct),\n            \"space\" =\u003e Ok(Self::Space),\n            \"upper\" =\u003e Ok(Self::Upper),\n            \"word\" =\u003e Ok(Self::Word),\n            \"xdigit\" =\u003e Ok(Self::XDigit),\n            _ =\u003e Err(error::TokenConvertError::InvalidPosixClass(\n                value.to_string(),\n            )),\n        }\n    }\n}\n\n#[derive(Default, DefaultWithSpan, Debug)]\npub struct StringSpan {\n    pub span:  Span,\n    pub value: String,\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":33,"coverable":42},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","error.rs"],"content":"use std::convert::From;\nuse std::{fmt, result};\n\nuse aglet_text::Span;\nuse thiserror::Error;\n\nuse crate::tokenize;\n\npub type Result\u003cT\u003e = result::Result\u003cT, Error\u003e;\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    pub span: Span,\n    pub kind: ErrorKind,\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}) {}\", self.span, self.kind)\n    }\n}\n\nimpl From\u003ctokenize::Error\u003e for Error {\n    fn from(value: tokenize::Error) -\u003e Self {\n        Error {\n            span: value.span,\n            kind: ErrorKind::TokenizeError(value.cause),\n        }\n    }\n}\n\n#[derive(Error, Clone, Debug, Eq, PartialEq)]\npub enum ErrorKind {\n    #[error(\"tokenizer error: {0}\")]\n    TokenizeError(tokenize::ErrorCause),\n\n    #[error(\"unexpected end of input: expected {0}\")]\n    UnexpectedEOF(String),\n\n    #[error(\"unexpected token {0:?}: expected {1}\")]\n    UnexpectedToken(tokenize::TokenKind, String),\n\n    #[error(\"empty character class\")]\n    EmptyClass,\n\n    #[error(\"unexpected token: {0}\")]\n    TokenConvertError(TokenConvertError),\n\n    #[error(\"not implemented\")]\n    NotImplemented,\n}\n\n#[derive(Error, Clone, Debug, Eq, PartialEq)]\npub enum TokenConvertError {\n    #[error(\"invalid token for boundary: {0:?}\")]\n    InvalidTokenForBoundary(tokenize::TokenKind),\n\n    #[error(\"invalid token for repetition: {0:?}\")]\n    InvalidTokenForRepetition(tokenize::TokenKind),\n\n    #[error(\"invalid posix class: {0}\")]\n    InvalidPosixClass(String),\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","input.rs"],"content":"use std::iter::Peekable;\n\nuse aglet_text::Span;\n\nuse crate::parse::error::*;\nuse crate::tokenize::{self, Token, TokenKind};\n\npub(crate) struct Input\u003c'a\u003e {\n    data:   Peekable\u003cBox\u003cdyn Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e + 'a\u003e\u003e,\n    span:   Span,\n    errors: Vec\u003cError\u003e,\n}\n\nimpl\u003c'a\u003e Input\u003c'a\u003e {\n    pub fn new\u003cT\u003e(data: T) -\u003e Self\n    where\n        T: Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e + 'a,\n    {\n        let data = Box::new(data) as Box\u003cdyn Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e\u003e;\n        Self {\n            data:   data.peekable(),\n            span:   Span::new(0, 0),\n            errors: Vec::new(),\n        }\n    }\n\n    pub fn position(\u0026self) -\u003e usize {\n        self.span.end\n    }\n\n    pub fn peek_kind(\u0026mut self) -\u003e Option\u003cResult\u003c\u0026TokenKind\u003e\u003e {\n        self.skip_errors();\n\n        match self.data.peek() {\n            None =\u003e None,\n            Some(Ok(tok)) =\u003e Some(Ok(\u0026tok.kind)),\n            Some(Err(err)) =\u003e Some(Err(Error::from(err.clone()))),\n        }\n    }\n\n    #[inline]\n    pub fn has_where\u003cF\u003e(\u0026mut self, f: F) -\u003e Result\u003cbool\u003e\n    where\n        F: Fn(\u0026TokenKind) -\u003e bool,\n    {\n        match self.peek_kind() {\n            None =\u003e Ok(false),\n            Some(Err(err)) =\u003e Err(err),\n            Some(Ok(kind)) =\u003e Ok(f(kind)),\n        }\n    }\n\n    pub fn next(\u0026mut self) -\u003e Option\u003cResult\u003cToken\u003e\u003e {\n        self.skip_errors();\n\n        let item = self.data.next().map(|res| res.map_err(Error::from));\n\n        if let Some(Ok(tok)) = \u0026item {\n            self.span = tok.span;\n        }\n\n        item\n    }\n\n    #[inline]\n    pub fn match_where\u003cF\u003e(\u0026mut self, f: F) -\u003e Result\u003cOption\u003cToken\u003e\u003e\n    where\n        F: Fn(\u0026TokenKind) -\u003e bool,\n    {\n        if self.has_where(f)? {\n            Ok(Some(\n                self.next()\n                    .expect(\"next token matches previous peek\")\n                    .expect(\"next token matches previous peek\"),\n            ))\n        } else {\n            Ok(None)\n        }\n    }\n\n    #[inline]\n    pub fn error(\u0026self, kind: ErrorKind) -\u003e Error {\n        Error {\n            span: self.span,\n            kind,\n        }\n    }\n\n    #[inline]\n    pub fn errors(\u0026self) -\u003e \u0026[Error] {\n        \u0026self.errors\n    }\n\n    fn skip_errors(\u0026mut self) {\n        loop {\n            match self.data.peek() {\n                Some(Err(err)) if !err.is_fatal() =\u003e self.errors.push(err.clone().into()),\n                _ =\u003e return,\n            }\n\n            self.data.next();\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":757},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":757},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":757},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":115},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":642},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":737},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":737},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":629},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":763},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":761},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":624},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":624},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":442},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":34,"coverable":41},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","mod.rs"],"content":"pub mod ast;\npub mod error;\nmod input;\npub mod parser;\nmod pretty;\n\n#[cfg(test)]\nuse aglet_text::Span;\npub use error::{Error, ErrorKind};\npub use parser::Parser;\n\n#[cfg(test)]\nuse crate::tokenize::{self, Token, TokenKind};\n\n#[cfg(test)]\npub(crate) fn token_iter(tokens: Vec\u003cTokenKind\u003e) -\u003e impl Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e {\n    tokens.into_iter().map(|kind| {\n        Ok(Token {\n            span: Span::new(0, 0),\n            kind,\n        })\n    })\n}\n\n#[cfg(test)]\npub(crate) fn span_token_iter(\n    span_start: usize,\n    tokens: Vec\u003c(usize, TokenKind)\u003e,\n) -\u003e impl Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e {\n    tokens\n        .into_iter()\n        .scan(span_start, |span_start, (span_len, kind)| {\n            let start = *span_start;\n            *span_start += span_len;\n            Some((start, span_len, kind))\n        })\n        .map(|(span_start, span_len, kind)| {\n            let tok = Token {\n                span: Span::new(span_start, span_start + span_len),\n                kind,\n            };\n\n            Ok(tok)\n        })\n}\n\n#[cfg(test)]\nmacro_rules! assert_kind {\n    ($expr:expr, $kind:pat) =\u003e {\n        if !matches!($expr.kind, $kind) {\n            panic!(\"{:?} does not match {}\", $expr.kind, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_err {\n    ($res:expr, $kind:pat) =\u003e {\n        if !matches!($res, Err(Error { kind: $kind, .. })) {\n            panic!(\"{:?} does not match error {}\", $res, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\npub(crate) use assert_err;\n#[cfg(test)]\npub(crate) use assert_kind;\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":281},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":253},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":11},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","parser.rs"],"content":"use std::convert::TryFrom;\n\nuse aglet_text::Span;\n\nuse crate::parse::ast::*;\nuse crate::parse::error::*;\nuse crate::parse::input::Input;\nuse crate::tokenize::token::tok;\nuse crate::tokenize::{self, Token, TokenKind};\n\n/// Parse regular expressions from a [token stream](tokenize::Tokenizer)\n///\n/// Uses a recursive-descent approach to parse a regular expression, with a grammar free\n/// of left-recursion.\n///\n/// # Grammar:\n///\n/// ```grammar\n/// expr -\u003e\n///     | alternation\n///     | \\e\n/// alternation -\u003e\n///     | concatenation ('|' alternation)?\n/// concatenation -\u003e\n///     | repetition concatenation?\n/// repetition -\u003e\n///     | item repetition-spec?\n/// repetition_spec -\u003e\n///     | repetition_range\n///     | QUESTION\n///     | STAR\n///     | PLUS\n/// repetition_range -\u003e\n///     | '{' repetition_range_contents '}'\n/// repetition_range_contents -\u003e\n///     | NUMBER? (',' NUMBER?)?\n/// item -\u003e\n///     | DOT\n///     | LITERAL\n///     | DIGIT_CLASS\n///     | WHITESPACE_CLASS\n///     | WORD_CLASS\n///     | BOUNDARY\n///     | group\n///     | class\n/// group -\u003e\n///     | '(' group_contents ')'\n/// group_contents -\u003e\n///     | '?' flags? ':' expr\n///     | '?' flags\n///     | '?' 'P'? '\u003c' NAME '\u003e' expr\n///     | expr\n/// class -\u003e\n///     | unicode_class\n///     | '[' specified_class ']'\n/// unicode_class -\u003e\n///     | unicode_escape CHAR\n///     | unicode_escape '{' NAME '}'\n///     | unicode_escape '{' NAME '!'? '=' NAME '}'\n/// unicode_escape -\u003e\n///     | '\\p'\n///     | '\\P'\n/// specified_class -\u003e\n///     | NEGATED? spec_item+\n/// spec_item -\u003e\n///     | spec_term spec_set?\n/// spec_term -\u003e\n///     | LITERAL ('-' LITERAL)?\n///     | DIGIT_CLASS\n///     | WHITESPACE_CLASS\n///     | WORD_CLASS\n///     | '[' ':' '^'? NAME ':' ']'\n///     | '[' specified_class ']'\n/// spec_set -\u003e\n///     | '~~' spec_term spec_set?\n///     | '--' spec_item spec_set?\n///     | '\u0026\u0026' spec_item spec_set?\n/// ```\npub struct Parser\u003c'a\u003e {\n    input:       Input\u003c'a\u003e,\n    group_index: usize,\n    errors:      Vec\u003cError\u003e,\n}\n\nimpl\u003c'a\u003e Parser\u003c'a\u003e {\n    /// Create a new parser from a token iterator\n    ///\n    /// Since [`Tokenizer`](tokenize::Tokenizer) implements Iterator, a parser can be built\n    /// from it directly\n    pub fn new\u003cT\u003e(input: T) -\u003e Self\n    where\n        T: Iterator\u003cItem = tokenize::Result\u003cToken\u003e\u003e + 'a,\n    {\n        Parser {\n            input:       Input::new(input),\n            group_index: 1,\n            errors:      Vec::new(),\n        }\n    }\n\n    /// Parse the regular expression into a [syntax tree](Ast)\n    pub fn parse(mut self) -\u003e ParseResult {\n        let res = self.parse_expr();\n        let ast = self.ok_or_default(res);\n\n        let mut errors = self.errors;\n        errors.extend_from_slice(self.input.errors());\n\n        ParseResult { ast, errors }\n    }\n\n    /// Parse an expression, starting with alternations as the weakest binding operation\n    ///\n    /// An alternation is a list of expressions separated by `|` symbols, where the\n    /// regular expression must match one of the alternatives.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// expr -\u003e\n    ///     | alternation\n    ///     | \\e\n    /// alternation -\u003e\n    ///     | concatenation ('|' alternation)?\n    /// ```\n    pub fn parse_expr(\u0026mut self) -\u003e Result\u003cExpr\u003e {\n        let mut items = Vec::new();\n\n        // don't recursively match concatenation and then alternation as in the grammar,\n        // rather just use a loop to match a series of concatenations\n        loop {\n            // parse an alternate\n            let item = match self.parse_concatenation()? {\n                Some(item) =\u003e item,\n\n                // If there is nothing in the alternate (e.g., `/abc|/`) then an empty\n                // expression is allowed\n                None =\u003e Expr {\n                    span: Span::new(self.input.position(), self.input.position()),\n                    kind: ExprKind::Empty,\n                },\n            };\n\n            // there will always be at least one item, since even an empty token stream will\n            // first match an `ExprKind::Empty`\n            items.push(item);\n\n            // continue matching expressions as alternates as long as there are more\n            // `|` symbols separating them\n            if !self.input.has_where(TokenKind::is_alternate)? {\n                break;\n            }\n\n            self.input.next();\n        }\n\n        if items.len() \u003e 1 {\n            // The alternation expression type only makes sense if there is more than one\n            // alternate\n            let span = Span::wrap(\u0026items[0].span, \u0026items[items.len() - 1].span);\n            let kind = ExprKind::Alternation(Alternation { span, items });\n\n            Ok(Expr { span, kind })\n        } else {\n            // If there is only one alternate, don't bother wrapping it in an `Alternation`\n            // and just use the underlying expression instead. There is always at least one\n            // item so it's safe to unwrap\n            Ok(items.pop().unwrap())\n        }\n    }\n\n    /// Parse a concatenation, using repetition as the next weakest binding operation\n    ///\n    /// A concatenation is a series of sub-expressions directly next to each other with\n    /// no conjoining symbol, where the regular expression will match them one after the other.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// concatenation -\u003e\n    ///     | repetition concatenation?\n    /// ```\n    pub fn parse_concatenation(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let mut items = Vec::new();\n\n        // don't recursively match repetitions and concatenations, rather just use a loop\n        // to match a series of repetitions, accomplishing the same thing\n        while let Some(item) = self.parse_repetition()? {\n            items.push(item);\n        }\n\n        // A concatenation only makes sense so long as there's more than one element\n        // to concatenate, otherwise the sub-expression type should pass through\n        if items.len() \u003e 1 {\n            let span = Span::wrap(\u0026items[0].span, \u0026items[items.len() - 1].span);\n            Ok(Some(Expr {\n                span,\n                kind: ExprKind::Concatenation(Concatenation { span, items }),\n            }))\n        } else {\n            // If there's less than two items, return the subexpression instead of a new\n            // concatenation (or None if no items were matched)\n            Ok(items.pop())\n        }\n    }\n\n    /// Parse a repetition of items\n    ///\n    /// Repetition specifies the number of times an item should be matched:\n    ///\n    /// * exactly one time (default),\n    /// * zero or one times,\n    /// * zero or more times,\n    /// * one or more times,\n    /// * exactly `n` times,\n    /// * `n` or more times,\n    /// * up to `n` times,\n    /// * between `n` and `m` times\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// repetition -\u003e\n    ///     | item repetition-spec?\n    /// repetition_spec -\u003e\n    ///     | repetition_range\n    ///     | QUESTION\n    ///     | STAR\n    ///     | PLUS\n    /// repetition_range -\u003e\n    ///     | '{' repetition_range_contents '}'\n    /// repetition_range_contents -\u003e\n    ///     | NUMBER? (',' NUMBER?)?\n    /// ```\n    pub fn parse_repetition(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        // match the item to be repeated\n        let Some(item) = self.parse_item()? else {\n            return Ok(None);\n        };\n\n        // the default quantity (exactly once) doesn't require any text to be matched,\n        // so matching a repetition specifier is optional. When not present, the sub-item\n        // will pass through instead of a repetition expr\n        if let Some(kind) = self.parse_repetition_spec()? {\n            let span = Span::new(item.span.start, self.input.position());\n            let repetition = Repetition {\n                span,\n                kind,\n                item: Box::new(item),\n            };\n\n            // a repetition specifier is present, so encode it in a repetition expression\n            Ok(Some(Expr {\n                span,\n                kind: ExprKind::Repetition(repetition),\n            }))\n        } else {\n            // no repetition specifier was present, so pass through the matched item\n            Ok(Some(item))\n        }\n    }\n\n    /// Parse a repetition specifier\n    ///\n    /// The specifier is the optional part of a repetition expression, so the parser generates\n    /// a [`RepetitionKind`] rather than an [`Expr`].\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// repetition_spec -\u003e\n    ///     | repetition_range\n    ///     | QUESTION\n    ///     | STAR\n    ///     | PLUS\n    /// repetition_range -\u003e\n    ///     | '{' repetition_range_contents '}'\n    /// repetition_range_contents -\u003e\n    ///     | NUMBER? (',' NUMBER?)?\n    /// ```\n    pub fn parse_repetition_spec(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        self.parse_alts(vec![\n            Self::parse_question,\n            Self::parse_star,\n            Self::parse_plus,\n            Self::parse_repetition_range,\n        ])\n    }\n\n    /// Parse the zero-or-one quantity specifier (`?`)\n    pub fn parse_question(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        if self.input.has_where(TokenKind::is_question)? {\n            self.input.next();\n            Ok(Some(RepetitionKind::ZeroOrOne))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse the zero-or-more quantity specifier (`*`)\n    pub fn parse_star(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        if self.input.has_where(TokenKind::is_star)? {\n            self.input.next();\n            Ok(Some(RepetitionKind::ZeroOrMore))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse the one-or-more quantity specifier (`+`)\n    pub fn parse_plus(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        if self.input.has_where(TokenKind::is_plus)? {\n            self.input.next();\n            Ok(Some(RepetitionKind::OneOrMore))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse a specified range for a repetition\n    ///\n    /// A repetition range specifies a custom quantity for an item not expressible by\n    /// the `?`, `*`, and `+` specifiers:\n    ///\n    /// * `n` to `m`: `{n,m}`\n    /// * up to `n`: `{,n}` or `{0,n}`\n    /// * `n` or more: `{n,}`\n    /// * exactly `n`: `{n}`\n    ///\n    /// The can also be used in place of the `?`, `*`, and `+` specifiers:\n    ///\n    /// * zero or one: `{0,1}`\n    /// * zero or more: `{0,}`\n    /// * one or more: `{1,}`\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// repetition_range -\u003e\n    ///     | '{' repetition_range_contents '}'\n    /// repetition_range_contents -\u003e\n    ///     | NUMBER? (',' NUMBER?)?\n    /// ```\n    pub fn parse_repetition_range(\u0026mut self) -\u003e Result\u003cOption\u003cRepetitionKind\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_brace)? else {\n            return Ok(None);\n        };\n\n        // both numbers are optional, `{,}` is equivalent to `{0,}` and `*`\n        let mut start: Option\u003cusize\u003e = None;\n        let mut end: Option\u003cusize\u003e = None;\n\n        // first number\n        if let Some(tok) = self.input.match_where(TokenKind::is_number)? {\n            tok!(TokenKind::Number(number) = tok);\n            start = Some(number);\n        }\n\n        // the second number is only allowed if a comma is present\n        if self.input.match_where(TokenKind::is_comma)?.is_some() {\n            if let Some(tok) = self.input.match_where(TokenKind::is_number)? {\n                tok!(TokenKind::Number(number) = tok);\n                end = Some(number);\n            }\n        }\n\n        let close_tok = self.expect_match(\"end of range `}`\", TokenKind::is_close_brace)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n        Ok(Some(RepetitionKind::Range(Range { span, start, end })))\n    }\n\n    /// Parse an item to be matched by the regular expression\n    ///\n    /// Items are the basic units of the regular expression and represent actual text to\n    /// be matched. The simplest items (`DOT`, `LITERAL`) match a single character (unless\n    /// accompanied by a repetition specifier), and a `BOUNDARY` matches a zero-width location\n    /// in the input (e.g. the beginning of a word). The non-terminal `class` item also\n    /// matches a single character, but is constructed from a more complicated specification.\n    ///\n    /// A `group` item is a sub-expression that may match anything. It is matched at this\n    /// level because it can be a component of an alternation, concatenation, or repetition.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// item -\u003e\n    ///     | DOT\n    ///     | LITERAL\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | BOUNDARY\n    ///     | group\n    ///     | class\n    /// ```\n    pub fn parse_item(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let item = self.parse_alts(vec![\n            Self::parse_dot,\n            Self::parse_literal,\n            Self::parse_digit_class,\n            Self::parse_whitespace_class,\n            Self::parse_word_class,\n            Self::parse_boundary,\n            Self::parse_group,\n            Self::parse_class,\n        ])?;\n\n        // Valid tokens to follow an item come from those productions that can consume an item,\n        // in particular groups and alternation\n        if item.is_none() {\n            match self.input.peek_kind() {\n                Some(Ok(TokenKind::CloseGroup | TokenKind::Alternate)) =\u003e Ok(None),\n                Some(Ok(_)) =\u003e Err(self.illegal_tok(\"`.`, `[`, `(`, boundary, class, or literal\")),\n                _ =\u003e Ok(None),\n            }\n        } else {\n            Ok(item)\n        }\n    }\n\n    /// Parse the \"any\" item (`.`)\n    pub fn parse_dot(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_dot)? else {\n            return Ok(None);\n        };\n\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Any,\n        }))\n    }\n\n    /// Parse a literal item (a single character)\n    pub fn parse_literal(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_literal)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Literal(c) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Literal(c),\n        }))\n    }\n\n    /// Parse a digit short class, `\\d` or `\\D`\n    pub fn parse_digit_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_digit)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Digit(negated) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Digit(negated),\n        }))\n    }\n\n    /// Parse a whitespace short class, `\\s` or `\\S`\n    pub fn parse_whitespace_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_whitespace)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Whitespace(negated) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Whitespace(negated),\n        }))\n    }\n\n    /// Parse a word character short class, `\\w` or `\\W`\n    pub fn parse_word_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_word_char)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::WordChar(negated) = tok);\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::WordChar(negated),\n        }))\n    }\n\n    /// Parse a boundary item\n    ///\n    /// Boundaries have already been condensed into single tokens by the tokenizer,\n    /// but may be a single character (e.g. `$` or `^`) or several (`\\b`)\n    pub fn parse_boundary(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_boundary)? else {\n            return Ok(None);\n        };\n\n        let kind = match BoundaryKind::try_from(tok.kind) {\n            Ok(kind) =\u003e Ok(kind),\n            Err(err) =\u003e Err(self.input.error(ErrorKind::TokenConvertError(err))),\n        }?;\n\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Boundary(Boundary {\n                span: tok.span,\n                kind,\n            }),\n        }))\n    }\n\n    /// Parse a group item\n    ///\n    /// A group is usually a sub-expression that contains another entire regex. It is surrounded\n    /// by parentheses and can begin with some options that change its behaviour.\n    ///\n    /// Groups can be capturing (the text matched by the sub-expression can be retrieved\n    /// on its own), named, non-capturing, and contain flags which alter the behaviour of the\n    /// engine. For example, the case-insensitive flag will make matches within the group\n    /// case-insensitive.\n    ///\n    /// The `FLAGS` group does not contain a sub-expression, but applies the effect of the\n    /// specified flags to the current expression.\n    ///\n    /// The ignore-whitespace ('x') flag was already processed by the tokenizer and has no\n    /// effect from this stage.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// group -\u003e\n    ///     | '(' group_contents ')'\n    /// group_contents -\u003e\n    ///     | NON_CAPTURING expr\n    ///     | NON_CAPTURING_FLAGS expr\n    ///     | GROUP_NAME expr\n    ///     | FLAGS\n    /// ```\n    pub fn parse_group(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_group)? else {\n            return Ok(None);\n        };\n\n        // use a sub-parse to match the group's type and its contents, if applicable\n        let kind = self.parse_group_contents()?;\n\n        let close_tok = self.expect_match(\"end of group `)`\", TokenKind::is_close_group)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n\n        Ok(Some(Expr {\n            span,\n            kind: ExprKind::Group(Group { span, kind }),\n        }))\n    }\n\n    /// Parse the type and contents of a group\n    ///\n    /// Because the [`parse_group`][1] parser is responsible for the open and close braces\n    /// surrounding the group and therefore its span, this parser returns only the group\n    /// kind (which contains the subexpression, if applicable).\n    ///\n    /// This parser cannot return `None`, as an empty group that expects an expression\n    /// will be populated with an [`ExprKind::Empty`]\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// group_contents -\u003e\n    ///     | '?' flags? ':' expr\n    ///     | '?' flags\n    ///     | '?' 'P'? '\u003c' GROUP_NAME '\u003e' expr\n    ///     | expr\n    /// ```\n    ///\n    /// [1]: Parser::parse_group\n    pub fn parse_group_contents(\u0026mut self) -\u003e Result\u003cGroupKind\u003e {\n        let res = self\n            .parse_alts(vec![\n                Self::parse_group_with_header,\n                Self::parse_capturing_group,\n            ])?\n            // one of the group contents parsers must always produce a match\n            .expect(\"group contents should not be None\");\n\n        Ok(res)\n    }\n\n    /// Parse a group with an options header\n    ///\n    /// An options header begins with `?` and is used to specify a name or set of flags for the\n    /// group.\n    ///\n    /// Named groups are capturing groups, but instead of being identified by a\n    /// number, are also identified with a string. They begin with `?P\u003cname\u003e` or `?\u003cname\u003e`, where\n    /// `name` is the name of the sub-expression.\n    ///\n    /// A non-capturing group is not represented by a name or index; it optionally matches some\n    /// text and optionally specifies some flags. The flags set or cleared in a non-capturing\n    /// group only apply within that group.\n    ///\n    /// A flags group only specifies some flags and matches no text; flags set or cleared in a\n    /// flags group apply to their enclosing expression.\n    ///\n    /// Available flags are:\n    ///\n    /// * `i`: case-insensitive\n    /// * `m`: multi-line\n    /// * `s`: `.` matches newlines\n    /// * `R`: use `\\r\\n` when multiline mode is enabled\n    /// * `U`: swaps the meaning of `.*` and `.*?`\n    /// * `u`: enable unicode support (default)\n    /// * `x`: ignore whitespace and allow comments\n    ///\n    /// Flags are set or cleared like so:\n    ///\n    /// `ix-um`\n    ///\n    /// * Set the case-insensitive flag `i`\n    /// * Set the ignore-whitespace flag `x`\n    /// * Clear the unicode support flag `u`\n    /// * Clear the multi-line flag `m`\n    ///\n    /// ```grammar\n    /// group_contents -\u003e\n    ///     | '?' flags? ':' expr\n    ///     | '?' flags\n    ///     | '?' 'P'? '\u003c' NAME '\u003e' expr\n    /// ```\n    pub fn parse_group_with_header(\u0026mut self) -\u003e Result\u003cOption\u003cGroupKind\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_group_options)? else {\n            return Ok(None);\n        };\n\n        let group_kind = if self\n            .input\n            .match_where(TokenKind::is_open_group_name)?\n            .is_some()\n        {\n            let name_tok = self.expect_match(\"group name\", TokenKind::is_name)?;\n            tok!(TokenKind::Name(name) = name_tok);\n\n            self.expect_match(\"end of group name `\u003e`\", TokenKind::is_close_group_name)?;\n\n            let expr = self.parse_expr()?;\n            let name = StringSpan {\n                span:  name_tok.span,\n                value: name,\n            };\n\n            GroupKind::Named(NamedGroup {\n                name,\n                span: Span::wrap(\u0026open_tok.span, \u0026expr.span),\n                expr: Box::new(expr),\n            })\n        } else {\n            let flags = self.parse_flags()?;\n            if self\n                .input\n                .match_where(TokenKind::is_close_group_options)?\n                .is_some()\n            {\n                let expr = self.parse_expr()?;\n\n                GroupKind::NonCapturing(NonCapturingGroup {\n                    span: expr.span,\n                    expr: Box::new(expr),\n                    flags,\n                })\n            } else {\n                let flags = flags.unwrap_or_else(|| Flags {\n                    span:        Span::new(open_tok.span.end, open_tok.span.end),\n                    set_flags:   Vec::new(),\n                    clear_flags: Vec::new(),\n                });\n\n                GroupKind::Flags(FlagGroup { flags })\n            }\n        };\n\n        Ok(Some(group_kind))\n    }\n\n    pub fn parse_flags(\u0026mut self) -\u003e Result\u003cOption\u003cFlags\u003e\u003e {\n        let mut span = None;\n        let mut set_flags = vec![];\n        let mut clear_flags = vec![];\n        let mut clearing = false;\n\n        while let Some(tok) = self.input.match_where(TokenKind::is_flag_or_delimiter)? {\n            if let Some(s) = span {\n                span = Some(Span::wrap(\u0026s, \u0026tok.span));\n            } else {\n                span = Some(tok.span);\n            }\n\n            if tok.kind.is_flag() {\n                tok!(TokenKind::Flag(f) = tok);\n\n                if clearing {\n                    clear_flags.push(f.into())\n                } else {\n                    set_flags.push(f.into())\n                }\n            } else if tok.kind.is_flag_delimiter() {\n                if clearing {\n                    return Err(self.input.error(ErrorKind::UnexpectedToken(\n                        TokenKind::FlagDelimiter,\n                        \"end of flags `:` or `)`\".to_string(),\n                    )));\n                }\n\n                clearing = true;\n            }\n        }\n\n        if let Some(span) = span {\n            Ok(Some(Flags {\n                span,\n                set_flags,\n                clear_flags,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Parse a capturing group\n    ///\n    /// The matched contents of a capturing group can be referenced after the match. Named groups\n    /// are reference by a string name, whereas basic capturing groups are identified by a\n    /// sequenced number. The first capturing group is referenced by the number `1`. The number\n    /// `0` references the entire match.\n    ///\n    /// Capturing groups are not prefixed with any tokens\n    pub fn parse_capturing_group(\u0026mut self) -\u003e Result\u003cOption\u003cGroupKind\u003e\u003e {\n        // The only part of a capturing group (besides the parentheses) is the sub-expression\n        let expr = self.parse_expr()?;\n\n        // assign an incrementing index to the group\n        let index = self.group_index;\n        self.group_index += 1;\n\n        Ok(Some(GroupKind::Capturing(CapturingGroup {\n            span: expr.span,\n            index,\n            expr: Box::new(expr),\n        })))\n    }\n\n    /// Parse a character class\n    ///\n    /// Character classes match a single character from the input. The can be specified either\n    /// as a unicode class (any character belonging to a certain unicode category, or having\n    /// some other property) or as a specified class, where they can be matched with ranges and\n    /// sets of characters, or by POSIX class.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// class -\u003e\n    ///     | unicode_class\n    ///     | '[' specified_class ']'\n    /// unicode_class -\u003e\n    ///     | unicode_escape CHAR\n    ///     | unicode_escape '{' UNICODE_PROP_VALUE '}'\n    ///     | unicode_escape '{' UNICODE_PROP_NAME '=' UNICODE_PROP_VALUE '}'\n    ///     | unicode_escape '{' UNICODE_PROP_NAME '!=' UNICODE_PROP_VALUE '}'\n    /// unicode_escape -\u003e\n    ///     | '\\p'\n    ///     | '\\P'\n    /// specified_class -\u003e\n    ///     | NEGATED? spec_item+\n    /// spec_item -\u003e\n    ///     | spec_term spec_set?\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' POSIX_NAME ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    ///     | \\e\n    /// ```\n    pub fn parse_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        self.parse_alts(vec![Self::parse_specified_class, Self::parse_unicode_class])\n    }\n\n    /// Parse a unicode character class\n    ///\n    /// Unicode classes match a character with a specified property value, such as the general\n    /// category, script, script extension, block, etc.\n    ///\n    /// The short unicode class `\\pL` uses the single-character variant of the general category,\n    /// e.g. `L` for `Letter`. The longer version, `\\p{Ll}` can use a longer specification,\n    /// e.g. `Ll` for lowercase letters, `Letter` for letters, etc.\n    ///\n    /// Matching for a property other than general category uses the syntax `\\p{scx=Greek}`,\n    /// which matches a character in the greek script extension.\n    ///\n    /// The match can be negated using `\\P` instead of `\\p`, or in the property name syntax,\n    /// using `\\p{Script_Extension!=Greek}`. Double negations are treated as positive, i.e.\n    /// `\\P{sc!=Greek}` is equivalent to `\\p{sc=Greek}`.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// unicode_class -\u003e\n    ///     | UNICODE_SHORT\n    ///     | UNICODE_LONG '{' UNICODE_PROP_VALUE '}'\n    ///     | UNICODE_LONG '{' UNICODE_PROP_NAME '=' UNICODE_PROP_VALUE '}'\n    ///     | UNICODE_LONG '{' UNICODE_PROP_NAME '!=' UNICODE_PROP_VALUE '}'\n    /// ```\n    pub fn parse_unicode_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        self.parse_alts(vec![\n            Self::parse_unicode_short_class,\n            Self::parse_unicode_long_class,\n        ])\n    }\n\n    /// Parse a short-form unicode character class\n    ///\n    /// Unicode classes of the form `\\pL` are condensed into a single token by the tokenizer.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// unicode_class -\u003e\n    ///     | UNICODE_SHORT\n    /// ```\n    pub fn parse_unicode_short_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_unicode_short)? else {\n            return Ok(None);\n        };\n\n        // create a unicode class for the general category specified by the token\n        tok!(TokenKind::UnicodeShort(category, negated) = tok);\n        let unicode_class = UnicodeClass {\n            span:  tok.span,\n            name:  None,\n            value: StringSpan {\n                span:  tok.span,\n                value: format!(\"{}\", category),\n            },\n        };\n\n        // construct the class expression with the negation value from the token\n        Ok(Some(Expr {\n            span: tok.span,\n            kind: ExprKind::Class(Class {\n                span: tok.span,\n                negated,\n                kind: ClassKind::Unicode(unicode_class),\n            }),\n        }))\n    }\n\n    /// Parse a long-form unicode character class\n    ///\n    /// Unicode classes of the form `\\p{Property=Value}` are broken into start and end\n    /// tokens, name, value, and equality tokens, with name and equality tokens being optional.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// unicode_class -\u003e\n    ///     | UNICODE_LONG '{' NAME '}'\n    ///     | UNICODE_LONG '{' NAME '!'? '=' NAME '}'\n    /// ```\n    pub fn parse_unicode_long_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_unicode_long)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::UnicodeLong(open_negated) = open_tok);\n\n        self.expect_match(\"start of unicode property `{`\", TokenKind::is_open_brace)?;\n\n        // The first name is either the property name or value, depending on whether this is\n        // the `\\p{Value}` or `\\p{Prop=Value}` form\n        let first_name_tok = self.expect_match(\"name\", TokenKind::is_name)?;\n        tok!(TokenKind::Name(n) = first_name_tok);\n        let first_name = StringSpan {\n            span:  first_name_tok.span,\n            value: n,\n        };\n\n        let mut second_name = None;\n\n        // optionally match `=` or `!=`\n        let eq_negated = self.input.match_where(TokenKind::is_bang)?.is_some();\n        let has_eq = self.input.match_where(TokenKind::is_equal)?.is_some();\n\n        // TODO: detect a ! with no corresponding =\n\n        if has_eq {\n            let second_name_tok = self.expect_match(\"property value\", TokenKind::is_name)?;\n\n            tok!(TokenKind::Name(v) = second_name_tok);\n            second_name = Some(StringSpan {\n                span:  second_name_tok.span,\n                value: v,\n            });\n        }\n\n        let close_tok = self.expect_match(\n            \"unicode property closing brace `}`\",\n            TokenKind::is_close_brace,\n        )?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n        let kind = match second_name {\n            Some(second_name) =\u003e ClassKind::Unicode(UnicodeClass {\n                span,\n                name: Some(first_name),\n                value: second_name,\n            }),\n            None =\u003e ClassKind::Unicode(UnicodeClass {\n                span,\n                name: None,\n                value: first_name,\n            }),\n        };\n\n        let negated = open_negated != eq_negated;\n        let kind = ExprKind::Class(Class {\n            span,\n            negated,\n            kind,\n        });\n\n        Ok(Some(Expr { span, kind }))\n    }\n\n    /// Parse a specified class\n    ///\n    /// A specified class represents a set of characters which can be matched from the input.\n    /// They are specified using a combination of literals, ranges, set operations, sub-classes\n    /// and POSIX classes:\n    ///\n    /// * literals: `[abc]` matches any character `a`, `b`, or `c`\n    /// * ranges: `[a-c]` matches any character `a`, `b`, or `c`\n    /// * set difference: `[[abcdef]--[def]]` matches any character `a`, `b`, or `c`\n    /// * set intersection: `[[abcdef]\u0026\u0026[cdxyz]]` matches any character `c` or `d`\n    /// * symmetrical set difference: `[[abc]~~[bcd]]` matches any character `a` or `d`\n    /// * posix classes: `[[:alnum:]]` matches any alphanumeric character\n    ///\n    /// Classes can be negated using a `^` token at the beginning. POSIX classes can themselves\n    /// be negated using the same token at the beginning of the name:\n    ///\n    /// * `[^abc]` matches any character except `a`, `b`, and `c`\n    /// * `[[:^lower:]]` matches any character except lowercase letters\n    ///\n    /// POSIX classes are unaware of unicode properties, and so only apply to ASCII characters.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// specified_class -\u003e\n    ///     | NEGATED? spec_item+\n    /// spec_item -\u003e\n    ///     | spec_term spec_set?\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' POSIX_NAME ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    /// ```\n    pub fn parse_specified_class(\u0026mut self) -\u003e Result\u003cOption\u003cExpr\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_bracket)? else {\n            return Ok(None);\n        };\n\n        // optionally match a negation token for the class\n        let negated = self.input.match_where(TokenKind::is_negated)?.is_some();\n\n        // match all specification items\n        let mut items = Vec::new();\n        while let Some(item) = self.parse_specified_class_item()? {\n            items.push(item);\n        }\n\n        let close_tok =\n            self.expect_match(\"end of character class `]`\", TokenKind::is_close_bracket)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n        let inner_span_start = items\n            .first()\n            .map(|item| item.span.start)\n            .unwrap_or(open_tok.span.end);\n        let inner_span_end = items\n            .last()\n            .map(|item| item.span.end)\n            .unwrap_or(close_tok.span.start);\n        let inner_span = Span::new(inner_span_start, inner_span_end);\n\n        let kind = ClassKind::Specified(SpecifiedClass {\n            items,\n            span: inner_span,\n        });\n\n        Ok(Some(Expr {\n            span,\n            kind: ExprKind::Class(Class {\n                span,\n                negated,\n                kind,\n            }),\n        }))\n    }\n\n    /// Parse a specified class item\n    ///\n    /// Class items consist of literals, ranges, POSIX classes, subclasses, and set\n    /// operations. See [`parse_specified_class`][1] for more details. To eliminate\n    /// left-recursion from the grammar, subclasses and terminal productions are matched\n    /// first before matching set operations.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_item -\u003e\n    ///     | spec_term spec_set?\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' ':' '^'? NAME ':' ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    /// ```\n    ///\n    /// [1]: Parser::parse_specified_class\n    pub fn parse_specified_class_item(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(term) = self.parse_specified_class_term()? else {\n            return Ok(None);\n        };\n\n        let with_set = self.parse_class_item_set(term)?;\n        Ok(Some(with_set))\n    }\n\n    /// Parse a specified class item, excluding set operations\n    ///\n    /// Any specification item that can be positively identified by a terminal can be\n    /// parsed here, to ensure that the grammar is not left-recursive. Set operations\n    /// can match further items to build a left-associated tree of set operations.\n    ///\n    /// See [parse_specified_class][1] for details on class items\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    ///     | DIGIT_CLASS\n    ///     | WHITESPACE_CLASS\n    ///     | WORD_CLASS\n    ///     | '[' ':' '^'? NAME ':' ']'\n    ///     | '[' specified_class ']'\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_item spec_set?\n    ///     | '\u0026\u0026' spec_item spec_set?\n    /// ```\n    ///\n    /// [1]: Parser::parse_specified_class\n    pub fn parse_specified_class_term(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        self.parse_alts(vec![\n            Self::parse_class_term_literal,\n            Self::parse_class_term_digit,\n            Self::parse_class_term_whitespace,\n            Self::parse_class_term_word,\n            Self::parse_class_term_bracket,\n        ])\n    }\n\n    /// Parse a character class item beginning with a literal\n    ///\n    /// Either a literal or a literal range can be parsed here\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_term -\u003e\n    ///     | LITERAL ('-' LITERAL)?\n    /// ```\n    pub fn parse_class_term_literal(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        // match a literal, which will either be on its own or at the start\n        // of a literal range\n        let Some(start_tok) = self.input.match_where(TokenKind::is_literal)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Literal(c_start) = start_tok);\n\n        // optionally match the second half of a range\n        let spec = if self.input.match_where(TokenKind::is_range)?.is_some() {\n            let end_tok = self.expect_match(\"end of range\", TokenKind::is_literal)?;\n            tok!(TokenKind::Literal(c_end) = end_tok);\n\n            // if a range is matched, a range class specifier will be returned\n            let span = Span::wrap(\u0026start_tok.span, \u0026end_tok.span);\n            let kind = ClassSpecKind::Range(c_start, c_end);\n            ClassSpec { span, kind }\n        } else {\n            // if a range wasn't matched, then the literal class specifier will be\n            // returned on its own\n            let span = start_tok.span;\n            let kind = ClassSpecKind::Literal(c_start);\n            ClassSpec { span, kind }\n        };\n\n        Ok(Some(spec))\n    }\n\n    /// Parse a digit short class, `\\d` or `\\D`\n    pub fn parse_class_term_digit(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_digit)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Digit(negated) = tok);\n        Ok(Some(ClassSpec {\n            span: tok.span,\n            kind: ClassSpecKind::Digit(negated),\n        }))\n    }\n\n    /// Parse a whitespace short class, `\\s` or `\\S`\n    pub fn parse_class_term_whitespace(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_whitespace)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::Whitespace(negated) = tok);\n        Ok(Some(ClassSpec {\n            span: tok.span,\n            kind: ClassSpecKind::Whitespace(negated),\n        }))\n    }\n\n    /// Parse a word char short class, `\\w` or `\\W`\n    pub fn parse_class_term_word(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(tok) = self.input.match_where(TokenKind::is_word_char)? else {\n            return Ok(None);\n        };\n\n        tok!(TokenKind::WordChar(negated) = tok);\n        Ok(Some(ClassSpec {\n            span: tok.span,\n            kind: ClassSpecKind::WordChar(negated),\n        }))\n    }\n\n    /// Parse a specified class item that begins with an opening bracket\n    ///\n    /// This includes parsing a nested class. [`parse_specified_class`][1] can't really be reused\n    /// here because it needs to consume the first bracket - here the bracket is consumed so that\n    /// the beginning of POSIX_NAME can be peeked to disambiguate the two productions; once the\n    /// branch has been determined, control can't be passed to [`parse_specified_class`][1] because\n    /// the bracket was already consumed.\n    ///\n    /// Inverting this dependency and making [`parse_specified_class`][1] assume the bracket was\n    /// already consumed doesn't work that well because that token is needed to compute the\n    /// ast node's span.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_term -\u003e\n    ///     | '[' POSIX_NAME ']'\n    ///     | '[' specified_class ']'\n    /// ```\n    ///\n    /// [1]: Parser::parse_specified_class\n    pub fn parse_class_term_bracket(\u0026mut self) -\u003e Result\u003cOption\u003cClassSpec\u003e\u003e {\n        let Some(open_tok) = self.input.match_where(TokenKind::is_open_bracket)? else {\n            return Ok(None);\n        };\n\n        // attempt to match a POSIX class name\n        let kind = if let Some(open_colon) = self.input.match_where(TokenKind::is_colon)? {\n            let negated = self.input.match_where(TokenKind::is_negated)?.is_some();\n            let name = self.expect_match(\"posix class name\", TokenKind::is_name)?;\n            let close_colon =\n                self.expect_match(\"end of posix class name `:`\", TokenKind::is_colon)?;\n\n            tok!(TokenKind::Name(name) = name);\n\n            // convert the matched name into a POSIX class item\n            let posix_kind = match PosixKind::try_from(name.as_ref()) {\n                Ok(kind) =\u003e Ok(kind),\n                Err(err) =\u003e Err(self.input.error(ErrorKind::TokenConvertError(err))),\n            }?;\n\n            let kind_span = Span::wrap(\u0026open_colon.span, \u0026close_colon.span);\n            ClassSpecKind::Posix(PosixClass {\n                span: kind_span,\n                kind: posix_kind,\n                negated,\n            })\n        } else {\n            // if a POSIX class wasn't matched, then this must be the beginning of a subclass.\n            let negated = self.input.match_where(TokenKind::is_negated)?.is_some();\n\n            // match subclass items\n            let mut items = Vec::new();\n            while let Some(item) = self.parse_specified_class_item()? {\n                items.push(item);\n            }\n\n            let inner_span_start = items\n                .first()\n                .map(|item| item.span.start)\n                .unwrap_or(open_tok.span.end);\n            let inner_span_end = items\n                .last()\n                .map(|item| item.span.end)\n                .unwrap_or(open_tok.span.end);\n            let kind_span = Span::new(inner_span_start, inner_span_end);\n            let class_kind = ClassKind::Specified(SpecifiedClass {\n                span: kind_span,\n                items,\n            });\n\n            // create a subclass class specifier\n            ClassSpecKind::Class(Class {\n                span: kind_span,\n                kind: class_kind,\n                negated,\n            })\n        };\n\n        let close_tok = self.expect_match(\"end of posix class `]`\", TokenKind::is_close_bracket)?;\n\n        let span = Span::wrap(\u0026open_tok.span, \u0026close_tok.span);\n\n        Ok(Some(ClassSpec { span, kind }))\n    }\n\n    /// Parse a set operation in a class specification\n    ///\n    /// Set operations include:\n    ///\n    /// * difference `A--B`: members of set A that are not in set B\n    /// * symmetric difference `A~~B`: members that are not in both A and B\n    /// * intersection: `A\u0026\u0026B`: members that are in both set A and set B\n    ///\n    /// This parser accepts a [`ClassSpec`][1] as the left hand side of the operation,\n    /// and matches the right hand side itself. [`parse_specified_class_item`][2] parses\n    /// the left-hand-side before optionally parsing a `spec_set` in order to eliminate\n    /// left-recursion and create a left-associative structure.\n    ///\n    /// Multiple subsequent set operations can be matched, e.g.\n    /// `[[:ascii:]--[:upper:]--[:lower:]]`\n    ///\n    /// # Arguments\n    ///\n    /// * `start` - the left-hand-side of the operation. The parser takes ownership of it,\n    ///     but if no operator is matched, it will be returned again.\n    ///\n    /// # Grammar\n    ///\n    /// ```grammar\n    /// spec_set -\u003e\n    ///     | '~~' spec_term spec_set?\n    ///     | '--' spec_term spec_set?\n    ///     | '\u0026\u0026' spec_term spec_set?\n    /// ```\n    ///\n    /// [1]: ClassSpec\n    /// [2]: Parser::parse_specified_class_item\n    pub fn parse_class_item_set(\u0026mut self, start: ClassSpec) -\u003e Result\u003cClassSpec\u003e {\n        // match a set operator to begin parsing the class spec. If none is found\n        // then the left hand side will be returned unchanged.\n        let set_kind = if let Some(tok) = self.input.match_where(TokenKind::is_set_operator)? {\n            tok.kind\n        } else {\n            return Ok(start);\n        };\n\n        // parse the right-hand side of the operation\n        let Some(end) = self.parse_specified_class_term()? else {\n            return Err(self.input.error(ErrorKind::UnexpectedToken(\n                set_kind,\n                \"end of set\".to_string(),\n            )));\n        };\n\n        // construct a `ClassSpecKind` depending on which operator was found\n        let span = Span::wrap(\u0026start.span, \u0026end.span);\n        let kind = match set_kind {\n            TokenKind::Symmetrical =\u003e ClassSpecKind::Symmetrical(Symmetrical {\n                span,\n                left: Box::new(start),\n                right: Box::new(end),\n            }),\n            TokenKind::Difference =\u003e ClassSpecKind::Difference(Difference {\n                span,\n                left: Box::new(start),\n                right: Box::new(end),\n            }),\n            TokenKind::Intersection =\u003e ClassSpecKind::Intersection(Intersection {\n                span,\n                left: Box::new(start),\n                right: Box::new(end),\n            }),\n            _ =\u003e unreachable!(),\n        };\n\n        let nested_set = self.parse_class_item_set(ClassSpec { span, kind })?;\n        Ok(nested_set)\n    }\n\n    fn parse_alts\u003cF, R\u003e(\u0026mut self, alts: Vec\u003cF\u003e) -\u003e Result\u003cOption\u003cR\u003e\u003e\n    where\n        F: FnMut(\u0026mut Self) -\u003e Result\u003cOption\u003cR\u003e\u003e,\n    {\n        for mut alt in alts {\n            match alt(self) {\n                Ok(None) =\u003e continue,\n                result =\u003e return result,\n            }\n        }\n\n        Ok(None)\n    }\n\n    fn illegal_tok(\u0026mut self, expect: \u0026str) -\u003e Error {\n        match self.input.next() {\n            Some(Ok(tok)) =\u003e self\n                .input\n                .error(ErrorKind::UnexpectedToken(tok.kind, expect.to_string())),\n            Some(Err(err)) =\u003e err,\n            None =\u003e self\n                .input\n                .error(ErrorKind::UnexpectedEOF(expect.to_string())),\n        }\n    }\n\n    fn expect_match\u003cF\u003e(\u0026mut self, expect: \u0026str, f: F) -\u003e Result\u003cToken\u003e\n    where\n        F: Fn(\u0026TokenKind) -\u003e bool,\n    {\n        match self.input.next() {\n            Some(Ok(tok)) if f(\u0026tok.kind) =\u003e Ok(tok),\n            Some(Ok(tok)) =\u003e Err(self\n                .input\n                .error(ErrorKind::UnexpectedToken(tok.kind, expect.to_string()))),\n            Some(Err(err)) =\u003e Err(err),\n            None =\u003e Err(self\n                .input\n                .error(ErrorKind::UnexpectedEOF(expect.to_string()))),\n        }\n    }\n\n    fn ok_or_default\u003cT: Default\u003e(\u0026mut self, res: Result\u003cT\u003e) -\u003e T {\n        match res {\n            Ok(expr) =\u003e expr,\n            Err(e) =\u003e {\n                self.errors.push(e);\n                Default::default()\n            },\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::fmt::Debug;\n\n    use super::*;\n    use crate::parse::{assert_err, assert_kind, span_token_iter, token_iter};\n    use crate::tokenize::Flag;\n\n    fn unwrap_parse\u003cT\u003e(r: Result\u003cOption\u003cT\u003e\u003e) -\u003e T\n    where\n        T: Debug,\n    {\n        let Ok(Some(thing)) = r else {\n            panic!(\"parse failed: {:?}\", r);\n        };\n\n        thing\n    }\n\n    fn get_alternation(r: Result\u003cExpr\u003e) -\u003e Alternation {\n        let Ok(expr) = r else {\n            panic!(\"parse failed\");\n        };\n        let ExprKind::Alternation(alternation) = expr.kind else {\n            panic!(\"not an alternation\");\n        };\n\n        alternation\n    }\n\n    fn get_concatenation(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Concatenation {\n        let expr = unwrap_parse(r);\n        let ExprKind::Concatenation(concatenation) = expr.kind else {\n            panic!(\"not a concatenation\");\n        };\n\n        concatenation\n    }\n\n    fn get_repetition(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Repetition {\n        let expr = unwrap_parse(r);\n        let ExprKind::Repetition(repetition) = expr.kind else {\n            panic!(\"not a repetition\");\n        };\n\n        repetition\n    }\n\n    fn get_range(r: Result\u003cOption\u003cRepetitionKind\u003e\u003e) -\u003e Range {\n        let kind = unwrap_parse(r);\n        let RepetitionKind::Range(range) = kind else {\n            panic!(\"not a range\");\n        };\n\n        range\n    }\n\n    fn get_boundary(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Boundary {\n        let expr = unwrap_parse(r);\n        let ExprKind::Boundary(boundary) = expr.kind else {\n            panic!(\"expression is not a boundary\");\n        };\n\n        boundary\n    }\n\n    fn get_group(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Group {\n        let expr = unwrap_parse(r);\n        let ExprKind::Group(group) = expr.kind else {\n            panic!(\"expression is not a group\");\n        };\n\n        group\n    }\n\n    fn get_class(r: Result\u003cOption\u003cExpr\u003e\u003e) -\u003e Class {\n        let expr = unwrap_parse(r);\n        let ExprKind::Class(class) = expr.kind else {\n            panic!(\"expression is not a class\");\n        };\n\n        class\n    }\n\n    fn get_class_spec(r: Result\u003cOption\u003cClassSpec\u003e\u003e) -\u003e ClassSpec {\n        let Ok(r) = r else {\n            panic!(\"parse failed\");\n        };\n\n        let Some(spec) = r else {\n            panic!(\"empty parse\");\n        };\n\n        spec\n    }\n\n    fn get_class_items(class: Class) -\u003e Vec\u003cClassSpec\u003e {\n        if let ClassKind::Specified(SpecifiedClass { items, .. }) = class.kind {\n            items\n        } else {\n            panic!(\"not a specified class\");\n        }\n    }\n\n    fn get_unicode_class(class: Class) -\u003e UnicodeClass {\n        let ClassKind::Unicode(class) = class.kind else {\n            panic!(\"class is not unicode class\");\n        };\n\n        class\n    }\n\n    #[test]\n    fn expr() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Alternate,\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::Alternate,\n            TokenKind::OpenGroup,\n            TokenKind::CloseGroup,\n            TokenKind::Alternate,\n        ]));\n\n        let alt = get_alternation(p.parse_expr());\n        assert_eq!(alt.items.len(), 4);\n        assert_kind!(alt.items[0], ExprKind::Literal('a'));\n        assert_kind!(alt.items[1], ExprKind::Concatenation(_));\n        assert_kind!(alt.items[2], ExprKind::Group(_));\n        assert_kind!(alt.items[3], ExprKind::Empty);\n\n        let ExprKind::Concatenation(Concatenation { items, .. }) = \u0026alt.items[1].kind else {\n            panic!(\"not a concatenation\");\n        };\n        assert_eq!(items.len(), 2);\n        assert_kind!(items[0], ExprKind::Literal('b'));\n        assert_kind!(items[1], ExprKind::Literal('c'));\n\n        let ExprKind::Group(Group {\n            kind: GroupKind::Capturing(group),\n            ..\n        }) = \u0026alt.items[2].kind\n        else {\n            panic!(\"not a group\");\n        };\n        assert_kind!(group.expr, ExprKind::Empty);\n    }\n\n    #[test]\n    fn concatenation() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::OpenGroup,\n            TokenKind::Literal('c'),\n            TokenKind::CloseGroup,\n        ]));\n\n        let concat = get_concatenation(p.parse_concatenation());\n        assert_eq!(concat.items.len(), 3);\n        assert_kind!(concat.items[0], ExprKind::Literal('a'));\n        assert_kind!(concat.items[1], ExprKind::Literal('b'));\n        assert_kind!(concat.items[2], ExprKind::Group(_));\n        let ExprKind::Group(Group {\n            kind: GroupKind::Capturing(group),\n            ..\n        }) = \u0026concat.items[2].kind\n        else {\n            panic!(\"not a group\");\n        };\n\n        assert!(matches!(group.expr.kind, ExprKind::Literal('c')));\n    }\n\n    #[test]\n    fn repetition() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Dot,\n            TokenKind::Question,\n            TokenKind::Literal('a'),\n            TokenKind::OpenBrace,\n            TokenKind::Number(2),\n            TokenKind::Comma,\n            TokenKind::Number(3),\n            TokenKind::CloseBrace,\n            TokenKind::Literal('b'),\n        ]));\n\n        let rep = get_repetition(p.parse_repetition());\n        assert!(matches!(rep.kind, RepetitionKind::ZeroOrOne));\n        assert!(matches!(rep.item.kind, ExprKind::Any));\n\n        let rep = get_repetition(p.parse_repetition());\n        assert!(matches!(rep.kind, RepetitionKind::Range(_)));\n        assert!(matches!(rep.item.kind, ExprKind::Literal('a')));\n\n        let expr = unwrap_parse(p.parse_repetition());\n        assert!(matches!(expr.kind, ExprKind::Literal('b')));\n\n        // TODO: detect stray repetition tokens where they don't belong\n    }\n\n    #[test]\n    fn repetition_spec() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Question,\n            TokenKind::Star,\n            TokenKind::Plus,\n            TokenKind::OpenBrace,\n            TokenKind::CloseBrace,\n            TokenKind::Dot,\n        ]));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::ZeroOrOne));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::ZeroOrMore));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::OneOrMore));\n\n        let rep = unwrap_parse(p.parse_repetition_spec());\n        assert!(matches!(rep, RepetitionKind::Range(_)));\n\n        let res = p.parse_repetition_spec();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn repetition_range() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenBrace,\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Comma,\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Number(1),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Number(2),\n            TokenKind::Comma,\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Number(3),\n            TokenKind::Comma,\n            TokenKind::Number(4),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Comma,\n            TokenKind::Number(5),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Literal('a'),\n        ]));\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, None);\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, None);\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, Some(1));\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, Some(2));\n        assert_eq!(range.end, None);\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, Some(3));\n        assert_eq!(range.end, Some(4));\n\n        let range = get_range(p.parse_repetition_range());\n        assert_eq!(range.start, None);\n        assert_eq!(range.end, Some(5));\n\n        let res = p.parse_repetition_range();\n        assert!(matches!(\n            res,\n            Err(Error {\n                kind: ErrorKind::UnexpectedToken(TokenKind::Literal('a'), _),\n                ..\n            })\n        ));\n    }\n\n    #[test]\n    fn item() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Dot,\n            TokenKind::Literal('a'),\n            TokenKind::EndOfText,\n            TokenKind::OpenGroup,\n            TokenKind::Literal('b'),\n            TokenKind::CloseGroup,\n            TokenKind::Digit(true),\n            TokenKind::Whitespace(false),\n            TokenKind::WordChar(true),\n            TokenKind::UnicodeShort('L', true),\n            TokenKind::OpenBracket,\n            TokenKind::Literal('c'),\n            TokenKind::CloseBracket,\n            TokenKind::Star,\n        ]));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Any);\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Literal('a'));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Boundary(_));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Group(_));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Digit(true));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Whitespace(false));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::WordChar(true));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Class(_));\n\n        let expr = unwrap_parse(p.parse_item());\n        assert_kind!(expr, ExprKind::Class(_));\n\n        let res = p.parse_item();\n        assert_err!(res, ErrorKind::UnexpectedToken(TokenKind::Star, _));\n    }\n\n    #[test]\n    fn boundary() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::StartOfLine,\n            TokenKind::EndOfLine,\n            TokenKind::StartOfText,\n            TokenKind::EndOfText,\n            TokenKind::WordBoundary,\n            TokenKind::NonWordBoundary,\n            TokenKind::OpenGroup,\n            TokenKind::CloseGroup,\n        ]));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::StartOfLine));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::EndOfLine));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::StartOfText));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::EndOfText));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::WordBoundary));\n\n        let boundary = get_boundary(p.parse_boundary());\n        assert!(matches!(boundary.kind, BoundaryKind::NonWordBoundary));\n\n        let res = p.parse_boundary();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroup,\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n            TokenKind::CloseGroupName,\n            TokenKind::Literal('b'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('c'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('d'),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('e'),\n            TokenKind::OpenGroup,\n            TokenKind::CloseGroup,\n        ]));\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::Capturing(_));\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::Named(_));\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::NonCapturing(_));\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, .. }) = group.kind else {\n            panic!(\"not a non-capturing group\");\n        };\n        assert!(flags.is_none());\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::NonCapturing(_));\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, .. }) = group.kind else {\n            panic!(\"not a non-capturing group\");\n        };\n        assert!(flags.is_some());\n\n        let group = get_group(p.parse_group());\n        assert_kind!(group, GroupKind::Flags(_));\n\n        let res = p.parse_group();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn group_errors() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroup,\n            TokenKind::Literal('a'),\n        ]));\n\n        let res = p.parse_group();\n        assert!(matches!(\n            res,\n            Err(Error {\n                kind: ErrorKind::UnexpectedEOF(_),\n                ..\n            })\n        ));\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroup,\n            TokenKind::CloseBracket,\n        ]));\n\n        let res = p.parse_group();\n        assert!(matches!(\n            res,\n            Err(Error {\n                kind: ErrorKind::UnexpectedToken(TokenKind::CloseBracket, _),\n                ..\n            })\n        ));\n    }\n\n    #[test]\n    fn non_capturing() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, expr, .. }) = kind else {\n            panic!(\"non a non-capturing group\");\n        };\n\n        assert!(flags.is_none());\n        assert_kind!(expr, ExprKind::Concatenation(_));\n    }\n\n    #[test]\n    fn non_capturing_flags() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::NonCapturing(NonCapturingGroup { flags, expr, .. }) = kind else {\n            panic!(\"non a non-capturing group\");\n        };\n\n        assert!(flags.is_some());\n        assert_eq!(\n            flags.as_ref().unwrap().set_flags,\n            vec![FlagKind::CaseInsensitive]\n        );\n        assert_eq!(\n            flags.as_ref().unwrap().clear_flags,\n            vec![FlagKind::IgnoreWhitespace]\n        );\n        assert_kind!(expr, ExprKind::Concatenation(_));\n    }\n\n    #[test]\n    fn named_group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n            TokenKind::CloseGroupName,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('b'),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::Named(NamedGroup { name, expr, .. }) = kind else {\n            panic!(\"not a named group\");\n        };\n\n        assert_eq!(name.value, \"name\".to_string());\n        assert_kind!(expr, ExprKind::Concatenation(_));\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n            TokenKind::CloseGroupName,\n            TokenKind::CloseGroupOptions,\n        ]));\n\n        let res = p.parse_group_with_header();\n        assert_err!(\n            res,\n            ErrorKind::UnexpectedToken(TokenKind::CloseGroupOptions, _)\n        );\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(\"name\".to_string()),\n        ]));\n\n        let res = p.parse_group_with_header();\n        assert_err!(res, ErrorKind::UnexpectedEOF(_));\n    }\n\n    #[test]\n    fn flag_group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::SwapGreed),\n        ]));\n\n        let kind = unwrap_parse(p.parse_group_with_header());\n        let GroupKind::Flags(flags) = kind else {\n            panic!(\"not a flag group\");\n        };\n        assert_eq!(\n            flags.flags.set_flags,\n            vec![FlagKind::CaseInsensitive, FlagKind::IgnoreWhitespace],\n        );\n        assert_eq!(\n            flags.flags.clear_flags,\n            vec![FlagKind::MultiLine, FlagKind::SwapGreed],\n        );\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::FlagDelimiter,\n        ]));\n\n        let res = p.parse_group_with_header();\n        assert_err!(\n            res,\n            ErrorKind::UnexpectedToken(TokenKind::FlagDelimiter, ..)\n        );\n    }\n\n    #[test]\n    fn capturing_group() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n        ]));\n        p.group_index = 4;\n\n        let kind = unwrap_parse(p.parse_capturing_group());\n        assert!(matches!(kind, GroupKind::Capturing(_)));\n        let GroupKind::Capturing(group) = kind else {\n            panic!(\"not a capturing group\");\n        };\n\n        assert!(matches!(group.expr.kind, ExprKind::Concatenation(_)));\n        assert_eq!(group.index, 4);\n        assert_eq!(p.group_index, 5);\n    }\n\n    #[test]\n    fn flags() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::CRLFMode),\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::Flag(Flag::Unicode),\n            TokenKind::CloseGroupOptions,\n        ]));\n\n        let flags = unwrap_parse(p.parse_flags());\n\n        let expected_set = vec![\n            FlagKind::IgnoreWhitespace,\n            FlagKind::MultiLine,\n            FlagKind::CRLFMode,\n            FlagKind::DotMatchesNewline,\n        ];\n        assert_eq!(expected_set.len(), flags.set_flags.len());\n        for (expected_flag, actual_flag) in expected_set.into_iter().zip(flags.set_flags) {\n            assert_eq!(expected_flag, actual_flag);\n        }\n\n        let expected_clear = vec![\n            FlagKind::CaseInsensitive,\n            FlagKind::SwapGreed,\n            FlagKind::Unicode,\n        ];\n        assert_eq!(expected_clear.len(), flags.clear_flags.len());\n        for (expected_flag, actual_flag) in expected_clear.into_iter().zip(flags.clear_flags) {\n            assert_eq!(expected_flag, actual_flag);\n        }\n    }\n\n    #[test]\n    fn class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::OpenBracket,\n            TokenKind::Negated,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::CloseBracket,\n            TokenKind::Plus,\n        ]));\n\n        let class = get_class(p.parse_class());\n        assert!(matches!(\n            class,\n            Class {\n                kind: ClassKind::Unicode(_),\n                ..\n            }\n        ));\n\n        let class = get_class(p.parse_class());\n        assert!(matches!(\n            class,\n            Class {\n                kind: ClassKind::Specified(_),\n                ..\n            }\n        ));\n\n        let res = p.parse_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn unicode_class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Letter\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::Literal('\\x5A'),\n        ]));\n\n        let class = get_unicode_class(get_class(p.parse_unicode_class()));\n        assert_eq!(class.value.value, \"L\".to_string());\n        assert!(class.name.is_none());\n\n        let class = get_unicode_class(get_class(p.parse_unicode_class()));\n        assert_eq!(class.value.value, \"Letter\".to_string());\n        assert!(class.name.is_none());\n\n        let res = p.parse_unicode_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn unicode_short_class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::UnicodeShort('L', true),\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Letter\".to_string()),\n            TokenKind::CloseBrace,\n        ]));\n\n        let class = get_class(p.parse_unicode_short_class());\n        assert!(!class.negated);\n        let u_class = get_unicode_class(class);\n        assert_eq!(u_class.value.value, \"L\".to_string());\n\n        let class = get_class(p.parse_unicode_short_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert_eq!(u_class.value.value, \"L\".to_string());\n\n        let res = p.parse_unicode_short_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn unicode_long_class() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Letter\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"Digit\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"sc\".to_string()),\n            TokenKind::Bang,\n            TokenKind::Equal,\n            TokenKind::Name(\"Greek\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"sc\".to_string()),\n            TokenKind::Equal,\n            TokenKind::Name(\"Greek\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(\"sc\".to_string()),\n            TokenKind::Bang,\n            TokenKind::Equal,\n            TokenKind::Name(\"Greek\".to_string()),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeShort('L', true),\n        ]));\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(!class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_none());\n        assert_eq!(u_class.value.value, \"Letter\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_none());\n        assert_eq!(u_class.value.value, \"Digit\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_some());\n        assert_eq!(u_class.name.unwrap().value, \"sc\".to_string());\n        assert_eq!(u_class.value.value, \"Greek\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_some());\n        assert_eq!(u_class.name.unwrap().value, \"sc\".to_string());\n        assert_eq!(u_class.value.value, \"Greek\".to_string());\n\n        let class = get_class(p.parse_unicode_long_class());\n        assert!(!class.negated);\n        let u_class = get_unicode_class(class);\n        assert!(u_class.name.is_some());\n        assert_eq!(u_class.name.unwrap().value, \"sc\".to_string());\n        assert_eq!(u_class.value.value, \"Greek\".to_string());\n\n        let res = p.parse_unicode_long_class();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn specified_class() {\n        let mut p = Parser::new(span_token_iter(\n            0,\n            vec![\n                (1, TokenKind::OpenBracket),\n                (1, TokenKind::Literal('a')),\n                (1, TokenKind::Literal('b')),\n                (1, TokenKind::Literal('c')),\n                (1, TokenKind::CloseBracket),\n                (1, TokenKind::OpenBracket),\n                (1, TokenKind::Negated),\n                (1, TokenKind::Literal('a')),\n                (1, TokenKind::Literal('b')),\n                (1, TokenKind::Literal('c')),\n                (1, TokenKind::CloseBracket),\n            ],\n        ));\n\n        let class = get_class(p.parse_specified_class());\n        assert!(!class.negated);\n        assert_eq!(class.span.start, 0);\n        assert_eq!(class.span.end, 5);\n        assert!(matches!(class.kind, ClassKind::Specified(_)));\n        let items = get_class_items(class);\n        assert_eq!(items.len(), 3);\n        assert!(matches!(items[0].kind, ClassSpecKind::Literal('a')));\n        assert!(matches!(items[1].kind, ClassSpecKind::Literal('b')));\n        assert!(matches!(items[2].kind, ClassSpecKind::Literal('c')));\n\n        let class = get_class(p.parse_specified_class());\n        assert!(class.negated);\n        assert_eq!(class.span.start, 5);\n        assert_eq!(class.span.end, 11);\n        assert!(matches!(class.kind, ClassKind::Specified(_)));\n        let items = get_class_items(class);\n        assert_eq!(items.len(), 3);\n        assert!(matches!(items[0].kind, ClassSpecKind::Literal('a')));\n        assert!(matches!(items[1].kind, ClassSpecKind::Literal('b')));\n        assert!(matches!(items[2].kind, ClassSpecKind::Literal('c')));\n    }\n\n    #[test]\n    fn spec_class_item() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Intersection,\n            TokenKind::Literal('\\x63'),\n            TokenKind::Symmetrical,\n            TokenKind::Literal('Q'),\n            TokenKind::CloseBracket,\n        ]));\n        let spec = get_class_spec(p.parse_specified_class_item());\n\n        assert!(matches!(spec.kind, ClassSpecKind::Symmetrical(_)));\n        let ClassSpecKind::Symmetrical(spec) = spec.kind else {\n            panic!(\"symmetrical\");\n        };\n\n        assert!(matches!(spec.left.kind, ClassSpecKind::Intersection(_)));\n        assert!(matches!(spec.right.kind, ClassSpecKind::Literal('Q')));\n\n        let ClassSpecKind::Intersection(spec) = spec.left.kind else {\n            panic!(\"intersection\");\n        };\n\n        assert!(matches!(spec.left.kind, ClassSpecKind::Range('a', 'z')));\n        assert!(matches!(spec.right.kind, ClassSpecKind::Literal('\\x63')));\n    }\n\n    #[test]\n    fn class_term() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Digit(true),\n            TokenKind::Whitespace(false),\n            TokenKind::WordChar(false),\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Name(\"alpha\".to_string()),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Literal('a'),\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n        ]));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('a')));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Range('b', 'z')));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Digit(true)));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::Whitespace(false)));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(spec.kind, ClassSpecKind::WordChar(false)));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Posix(PosixClass {\n                kind: PosixKind::Alpha,\n                ..\n            })\n        ));\n\n        let spec = get_class_spec(p.parse_specified_class_term());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Class(Class {\n                kind: ClassKind::Specified(_),\n                ..\n            })\n        ));\n    }\n\n    #[test]\n    fn class_term_literal() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Range,\n            TokenKind::Literal('c'),\n            TokenKind::Literal('d'),\n            TokenKind::Literal('-'),\n            TokenKind::CloseBracket,\n        ]));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('a')));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Range('b', 'c')));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('d')));\n\n        let spec = get_class_spec(p.parse_class_term_literal());\n        assert!(matches!(spec.kind, ClassSpecKind::Literal('-')));\n    }\n\n    #[test]\n    fn class_term_bracket() {\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Negated,\n            TokenKind::Name(\"xdigit\".to_string()),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::CloseBracket,\n            TokenKind::Literal('a'),\n        ]));\n\n        let spec = get_class_spec(p.parse_class_term_bracket());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Posix(PosixClass {\n                kind: PosixKind::XDigit,\n                negated: true,\n                ..\n            })\n        ));\n\n        let spec = get_class_spec(p.parse_class_term_bracket());\n        assert!(matches!(\n            spec.kind,\n            ClassSpecKind::Class(Class {\n                kind: ClassKind::Specified(_),\n                ..\n            })\n        ));\n\n        let res = p.parse_class_term_bracket();\n        assert!(matches!(res, Ok(None)));\n    }\n\n    #[test]\n    fn class_item_set() {\n        let lhs = ClassSpec {\n            span: Span::new(2, 3),\n            kind: ClassSpecKind::Literal('c'),\n        };\n\n        let mut p = Parser::new(token_iter(vec![\n            TokenKind::Symmetrical,\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Difference,\n            TokenKind::Literal('z'),\n        ]));\n\n        let Ok(spec) = p.parse_class_item_set(lhs) else {\n            panic!(\"parse failed\");\n        };\n        let ClassSpecKind::Difference(set) = spec.kind else {\n            panic!(\"difference set\");\n        };\n        assert!(matches!(set.left.kind, ClassSpecKind::Symmetrical(_)));\n        assert!(matches!(set.right.kind, ClassSpecKind::Literal('z')));\n\n        let ClassSpecKind::Symmetrical(set) = set.left.kind else {\n            panic!(\"symmetrical set\");\n        };\n        assert!(matches!(set.left.kind, ClassSpecKind::Literal('c')));\n        assert!(matches!(set.right.kind, ClassSpecKind::Range('a', 'z')));\n    }\n}\n","traces":[{"line":90,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":79},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":892,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":977,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":996,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1005,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":1079,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1080,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":1099,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":1102,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":1110,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1114,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1143,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1144,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1155,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":1190,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":1194,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":1221,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1226,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1227,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1228,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1232,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1233,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1234,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1235,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1242,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1246,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1248,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":1288,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":1289,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1291,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":1295,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1303,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1304,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":1305,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1306,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1307,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1308,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1316,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1324,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1327,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":1331,"address":[],"length":0,"stats":{"Line":1259},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":493},"fn_name":null},{"line":1334,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":1338,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":1341,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1342,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1343,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1344,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":1357,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":1358,"address":[],"length":0,"stats":{"Line":181},"fn_name":null},{"line":1359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1363,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1365,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":383,"coverable":436},{"path":["/","home","carson","projects","aglet","aglet-regex","src","parse","pretty.rs"],"content":"use aglet_pretty::{Pretty, Result, Writer};\nuse colored::Color;\n\nuse crate::parse::ast::*;\n\nconst COLOR_BOUNDARY: Option\u003cColor\u003e = Some(Color::BrightRed);\nconst COLOR_REPETITION: Option\u003cColor\u003e = Some(Color::Cyan);\nconst COLOR_MATCH_ONE: Option\u003cColor\u003e = Some(Color::Green);\nconst COLOR_CLASS_ITEM: Option\u003cColor\u003e = Some(Color::BrightYellow);\n\nimpl Pretty for Expr {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            ExprKind::Any =\u003e w.print_ast(\".\", Some(self.span), COLOR_MATCH_ONE).finish(),\n            ExprKind::Literal(c) =\u003e w\n                .print_ast(\"Literal\", Some(self.span), COLOR_MATCH_ONE)\n                .property(None, c, None)\n                .finish(),\n            ExprKind::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ExprKind::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ExprKind::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ExprKind::Empty =\u003e w.print_ast(\"Expr\", Some(self.span), None).finish(),\n            _ =\u003e w.print(\u0026self.kind),\n        }\n    }\n}\n\nimpl Pretty for ExprKind {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match self {\n            Self::Alternation(alt) =\u003e w.print(alt),\n            Self::Concatenation(concat) =\u003e w.print(concat),\n            Self::Repetition(rep) =\u003e w.print(rep),\n            Self::Any =\u003e w.print_ast(\"Any\", None, None).finish(),\n            Self::Literal(c) =\u003e w\n                .print_ast(\"Literal\", None, COLOR_MATCH_ONE)\n                .property(None, c, None)\n                .finish(),\n            Self::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", None, COLOR_MATCH_ONE)\n                .maybe_property(None, if *negated { Some(\u0026\"negated\") } else { None }, None)\n                .finish(),\n            Self::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", None, COLOR_MATCH_ONE)\n                .maybe_property(None, if *negated { Some(\u0026\"negated\") } else { None }, None)\n                .finish(),\n            Self::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", None, COLOR_MATCH_ONE)\n                .maybe_property(None, if *negated { Some(\u0026\"negated\") } else { None }, None)\n                .finish(),\n            Self::Boundary(boundary) =\u003e w.print(boundary),\n            Self::Group(group) =\u003e w.print(group),\n            Self::Class(class) =\u003e w.print(class),\n            Self::Empty =\u003e w.print_ast(\"Expr\", None, None).finish(),\n        }\n    }\n}\n\nimpl Pretty for Alternation {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let mut printer = w.print_ast(\"Alt\", Some(self.span), None);\n        for expr in \u0026self.items {\n            printer.child(None, expr);\n        }\n        printer.finish()\n    }\n}\n\nimpl Pretty for Concatenation {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let mut printer = w.print_ast(\"Concat\", Some(self.span), None);\n        for expr in \u0026self.items {\n            printer.child(None, expr);\n        }\n        printer.finish()\n    }\n}\n\nimpl Pretty for Repetition {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            RepetitionKind::ZeroOrOne =\u003e w\n                .print_ast(\"ZeroOrOne\", Some(self.span), COLOR_REPETITION)\n                .child(None, \u0026*self.item)\n                .finish(),\n            RepetitionKind::ZeroOrMore =\u003e w\n                .print_ast(\"ZeroOrMore\", Some(self.span), COLOR_REPETITION)\n                .child(None, \u0026*self.item)\n                .finish(),\n            RepetitionKind::OneOrMore =\u003e w\n                .print_ast(\"OneOrMore\", Some(self.span), COLOR_REPETITION)\n                .child(None, \u0026*self.item)\n                .finish(),\n            RepetitionKind::Range(range) =\u003e w\n                .print_ast(\"Range\", Some(self.span), COLOR_REPETITION)\n                .property(Some(\"start\"), \u0026range.start.unwrap_or(0), None)\n                .maybe_property(Some(\"end\"), range.end.as_ref(), None)\n                .child(None, \u0026*self.item)\n                .finish(),\n        }\n    }\n}\n\nimpl Pretty for Boundary {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let boundary_title = format!(\"{:?}\", self.kind);\n        w.print_ast(boundary_title.as_ref(), Some(self.span), COLOR_BOUNDARY)\n            .finish()\n    }\n}\n\nimpl Pretty for Group {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print(\u0026self.kind)\n    }\n}\n\nimpl Pretty for GroupKind {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match self {\n            Self::Capturing(capturing) =\u003e w.print(capturing),\n            Self::Named(named) =\u003e w.print(named),\n            Self::NonCapturing(non_capturing) =\u003e w.print(non_capturing),\n            Self::Flags(flags) =\u003e w.print(flags),\n            Self::Empty =\u003e w.print_ast(\"Group\", None, None).finish(),\n        }\n    }\n}\n\nimpl Pretty for CapturingGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Group\", Some(self.span), None)\n            .property(Some(\"index\"), \u0026self.index, None)\n            .child(None, \u0026*self.expr)\n            .finish()\n    }\n}\n\nimpl Pretty for NamedGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Group\", Some(self.span), None)\n            .property(Some(\"name\"), \u0026self.name.value, None)\n            .child(None, \u0026*self.expr)\n            .finish()\n    }\n}\n\nimpl Pretty for NonCapturingGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let mut printer = w.print_ast(\"Group\", Some(self.span), None);\n        if let Some(flags) = \u0026self.flags {\n            printer.child(None, flags);\n        }\n\n        printer.child(None, \u0026*self.expr).finish()\n    }\n}\n\nimpl Pretty for FlagGroup {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print(\u0026self.flags)\n    }\n}\n\nimpl Pretty for Flags {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Flags\", Some(self.span), None)\n            .property(Some(\"set\"), \u0026self.set_flags, None)\n            .property(Some(\"clear\"), \u0026self.clear_flags, None)\n            .finish()\n    }\n}\n\nimpl Pretty for Class {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            ClassKind::Unicode(class) =\u003e w\n                .print_ast(\"UnicodeClass\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if self.negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .maybe_property(\n                    Some(\"name\"),\n                    class.name.as_ref().map(|name| \u0026name.value).as_ref(),\n                    None,\n                )\n                .property(Some(\"value\"), \u0026class.value.value, None)\n                .finish(),\n            ClassKind::Specified(class) =\u003e w\n                .print_ast(\"SpecifiedClass\", Some(self.span), COLOR_MATCH_ONE)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if self.negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .children(\u0026class.items)\n                .finish(),\n        }\n    }\n}\n\nimpl Pretty for ClassSpec {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match \u0026self.kind {\n            ClassSpecKind::Literal(c) =\u003e w\n                .print_ast(\"Literal\", Some(self.span), COLOR_CLASS_ITEM)\n                .property(None, c, None)\n                .finish(),\n            ClassSpecKind::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", Some(self.span), COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ClassSpecKind::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", Some(self.span), COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ClassSpecKind::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", Some(self.span), COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            ClassSpecKind::Range(start, end) =\u003e w\n                .print_ast(\"Range\", Some(self.span), COLOR_CLASS_ITEM)\n                .property(Some(\"start\"), start, None)\n                .property(Some(\"end\"), end, None)\n                .finish(),\n            _ =\u003e w.print(\u0026self.kind),\n        }\n    }\n}\n\nimpl Pretty for ClassSpecKind {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        match self {\n            Self::Intersection(intersection) =\u003e w.print(intersection),\n            Self::Difference(difference) =\u003e w.print(difference),\n            Self::Symmetrical(symmetrical) =\u003e w.print(symmetrical),\n            Self::Literal(c) =\u003e w\n                .print_ast(\"Literal\", None, COLOR_CLASS_ITEM)\n                .property(None, c, None)\n                .finish(),\n            Self::Digit(negated) =\u003e w\n                .print_ast(\"Digit\", None, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            Self::Whitespace(negated) =\u003e w\n                .print_ast(\"Whitespace\", None, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            Self::WordChar(negated) =\u003e w\n                .print_ast(\"WordChar\", None, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            Self::Range(start, end) =\u003e w\n                .print_ast(\"Range\", None, COLOR_CLASS_ITEM)\n                .property(Some(\"start\"), start, None)\n                .property(Some(\"end\"), end, None)\n                .finish(),\n            Self::Posix(posix) =\u003e w.print(posix),\n            Self::Class(class) =\u003e w.print(class),\n            Self::Empty =\u003e w.print_ast(\"Empty\", None, COLOR_CLASS_ITEM).finish(),\n        }\n    }\n}\n\nimpl Pretty for Intersection {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Intersection\", Some(self.span), COLOR_CLASS_ITEM)\n            .child(None, \u0026*self.left)\n            .child(None, \u0026*self.right)\n            .finish()\n    }\n}\n\nimpl Pretty for Difference {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"Difference\", Some(self.span), COLOR_CLASS_ITEM)\n            .child(None, \u0026*self.left)\n            .child(None, \u0026*self.right)\n            .finish()\n    }\n}\n\nimpl Pretty for Symmetrical {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"SymmectricalDifference\", Some(self.span), COLOR_CLASS_ITEM)\n            .child(None, \u0026*self.left)\n            .child(None, \u0026*self.right)\n            .finish()\n    }\n}\n\nimpl Pretty for PosixClass {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_ast(\"PosixClass\", Some(self.span), COLOR_CLASS_ITEM)\n            .property(None, \u0026self.kind, None)\n            .finish()\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":186},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","error.rs"],"content":"use std::{fmt, ops, result};\n\nuse aglet_text::Span;\n\nuse crate::tokenize::state::StateStack;\n\npub type Result\u003cT\u003e = result::Result\u003cT, Error\u003e;\npub type StackResult\u003cT\u003e = result::Result\u003cT, StackError\u003e;\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    pub span:  Span,\n    pub cause: ErrorCause,\n}\n\nimpl Error {\n    pub fn new(span: Span, cause: ErrorCause) -\u003e Self {\n        Error { span, cause }\n    }\n\n    pub fn is_fatal(\u0026self) -\u003e bool {\n        matches!(self.cause, ErrorCause::FatalError(_))\n    }\n\n    pub fn is_eof(\u0026self) -\u003e bool {\n        matches!(self.cause, ErrorCause::Error(ErrorKind::EndOfFile))\n    }\n\n    pub fn is_any_eof(\u0026self) -\u003e bool {\n        matches!(\n            self.cause,\n            ErrorCause::Error(ErrorKind::EndOfFile | ErrorKind::UnexpectedEOF(_))\n        )\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}) {}\", self.span, self.cause)\n    }\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub struct StackError {\n    pub error: Error,\n    pub stack: StateStack,\n}\n\nimpl StackError {\n    pub fn from_error(error: Error, stack: StateStack) -\u003e Self {\n        StackError { error, stack }\n    }\n}\n\nimpl fmt::Display for StackError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"({}) {}\", self.span, self.cause)\n    }\n}\n\nimpl ops::Deref for StackError {\n    type Target = Error;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.error\n    }\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum ErrorCause {\n    #[error(\"{0}\")]\n    Error(#[from] ErrorKind),\n\n    #[error(\"fatal error: {0}\")]\n    FatalError(#[from] FatalErrorKind),\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum ErrorKind {\n    #[error(\"end of file\")]\n    EndOfFile,\n\n    #[error(\"unexpected end of file: {0}\")]\n    UnexpectedEOF(String),\n\n    #[error(\"unexpected `{0}`\")]\n    UnexpectedChar(char),\n\n    #[error(\"invalid hex digit `{0}`\")]\n    InvalidHexDigit(char),\n\n    #[error(\"invalid character code `{0}`\")]\n    InvalidCharCode(String),\n\n    #[error(\"unrecognized escape sequence: \\\\{0}\")]\n    UnrecognizedEscape(char),\n\n    #[error(\"unrecognized flag: {0}\")]\n    UnrecognizedFlag(char),\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum FatalErrorKind {\n    #[error(\"state stack is empty\")]\n    EmptyStateStack,\n\n    #[error(\"internal state error: {0}\")]\n    InternalStateError(StateError),\n\n    #[error(\"not implemented\")]\n    NotImplemented,\n}\n\nimpl From\u003cStateError\u003e for ErrorCause {\n    fn from(value: StateError) -\u003e Self {\n        ErrorCause::FatalError(value.into())\n    }\n}\n\nimpl From\u003cStateError\u003e for FatalErrorKind {\n    fn from(err: StateError) -\u003e Self {\n        FatalErrorKind::InternalStateError(err)\n    }\n}\n\n#[derive(thiserror::Error, Clone, Debug, Eq, PartialEq)]\npub enum StateError {\n    #[error(\"no state on tokenizer stack\")]\n    NoStateOnStack,\n\n    #[error(\"cannot pop final state from tokenizer stack\")]\n    PoppedFinalState,\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":19},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","mod.rs"],"content":"pub mod error;\nmod pretty;\nmod state;\npub mod token;\npub mod tokenizer;\n\npub use error::{Error, ErrorCause, ErrorKind, FatalErrorKind, Result};\npub use token::{Flag, Token, TokenKind};\npub use tokenizer::Tokenizer;\n\n#[cfg(test)]\nmacro_rules! assert_next_tok {\n    ( $tokenizer:expr , $kind:pat ) =\u003e {\n        let next = $tokenizer.next();\n        if !matches!(next, Some(Ok(Token { kind: $kind, .. }))) {\n            panic!(\"{:?} does not match token {}\", next, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_next_err {\n    ( $tokenizer:expr , $kind:pat ) =\u003e {\n        let next = $tokenizer.next();\n        if !matches!(\n            next,\n            Some(Err(Error {\n                cause: ErrorCause::Error($kind),\n                ..\n            }))\n        ) {\n            panic!(\"{:?} does not match error {}\", next, stringify!($kind));\n        }\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_next_none {\n    ( $tokenizer:expr ) =\u003e {\n        let next = $tokenizer.next();\n        if !next.is_none() {\n            panic!(\"{:?} is not None\", next);\n        }\n    };\n}\n\n#[cfg(test)]\npub(crate) fn assert_tokens(mut tr: Tokenizer, tokens: Vec\u003cTokenKind\u003e) {\n    let total_expected = tokens.len();\n    let mut count = 0;\n    for (i, expected) in tokens.iter().enumerate() {\n        let actual = tr\n            .next()\n            .expect(\u0026format!(\n                \"ran out of tokens; expecting {:?} ({})\",\n                expected, i\n            ))\n            .unwrap_or_else(|err| {\n                panic!(\"received error {:?}; expecting {:?} ({})\", err, expected, i)\n            })\n            .kind;\n\n        assert_eq!(expected, \u0026actual, \"failed to match token {}\", i);\n        count += 1;\n    }\n\n    assert_eq!(total_expected, count);\n    assert_next_none!(tr);\n}\n\n#[cfg(test)]\npub(crate) use assert_next_err;\n#[cfg(test)]\npub(crate) use assert_next_none;\n#[cfg(test)]\npub(crate) use assert_next_tok;\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":269},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":24},"fn_name":null}],"covered":15,"coverable":16},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","pretty.rs"],"content":"use aglet_pretty::{Pretty, Result, Writer};\nuse colored::Color;\n\nuse crate::tokenize::error::{Error, StackError};\nuse crate::tokenize::state::State;\nuse crate::tokenize::token::*;\n\nconst COLOR_BOUNDARY: Option\u003cColor\u003e = Some(Color::BrightRed);\nconst COLOR_REPETITION: Option\u003cColor\u003e = Some(Color::Cyan);\nconst COLOR_MATCH_ONE: Option\u003cColor\u003e = Some(Color::Green);\nconst COLOR_CLASS_ITEM: Option\u003cColor\u003e = Some(Color::BrightYellow);\nconst COLOR_ERROR: Option\u003cColor\u003e = Some(Color::Red);\n\nimpl Pretty for TokenStack {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let stack = Some(format!(\"\\t\\u{2192} {:?}\", self.stack));\n        let top_state = self.stack.get().map(|state| *state).ok();\n\n        self.token.pretty_print(stack, top_state, w)\n    }\n}\n\nimpl Pretty for Token {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        self.pretty_print(None, None, w)\n    }\n}\n\nimpl Pretty for StackError {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        let stack = Some(format!(\"\\t\\u{2192} {:?}\", self.stack));\n        w.print_token(\"Error\", Some(self.span), stack, COLOR_ERROR)\n            .property(None, \u0026self.cause.to_string(), None)\n            .finish()\n    }\n}\n\nimpl Pretty for Error {\n    fn print(\u0026self, w: \u0026mut Writer\u003c'_\u003e) -\u003e Result {\n        w.print_token(\"Error\", Some(self.span), None, COLOR_ERROR)\n            .property(None, \u0026self.cause.to_string(), None)\n            .finish()\n    }\n}\n\nimpl Token {\n    fn pretty_print(\n        \u0026self,\n        stack: Option\u003cString\u003e,\n        top_state: Option\u003cState\u003e,\n        w: \u0026mut Writer\u003c'_\u003e,\n    ) -\u003e Result {\n        match \u0026self.kind {\n            TokenKind::Literal(c) =\u003e w\n                .print_token(\n                    \"Literal\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .property(None, c, None)\n                .finish(),\n            TokenKind::Digit(negated) =\u003e w\n                .print_token(\n                    \"Digit\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::Whitespace(negated) =\u003e w\n                .print_token(\n                    \"Whitespace\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::WordChar(negated) =\u003e w\n                .print_token(\n                    \"WordChar\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Class)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        COLOR_MATCH_ONE\n                    },\n                )\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::Dot =\u003e w\n                .print_token(\"Dot\", Some(self.span), stack, COLOR_MATCH_ONE)\n                .finish(),\n            TokenKind::Alternate =\u003e w\n                .print_token(\"Alternate\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::StartOfLine =\u003e w\n                .print_token(\"StartOfLine\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::EndOfLine =\u003e w\n                .print_token(\"EndOfLine\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::StartOfText =\u003e w\n                .print_token(\"StartOfText\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::EndOfText =\u003e w\n                .print_token(\"EndOfText\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::WordBoundary =\u003e w\n                .print_token(\"WordBoundary\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::NonWordBoundary =\u003e w\n                .print_token(\"NonWordBoundary\", Some(self.span), stack, COLOR_BOUNDARY)\n                .finish(),\n            TokenKind::OpenBrace =\u003e w\n                .print_token(\n                    \"OpenBrace\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Range)) {\n                        COLOR_REPETITION\n                    } else if matches!(top_state, Some(State::UnicodeProperties)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        None\n                    },\n                )\n                .finish(),\n            TokenKind::CloseBrace =\u003e w\n                .print_token(\n                    \"CloseBrace\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::Range)) {\n                        COLOR_REPETITION\n                    } else if matches!(top_state, Some(State::UnicodeProperties)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        None\n                    },\n                )\n                .finish(),\n            TokenKind::Number(value) =\u003e w\n                .print_token(\"Number\", Some(self.span), stack, COLOR_REPETITION)\n                .property(None, value, None)\n                .finish(),\n            TokenKind::Comma =\u003e w\n                .print_token(\"Comma\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::Question =\u003e w\n                .print_token(\"Question\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::Star =\u003e w\n                .print_token(\"Star\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::Plus =\u003e w\n                .print_token(\"Plus\", Some(self.span), stack, COLOR_REPETITION)\n                .finish(),\n            TokenKind::OpenGroup =\u003e w\n                .print_token(\"OpenGroup\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::CloseGroup =\u003e w\n                .print_token(\"CloseGroup\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::OpenGroupOptions =\u003e w\n                .print_token(\"OpenGroupOptions\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::CloseGroupOptions =\u003e w\n                .print_token(\"CloseGroupOptions\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::OpenGroupName =\u003e w\n                .print_token(\"OpenGroupName\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::CloseGroupName =\u003e w\n                .print_token(\"CloseGroupName\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::Flag(flag) =\u003e w\n                .print_token(\"Flag\", Some(self.span), stack, None)\n                .property(None, flag, None)\n                .finish(),\n            TokenKind::FlagDelimiter =\u003e w\n                .print_token(\"FlagDelimiter\", Some(self.span), stack, None)\n                .finish(),\n            TokenKind::OpenBracket =\u003e w\n                .print_token(\"OpenBracket\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::CloseBracket =\u003e w\n                .print_token(\"CloseBracket\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Colon =\u003e w\n                .print_token(\"Colon\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Negated =\u003e w\n                .print_token(\"Negated\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Range =\u003e w\n                .print_token(\"Range\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Symmetrical =\u003e w\n                .print_token(\"Symmetrical\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Difference =\u003e w\n                .print_token(\"Difference\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Intersection =\u003e w\n                .print_token(\"Intersection\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::UnicodeShort(category, negated) =\u003e w\n                .print_token(\"UnicodeShort\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .property(None, category, None)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::UnicodeLong(negated) =\u003e w\n                .print_token(\"UnicodeLong\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .maybe_property(\n                    Some(\"negated\"),\n                    if *negated { Some(\u0026true) } else { None },\n                    None,\n                )\n                .finish(),\n            TokenKind::Equal =\u003e w\n                .print_token(\"Equal\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Bang =\u003e w\n                .print_token(\"Bang\", Some(self.span), stack, COLOR_CLASS_ITEM)\n                .finish(),\n            TokenKind::Name(name) =\u003e w\n                .print_token(\n                    \"Name\",\n                    Some(self.span),\n                    stack,\n                    if matches!(top_state, Some(State::ClassName | State::UnicodeProperties)) {\n                        COLOR_CLASS_ITEM\n                    } else {\n                        None\n                    },\n                )\n                .property(None, name, None)\n                .finish(),\n        }\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":147},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","state.rs"],"content":"use std::fmt;\n\nuse crate::tokenize::error::StateError;\n\n#[derive(Clone, PartialEq, Eq)]\npub struct StateStack {\n    pub stack: Vec\u003cStateFlags\u003e,\n}\n\nimpl StateStack {\n    pub(crate) fn new() -\u003e Self {\n        StateStack {\n            stack: vec![StateFlags::default()],\n        }\n    }\n\n    pub(crate) fn push(\u0026mut self, state: State) {\n        let flags = self.stack.last().map(|sf| sf.flags).unwrap_or_default();\n\n        self.stack.push(StateFlags { state, flags });\n    }\n\n    pub(crate) fn swap(\u0026mut self, state: State) -\u003e Result\u003cState, StateError\u003e {\n        let former = self.stack.pop().ok_or(StateError::NoStateOnStack)?;\n        let flags = former.flags;\n\n        self.stack.push(StateFlags { state, flags });\n        Ok(former.state)\n    }\n\n    pub(crate) fn pop(\u0026mut self) -\u003e Result\u003cState, StateError\u003e {\n        if self.stack.len() == 1 {\n            return Err(StateError::PoppedFinalState);\n        }\n\n        self.stack\n            .pop()\n            .map(|sf| sf.state)\n            .ok_or(StateError::NoStateOnStack)\n    }\n\n    pub(crate) fn pop_all(\u0026mut self) -\u003e Result\u003c(), StateError\u003e {\n        if self.stack.len() == 1 {\n            return Err(StateError::PoppedFinalState);\n        }\n\n        self.stack.clear();\n        self.stack.push(StateFlags::default());\n\n        Ok(())\n    }\n\n    pub(crate) fn flags(\u0026self) -\u003e Result\u003c\u0026Flags, StateError\u003e {\n        let top = self.stack.last().ok_or(StateError::NoStateOnStack)?;\n\n        Ok(\u0026top.flags)\n    }\n\n    pub(crate) fn flags_mut(\u0026mut self) -\u003e Result\u003c\u0026mut Flags, StateError\u003e {\n        let top = self.stack.last_mut().ok_or(StateError::NoStateOnStack)?;\n\n        Ok(\u0026mut top.flags)\n    }\n\n    pub(crate) fn get(\u0026self) -\u003e Result\u003c\u0026State, StateError\u003e {\n        self.stack\n            .last()\n            .map(|sf| \u0026sf.state)\n            .ok_or(StateError::NoStateOnStack)\n    }\n}\n\nimpl fmt::Debug for StateStack {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut list = f.debug_list();\n        self.stack.iter().for_each(|sf| {\n            list.entry(\u0026sf);\n        });\n\n        list.finish()\n    }\n}\n\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq)]\npub enum State {\n    #[default]\n    Main,\n    GroupOptions,\n    Class,\n    ClassName,\n    Range,\n    UnicodeProperties,\n}\n\n#[derive(Default, Clone, Copy, PartialEq, Eq)]\npub struct Flags {\n    pub(crate) unset_flags:  bool,\n    pub(crate) ignore_space: bool,\n}\n\nimpl fmt::Debug for Flags {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut list = f.debug_list();\n        if self.ignore_space {\n            list.entry(\u0026'x');\n        }\n\n        list.finish()\n    }\n}\n\n#[derive(Default, Clone, Copy, PartialEq, Eq)]\npub struct StateFlags {\n    state: State,\n    flags: Flags,\n}\n\nimpl fmt::Debug for StateFlags {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:?}\", self.state)?;\n        if self.flags.ignore_space {\n            write!(f, \"(x)\")?;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":522},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1080},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":41},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","token.rs"],"content":"use std::convert::TryFrom;\nuse std::fmt;\n\nuse aglet_text::Span;\n\nuse crate::tokenize::error::ErrorKind;\nuse crate::tokenize::state::StateStack;\n\n#[derive(Clone, PartialEq, Eq)]\npub struct Token {\n    pub span: Span,\n    pub kind: TokenKind,\n}\n\nimpl fmt::Debug for Token {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_tuple(\"tok\")\n            .field(\u0026self.span)\n            .field(\u0026self.kind)\n            .finish()\n    }\n}\n\nimpl Token {\n    pub fn new_with_offsets(kind: TokenKind, start: usize, end: usize) -\u003e Self {\n        Self {\n            span: Span::new(start, end),\n            kind,\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum Flag {\n    /// `i`: Letters match regardless of case\n    CaseInsensitive,\n\n    /// `m`: `^` and `$` match the beginning and end of a line\n    MultiLine,\n\n    /// `s`: allow `.` to match `\\n`\n    DotMatchesNewline,\n\n    /// `R`: use `\\r\\n` when multi-line mode is enabled\n    CRLFMode,\n\n    /// `U`: swap the meaning of `x*` and `x*?`\n    SwapGreed,\n\n    /// `u`: enable unicode support\n    Unicode,\n\n    /// `x`: ignore whitespace and enable line comments (beginning with `#`)\n    IgnoreWhitespace,\n}\n\nimpl TryFrom\u003cchar\u003e for Flag {\n    type Error = ErrorKind;\n\n    fn try_from(value: char) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            'i' =\u003e Ok(Self::CaseInsensitive),\n            'm' =\u003e Ok(Self::MultiLine),\n            's' =\u003e Ok(Self::DotMatchesNewline),\n            'R' =\u003e Ok(Self::CRLFMode),\n            'U' =\u003e Ok(Self::SwapGreed),\n            'u' =\u003e Ok(Self::Unicode),\n            'x' =\u003e Ok(Self::IgnoreWhitespace),\n            c =\u003e Err(ErrorKind::UnrecognizedFlag(c)),\n        }\n    }\n}\n\nimpl Flag {\n    pub fn is_flag_char(c: char) -\u003e bool {\n        match c {\n            'i' | 'm' | 's' | 'R' | 'U' | 'u' | 'x' =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    pub fn is_ignore_whitespace(\u0026self) -\u003e bool {\n        matches!(self, Self::IgnoreWhitespace)\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum TokenKind {\n    /// A literal character to be matched, or as part of a character class\n    Literal(char),\n\n    /// Digit character class `\\d`--or negated as `\\D`--either to be matched\n    /// or as a subclass in a specified character class (e.g. `[\\d]`).\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    Digit(bool),\n\n    /// Whitespace character class `\\s`--or negated as `\\S`--either to be matched\n    /// or as a subclass in a specified character class (e.g., `[\\s]`).\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    Whitespace(bool),\n\n    /// Word character class `\\w`--or negated as `\\W`--either to be matched\n    /// or as a subclass in a specified character class (e.g., `[\\w]`).\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    WordChar(bool),\n\n    /// \"Any\" character class `.` matching any input character\n    Dot,\n\n    /// Alternation operator `|` introducing another possible match\n    Alternate,\n\n    // Boundaries ==================================================\n    /// Start of line anchor `^`\n    StartOfLine,\n\n    /// End of line anchor `$`\n    EndOfLine,\n\n    /// Start of text anchor `\\A`\n    StartOfText,\n\n    /// End of text anchor `\\z`\n    EndOfText,\n\n    /// Word boundary `\\b`\n    WordBoundary,\n\n    /// Non-word boundary `\\B`\n    NonWordBoundary,\n\n    // Repetition ==================================================\n    /// Open brace `{` starting a specified repetition range (e.g. `.{1, 2}`)\n    OpenBrace,\n\n    /// Close brace `}` ending a specified repetition range (e.g. `.{1, 2}`)\n    CloseBrace,\n\n    /// A number inside a specified repetition range (e.g. `.{1, 2}`)\n    ///\n    /// # Items\n    ///\n    /// * `0` - value of the number\n    Number(usize),\n\n    /// Comma separating the start and end of a repetition range (e.g. `.{1, 2}`)\n    Comma,\n\n    /// Zero-or-one repetition `?`\n    Question,\n\n    /// Zero-or-more repetition `*`\n    Star,\n\n    /// One-or-more repetition `+`\n    Plus,\n\n    // Groups ==================================================\n    /// Beginning of a group `(`\n    OpenGroup,\n\n    /// End of a group `)`\n    CloseGroup,\n\n    /// Start of group options `?` in e.g. `(?\u003cname\u003e...)`\n    OpenGroupOptions,\n\n    /// End of group options `:` in e.g. `(?isx:...)`\n    CloseGroupOptions,\n\n    /// Start of group name `\u003c` or `P\u003c` in e.g. `(?P\u003cname\u003e...)`\n    OpenGroupName,\n\n    /// End of group name `\u003e` in e.g. `(?\u003cname\u003e...)`\n    CloseGroupName,\n\n    /// Flags in group options or a non-capturing flags group (e.g. `(?i-x)`)\n    Flag(Flag),\n\n    /// Delimiter character `-` between flags to be set and flags to be cleared (e.g. `(?i-x)`)\n    FlagDelimiter,\n\n    // Character classes ==================================================\n    /// Open bracket `[` beginning a specified character class or a posix class\n    /// (e.g. `[a-z]`, `[[:alpha:]]`])\n    OpenBracket,\n\n    /// Close bracket `]` ending a specified character class or a posix class\n    /// (e.g. `[a-z]`, `[[:alpha:]]`)\n    CloseBracket,\n\n    /// Surrounding token `:` for named posix classes (e.g. `[[:alpha:]]`)\n    Colon,\n\n    /// Negation marker `^` negating a specified character class or a posix class\n    /// (e.g. `[^a-z]`, `[[:^alpha:]]`)\n    Negated,\n\n    /// Character range operator `-` for specified classes (e.g. `[a-z]`)\n    Range,\n\n    /// Symmetrical difference set operator `~~` for specified classes (e.g. `[a-d~~c-f]`)\n    Symmetrical,\n\n    /// Difference set operator `--` for specified classes (e.g. `[a-z--h-l]`)\n    Difference,\n\n    /// Intersection set operator `\u0026\u0026` for specified classes (e.g. `[a-d\u0026\u0026c-f]`)\n    Intersection,\n\n    /// Short unicode character class `\\uL`--or negated as `\\UL`--to be matched (not\n    /// available in specified character classes).\n    ///\n    /// # Items\n    ///\n    /// * `0` - single-character unicode General Category specified (e.g. `L` for Letter)\n    /// * `1` - whether the class is negated\n    UnicodeShort(char, bool),\n\n    /// Beginning of a long unicode character class specifier `\\p{`--or negated as `\\P{`--to\n    /// be matched (not available in specified character classes). e.g. `\\p{sc=Greek}`\n    ///\n    /// # Items\n    ///\n    /// * `0` - whether the class is negated\n    UnicodeLong(bool),\n\n    /// Equal sign `=` in a unicode class specifier (e.g. `\\u{sc=Greek}`)\n    Equal,\n\n    /// Negation operator in a unicode class specifier (e.g. `\\u{sc!=Greek}`)\n    Bang,\n\n    // General ==================================================\n    /// Group and class names, and unicode property names and values\n    ///\n    /// # Items\n    ///\n    /// * `0` - name\n    Name(String),\n}\n\nimpl TokenKind {\n    #[inline]\n    pub fn is_literal(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Literal(_))\n    }\n\n    #[inline]\n    pub fn is_digit(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Digit(_))\n    }\n\n    #[inline]\n    pub fn is_whitespace(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Whitespace(_))\n    }\n\n    #[inline]\n    pub fn is_word_char(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::WordChar(_))\n    }\n\n    #[inline]\n    pub fn is_dot(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Dot)\n    }\n\n    #[inline]\n    pub fn is_alternate(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Alternate)\n    }\n\n    #[inline]\n    pub fn is_start_of_line(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::StartOfLine)\n    }\n\n    #[inline]\n    pub fn is_end_of_line(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::EndOfLine)\n    }\n\n    #[inline]\n    pub fn is_start_of_text(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::StartOfText)\n    }\n\n    #[inline]\n    pub fn is_end_of_text(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::EndOfText)\n    }\n\n    #[inline]\n    pub fn is_word_boundary(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::WordBoundary)\n    }\n\n    #[inline]\n    pub fn is_non_word_boundary(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::NonWordBoundary)\n    }\n\n    #[inline]\n    pub fn is_boundary(\u0026self) -\u003e bool {\n        match self {\n            TokenKind::StartOfLine\n            | TokenKind::EndOfLine\n            | TokenKind::StartOfText\n            | TokenKind::EndOfText\n            | TokenKind::WordBoundary\n            | TokenKind::NonWordBoundary =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    #[inline]\n    pub fn is_open_brace(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenBrace)\n    }\n\n    #[inline]\n    pub fn is_close_brace(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseBrace)\n    }\n\n    #[inline]\n    pub fn is_number(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Number(_))\n    }\n\n    #[inline]\n    pub fn is_comma(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Comma)\n    }\n\n    #[inline]\n    pub fn is_question(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Question)\n    }\n\n    #[inline]\n    pub fn is_star(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Star)\n    }\n\n    #[inline]\n    pub fn is_plus(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Plus)\n    }\n\n    #[inline]\n    pub fn is_open_group(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenGroup)\n    }\n\n    #[inline]\n    pub fn is_close_group(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseGroup)\n    }\n\n    #[inline]\n    pub fn is_open_group_options(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenGroupOptions)\n    }\n\n    #[inline]\n    pub fn is_close_group_options(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseGroupOptions)\n    }\n\n    #[inline]\n    pub fn is_open_group_name(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenGroupName)\n    }\n\n    #[inline]\n    pub fn is_close_group_name(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseGroupName)\n    }\n\n    #[inline]\n    pub fn is_flag(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Flag(_))\n    }\n\n    #[inline]\n    pub fn is_flag_delimiter(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::FlagDelimiter)\n    }\n\n    #[inline]\n    pub fn is_flag_or_delimiter(\u0026self) -\u003e bool {\n        self.is_flag() || self.is_flag_delimiter()\n    }\n\n    #[inline]\n    pub fn is_open_bracket(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::OpenBracket)\n    }\n\n    #[inline]\n    pub fn is_close_bracket(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::CloseBracket)\n    }\n\n    #[inline]\n    pub fn is_colon(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Colon)\n    }\n\n    #[inline]\n    pub fn is_negated(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Negated)\n    }\n\n    #[inline]\n    pub fn is_range(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Range)\n    }\n\n    #[inline]\n    pub fn is_symmetrical(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Symmetrical)\n    }\n\n    #[inline]\n    pub fn is_difference(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Difference)\n    }\n\n    #[inline]\n    pub fn is_intersection(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Intersection)\n    }\n\n    #[inline]\n    pub fn is_set_operator(\u0026self) -\u003e bool {\n        match self {\n            TokenKind::Symmetrical | TokenKind::Difference | TokenKind::Intersection =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    #[inline]\n    pub fn is_unicode_short(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::UnicodeShort(_, _))\n    }\n\n    #[inline]\n    pub fn is_unicode_long(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::UnicodeLong(_))\n    }\n\n    #[inline]\n    pub fn is_bang(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Bang)\n    }\n\n    #[inline]\n    pub fn is_equal(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Equal)\n    }\n\n    #[inline]\n    pub fn is_name(\u0026self) -\u003e bool {\n        matches!(self, TokenKind::Name(_))\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct TokenStack {\n    pub token: Token,\n    pub stack: StateStack,\n}\n\nmacro_rules! tok {\n    ( $kind:pat = $tok:ident) =\u003e {\n        let $kind = $tok.kind else {\n            panic!(\n                \"token `{}` does not match pattern `{}`\",\n                stringify!($tok.kind),\n                stringify!($kind)\n            );\n        };\n    };\n}\n\npub(crate) use tok;\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":89},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":85,"coverable":117},{"path":["/","home","carson","projects","aglet","aglet-regex","src","tokenize","tokenizer.rs"],"content":"use std::convert::TryInto;\n\nuse aglet_text::Cursor;\n\nuse crate::tokenize::error::*;\nuse crate::tokenize::state::*;\nuse crate::tokenize::token::*;\n#[cfg(test)]\nuse crate::tokenize::{assert_next_err, assert_next_none, assert_next_tok};\n\n/// Tokenizer for a regular expression\npub struct Tokenizer\u003c'a\u003e {\n    cursor:          Cursor\u003c'a\u003e,\n    state:           StateStack,\n    last_token_kind: Option\u003cTokenKind\u003e,\n    is_eof:          bool,\n}\n\nimpl\u003c'a\u003e Tokenizer\u003c'a\u003e {\n    /// Create a new regular expression tokenizer\n    ///\n    /// # Arguments\n    ///\n    /// * `input` - A string-like object that contains the entire regular\n    ///     expression to be tokenized\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use aglet_regex::tokenize;\n    /// let _ = tokenize::Tokenizer::new(\"[a-z-]{1, 4}\");\n    /// let _ = tokenize::Tokenizer::new(\"^hello, world$\");\n    /// ```\n    pub fn new\u003cC: Into\u003cCursor\u003c'a\u003e\u003e\u003e(cursor: C) -\u003e Self {\n        Tokenizer {\n            cursor:          cursor.into(),\n            state:           StateStack::new(),\n            last_token_kind: None,\n            is_eof:          false,\n        }\n    }\n\n    /// Get the next token from the input. A token includes both the kind of the\n    /// token along with the kind's associated data (e.g. a literal includes the\n    /// literal value) and the span over which the token was found in the input.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use aglet_regex::tokenize::*;\n    /// use aglet_regex::tokenize::token::Flag;\n    /// let mut tr = Tokenizer::new(\"(?x-i)\");\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::OpenGroup, 0, 1)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::OpenGroupOptions, 1, 2)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::Flag(Flag::IgnoreWhitespace), 2, 3)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::FlagDelimiter, 3, 4)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::Flag(Flag::CaseInsensitive), 4, 5)),\n    /// );\n    /// assert_eq!(\n    ///     tr.next_token(),\n    ///     Ok(Token::new_with_offsets(TokenKind::CloseGroup, 5, 6)),\n    /// );\n    /// ```\n    pub fn next_token(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // short-circuit the token matching code if the tokenizer has already been marked EOF\n        if self.is_eof {\n            return self.err(ErrorKind::EndOfFile);\n        }\n\n        let res = self.next_token_inner();\n\n        if let Err(err) = \u0026res {\n            if err.is_fatal() || err.is_any_eof() {\n                self.is_eof = true;\n            }\n        }\n\n        res\n    }\n\n    /// Get the next token from the input, along with the current state stack.\n    ///\n    /// When a state is added to the stack during an iteration, then the stack including the new\n    /// state will be returned. When a state is popped, then the stack will be returned as it was\n    /// before the iteration (i.e. will include the popped state). This is to group the terminating\n    /// token with the state it ends in the output.\n    ///\n    /// # Example\n    ///\n    /// For the regular expression:\n    ///\n    /// `[ab].+`\n    ///\n    /// The stacks returned with each token will be:\n    ///\n    /// * `[` [Main, Class]\n    /// * 'a' [Main, Class]\n    /// * 'b' [Main, Class]\n    /// * `]` [Main, Class]\n    /// * `.` [Main]\n    /// * `+` [Main]\n    ///\n    /// If this function always returned the state stack as it was _after_ each iteration, then\n    /// the result would be:\n    ///\n    /// * `[` [Main, Class]\n    /// * 'a' [Main, Class]\n    /// * 'b' [Main, Class]\n    /// * `]` [Main]\n    /// * `.` [Main]\n    /// * `+` [Main]\n    ///\n    /// disconnecting the closing bracket from the class state. This only really impacts the\n    /// colorization of pretty-printed token lists when, for example, a brace can be colorized as\n    /// part of a repetition or a unicode class. The open brace is always part of one state or the\n    /// other, but the close brace would never have that associated information.\n    pub fn next_token_stack(\u0026mut self) -\u003e StackResult\u003cTokenStack\u003e {\n        let (token, stack) = {\n            let stack_before = self.state.clone();\n            let token = self\n                .next_token()\n                .map_err(|e| StackError::from_error(e, stack_before.clone()))?;\n\n            if stack_before.stack.len() \u003e self.state.stack.len() {\n                (token, stack_before)\n            } else {\n                (token, self.state.clone())\n            }\n        };\n\n        Ok(TokenStack { token, stack })\n    }\n\n    /// Create an iterator over\n    pub fn into_token_stack_iter(self) -\u003e TokenStackIterator\u003c'a\u003e {\n        TokenStackIterator { tokenizer: self }\n    }\n\n    /// Get the next token from the input\n    fn next_token_inner(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let token = match self.state.get() {\n            Ok(State::Main) =\u003e self.next_token_main(),\n            Ok(State::GroupOptions) =\u003e self.next_token_group_options(),\n            Ok(State::Class) =\u003e self.next_token_class(),\n            Ok(State::ClassName) =\u003e self.next_token_class_name(),\n            Ok(State::Range) =\u003e self.next_token_range(),\n            Ok(State::UnicodeProperties) =\u003e self.next_token_unicode_properties(),\n            Err(err) =\u003e self.fatal_err(err.into()),\n        };\n\n        if let Ok(tok) = token.as_ref() {\n            self.last_token_kind = Some(tok.kind.clone());\n        }\n\n        token\n    }\n\n    /// Get a token in the `Main` state\n    ///\n    /// This state is used to tokenize the majority of a regular expression -\n    /// most literals, boundaries, repeaters, etc. are parsed here, being the\n    /// default parser for the input. Only groups, certain escapes, certain\n    /// repetitions, and character classes are parsed in a different state;\n    /// even then, groups fall back on the main state once their headers have\n    /// been parsed.\n    fn next_token_main(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // If the ignore_whitespace flag is set, try to skip any whitespace\n        // before reading the next token in the main state\n        let flags = self.flags()?;\n        if flags.ignore_space {\n            self.skip_whitespace();\n        }\n\n        match self.cursor.next() {\n            Some('^') =\u003e self.tok_kind(TokenKind::StartOfLine),\n            Some('$') =\u003e self.tok_kind(TokenKind::EndOfLine),\n            Some('.') =\u003e self.tok_kind(TokenKind::Dot),\n            Some('?') =\u003e self.tok_kind(TokenKind::Question),\n            Some('*') =\u003e self.tok_kind(TokenKind::Star),\n            Some('+') =\u003e self.tok_kind(TokenKind::Plus),\n            Some('|') =\u003e self.tok_kind(TokenKind::Alternate),\n\n            // The `(` token enters a group state - if it's just a capturing group\n            // (e.g. `(xyz)`) then just another `Main` state is used to parse the sub-expression.\n            // The group might have a header that starts with `?` (e.g. `(?P\u003cname\u003exyz)`), in which\n            // case enter the `Group` state to tokenize it before optionally returning to the\n            // `Main` state.\n            Some('(') if matches!(self.cursor.first(), Some('?')) =\u003e {\n                self.push_state(State::GroupOptions);\n                self.tok_kind(TokenKind::OpenGroup)\n            },\n            Some('(') =\u003e {\n                self.push_state(State::Main);\n                self.tok_kind(TokenKind::OpenGroup)\n            },\n\n            // The group state swaps to the main state as soon as its header\n            // has been parsed; so this state is responsible for matching the\n            // `)` token and popping the state\n            Some(')') =\u003e match self.state.pop() {\n                Ok(_) =\u003e self.tok_kind(TokenKind::CloseGroup),\n                Err(StateError::PoppedFinalState) =\u003e self.tok_kind(TokenKind::CloseGroup),\n                Err(err) =\u003e self.fatal_err(err.into()),\n            },\n\n            // The `[` token pushes the character class state, e.g. `[a-z]`\n            Some('[') =\u003e {\n                self.push_state(State::Class);\n                self.tok_kind(TokenKind::OpenBracket)\n            },\n\n            // The class state is responsible for matching these and popping the class state.\n            // If one is found here, it'll be a parse error, but the token can still be matched\n            Some(']') =\u003e self.tok_kind(TokenKind::CloseBracket),\n\n            // The `{` token pushes the range state, e.g. `{1,3}`\n            Some('{') =\u003e {\n                self.push_state(State::Range);\n                self.tok_kind(TokenKind::OpenBrace)\n            },\n\n            // The range state is responsible for matching these and popping the state.\n            // If one is found here, it'll be a parse error, but the token can still be matched\n            Some('}') =\u003e self.tok_kind(TokenKind::CloseBrace),\n\n            // escape sequences can be a single character after a backslash,\n            // or a more complicated unicode escape e.g. `\\x{01A1}`\n            Some('\\\\') =\u003e self.parse_escape_sequence_main(),\n\n            // All other input characters are literals\n            Some(c) =\u003e self.tok_kind(TokenKind::Literal(c)),\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `Group` state\n    ///\n    /// This state matches the header of a group, represented by a single\n    /// token. This could be a non-capturing marker, some flags, a group name,\n    /// etc.\n    ///\n    /// Before this function returns, the `Group` state will be swapped with\n    /// another `Main` state, in case there is an expression inside the group\n    /// that needs to be matched\n    fn next_token_group_options(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        if matches!(self.last_token_kind, Some(TokenKind::OpenGroupName)) {\n            let name = self.parse_id();\n            if !name.is_empty() {\n                return self.tok_kind(TokenKind::Name(name));\n            }\n        }\n\n        match self.cursor.next() {\n            Some('?') =\u003e self.tok_kind(TokenKind::OpenGroupOptions),\n            Some(':') =\u003e {\n                self.swap_state(State::Main)?;\n                self.tok_kind(TokenKind::CloseGroupOptions)\n            },\n            Some('P') if matches!(self.cursor.first(), Some('\u003c')) =\u003e {\n                self.cursor.skip(1);\n                self.tok_kind(TokenKind::OpenGroupName)\n            },\n            Some('\u003c') =\u003e self.tok_kind(TokenKind::OpenGroupName),\n            Some('\u003e') =\u003e {\n                self.swap_state(State::Main)?;\n                self.tok_kind(TokenKind::CloseGroupName)\n            },\n            Some('-') =\u003e {\n                {\n                    let flags = self.flags_mut()?;\n                    flags.unset_flags = true;\n                }\n\n                self.tok_kind(TokenKind::FlagDelimiter)\n            },\n            Some(')') =\u003e {\n                let is_flag_group = matches!(\n                    self.last_token_kind,\n                    Some(TokenKind::Flag(_) | TokenKind::FlagDelimiter)\n                );\n\n                if is_flag_group {\n                    let ignore_space = self.flags()?.ignore_space;\n                    self.pop_state()?;\n\n                    {\n                        let flags = self.flags_mut()?;\n                        flags.ignore_space = ignore_space;\n                    }\n                } else {\n                    self.pop_state()?;\n                }\n\n                self.tok_kind(TokenKind::CloseGroup)\n            },\n            Some(c) if Flag::is_flag_char(c) =\u003e {\n                let flag: Flag = c.try_into().unwrap();\n\n                {\n                    let flags = self.flags_mut()?;\n                    if flag.is_ignore_whitespace() {\n                        flags.ignore_space = !flags.unset_flags;\n                    }\n                }\n\n                self.tok_kind(TokenKind::Flag(flag))\n            },\n            Some(c) if c.is_alphabetic() =\u003e self.err(ErrorKind::UnrecognizedFlag(c)),\n            Some(c) =\u003e self.err(ErrorKind::UnexpectedChar(c)),\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `Class` state\n    ///\n    /// This state matches elaborated character classes between `[` and `]`\n    /// brackets, which can include ranges, differences, unions, etc.\n    fn next_token_class(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // If the ignore_whitespace flag is set, skip any whitespace and\n        // comments before matching the next class token\n        let flags = self.flags()?;\n        if flags.ignore_space {\n            self.skip_whitespace();\n        }\n\n        match self.cursor.next() {\n            // `-` at the end of the class (e.g. `-]`) is just a literal\n            Some('-') if matches!(self.cursor.first(), Some(']')) =\u003e {\n                self.tok_kind(TokenKind::Literal('-'))\n            },\n            // `--` is the difference token\n            Some('-') if matches!(self.cursor.first(), Some('-')) =\u003e {\n                self.cursor.skip(1);\n                self.tok_kind(TokenKind::Difference)\n            },\n            // `-` following a literal is a range token (e.g. `a-`)\n            Some('-') if matches!(self.last_token_kind, Some(TokenKind::Literal(_))) =\u003e {\n                self.tok_kind(TokenKind::Range)\n            },\n            // In any other case, `-` is just a literal\n            Some('-') =\u003e self.tok_kind(TokenKind::Literal('-')),\n            // `[:` begins a named class, e.g. `[:alpha:]`\n            Some('[') if matches!(self.cursor.first(), Some(':')) =\u003e {\n                self.push_state(State::ClassName);\n                self.tok_kind(TokenKind::OpenBracket)\n            },\n            // If not part of `[:`, `[` just begins a new sub-class\n            Some('[') =\u003e {\n                self.push_state(State::Class);\n                self.tok_kind(TokenKind::OpenBracket)\n            },\n            // `]` ends a class name or a character class and pops its own state\n            Some(']') =\u003e {\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBracket)\n            },\n            // `^` at the beginning of a character class is a negation\n            Some('^') if matches!(self.last_token_kind, Some(TokenKind::OpenBracket)) =\u003e {\n                self.tok_kind(TokenKind::Negated)\n            },\n            // `\u0026\u0026` is an intersection token\n            Some('\u0026') if matches!(self.cursor.first(), Some('\u0026')) =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Intersection)\n            },\n            // `~~` is a symmetrical difference token\n            Some('~') if matches!(self.cursor.first(), Some('~')) =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Symmetrical)\n            },\n            // Special characters can be escaped in classes\n            Some('\\\\') =\u003e self.parse_escape_sequence_class(),\n            // All other characters are just literals\n            Some(c) =\u003e self.tok_kind(TokenKind::Literal(c)),\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Read a named class within a character class\n    ///\n    /// A named class can be used in lieu of a more detailed character class\n    /// for clarity, e.g. `[[:alpha:]]` instead of `[a-zA-Z]`. These classes\n    /// are different from unicode classes (e.g. `\\p{alpha}`) and are only\n    /// stand-ins for relatively simple character classes:\n    ///\n    /// * `[[:alnum:]]` - `[0-9a-zA-Z]`\n    /// * `[[:alpha:]]` - `[a-zA-Z]`\n    /// * `[[:ascii:]]` - `[\\x00-\\x7F]`\n    /// * `[[:blank:]]` - `[\\t ]`\n    /// * `[[:cntrl:]]` - `[\\x00-\\x1F\\x7F]`\n    /// * `[[:digit:]]` - `[0-9]`\n    /// * `[[:graph:]]` - `[!-^]`\n    /// * `[[:lower:]]` - `[a-z]`\n    /// * `[[:print:]]` - `[ -~]`\n    /// * `[[:punct:]]` - `[!-/:-@\\[-\\`{-~]`\n    /// * `[[:space:]]` - `[\\t\\n\\v\\f\\r ]`\n    /// * `[[:upper:]]` - `[A-Z]`\n    /// * `[[:word:]]` - `[0-9a-zA-Z_]`\n    /// * `[[:xdigit:]]` - `[0-9a-fA-F]`\n    fn next_token_class_name(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        match self.cursor.first() {\n            Some(']') =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBracket)\n            },\n            Some(':') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Colon)\n            },\n            Some('^') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Negated)\n            },\n            Some(c) if unicode_ident::is_xid_start(c) =\u003e {\n                let name = self.parse_id();\n                self.tok_kind(TokenKind::Name(name))\n            },\n            // Misplaced id characters shouldn't pop the state; there's probably more\n            // valid posix class tokens to find\n            Some(c) if unicode_ident::is_xid_continue(c) =\u003e {\n                self.cursor.bump();\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            Some(c) =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `Range` state\n    ///\n    /// A range is a special kind of repetition operator specifying a minimum\n    /// and maximum number of characters to match - e.g. `.\\{3,5}`\n    fn next_token_range(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // Whitespace is always skipped in a range, because it cannot be\n        // significant to what is matched. Anything between braces, numbers,\n        // and commas is insignificant, but within numbers, whitespace is\n        // not tolerated\n        self.skip_whitespace();\n\n        match self.cursor.first() {\n            // The end of the range pops its own state\n            Some('}') =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBrace)\n            },\n            // A comma separates the start and end for the range\n            Some(',') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Comma)\n            },\n            Some(c) if c.is_numeric() =\u003e self.parse_number(),\n            Some(c) =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    /// Get a token in the `UnicodeProperties` state\n    ///\n    /// UnicodeProperties is a special character class that matches characters\n    /// based on their unicode class, language, etc.\n    ///\n    /// Properties can be specified with one character shorthand, e.g.:\n    ///\n    /// * \\pN - matches unicode numbers\n    /// * \\PN - matches anything except unicode numbers\n    ///\n    /// However, this state is only used once a brace is introduced to the\n    /// pattern. Braces can be used for more control, e.g.:\n    ///\n    /// * \\p{Lu} - matches an uppercase letter\n    /// * \\p{sc=Greek} - matches a letter in the Greek character set\n    fn next_token_unicode_properties(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        // Whitespace is always skipped here, because whitespace cannot\n        // be relevant to what is matched\n        self.skip_whitespace();\n\n        match self.cursor.first() {\n            Some('{') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::OpenBrace)\n            },\n            Some('=') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Equal)\n            },\n            Some('!') =\u003e {\n                self.cursor.bump();\n                self.tok_kind(TokenKind::Bang)\n            },\n            // `}` ends `UnicodeProperties` state and pops its own state\n            Some('}') =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.tok_kind(TokenKind::CloseBrace)\n            },\n            // Alphanumeric characters get added to `item` to be returned\n            // as either property name or value tokens\n            Some(c) if unicode_ident::is_xid_start(c) =\u003e {\n                let name = self.parse_id();\n                self.tok_kind(TokenKind::Name(name))\n            },\n            // Anything that looks like it was supposed to be part of an ID is an unexpected char,\n            // but the state won't be popped because there could be more class tokens to find\n            Some(c) if unicode_ident::is_xid_continue(c) =\u003e {\n                self.cursor.bump();\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            // Anything weirder that doesn't belong in a class specifier should create an error\n            // _and_ pop the state so that a different mode can look for valid tokens\n            Some(c) =\u003e {\n                self.cursor.bump();\n                self.pop_state()?;\n                self.err(ErrorKind::UnexpectedChar(c))\n            },\n            None =\u003e self.err(ErrorKind::EndOfFile),\n        }\n    }\n\n    #[inline]\n    fn push_state(\u0026mut self, state: State) {\n        self.state.push(state)\n    }\n\n    #[inline]\n    fn swap_state(\u0026mut self, state: State) -\u003e Result\u003cState\u003e {\n        self.state\n            .swap(state)\n            .map_err(|err| self.raw_err(err.into()))\n    }\n\n    #[inline]\n    fn pop_state(\u0026mut self) -\u003e Result\u003cState\u003e {\n        self.state.pop().map_err(|err| self.raw_err(err.into()))\n    }\n\n    #[inline]\n    fn pop_all_states(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.state.pop_all().map_err(|err| self.raw_err(err.into()))\n    }\n\n    /// Get an immutable copy of the state flags\n    #[inline]\n    fn flags(\u0026mut self) -\u003e Result\u003c\u0026Flags\u003e {\n        let span = self.cursor.span();\n        let res = self.state.flags();\n\n        match res {\n            Ok(flags) =\u003e Ok(flags),\n            Err(err) =\u003e Err(Error::new(span, err.into())),\n        }\n    }\n\n    /// Get a mutable copy of the state flags\n    #[inline]\n    fn flags_mut(\u0026mut self) -\u003e Result\u003c\u0026mut Flags\u003e {\n        let span = self.cursor.span();\n        let res = self.state.flags_mut();\n\n        match res {\n            Ok(flags) =\u003e Ok(flags),\n            Err(err) =\u003e Err(Error::new(span, err.into())),\n        }\n    }\n\n    /// Skip whitespace and comments in the input\n    ///\n    /// Any whitespace, or anything following a `#` character up to a newline\n    /// will be skipped. This is mostly used when the `ignore_whitespace` flag\n    /// is set for the main and class states; but it's also used in states where\n    /// whitespace is not significant in any case (e.g. in ranges).\n    ///\n    /// # Examples\n    ///\n    /// The input:\n    ///\n    /// `a b c\\nd e f #this is a comment\\ng h i`\n    ///\n    /// will be replaced with\n    ///\n    /// `abcdefghi`\n    fn skip_whitespace(\u0026mut self) {\n        // Keep track of whether a comment is being skipped; this will cause\n        // every character except a newline to be skipped, instead of only\n        // whitespace and `#` characters.\n        let mut skipping_comment = false;\n        loop {\n            match self.cursor.first() {\n                // Terminate comment skipping once a newline is seen\n                Some('\\n') if skipping_comment =\u003e skipping_comment = false,\n                // Skip all whitespace, or any character if in a comment\n                Some(c) if c.is_whitespace() || skipping_comment =\u003e (),\n                // Enter a comment when `#` is encountered\n                Some('#') =\u003e skipping_comment = true,\n                // In any other case, all whitespace has been skipped\n                _ =\u003e break,\n            }\n\n            self.cursor.skip(1);\n        }\n    }\n\n    /// Match an escape sequence in the `Main` state\n    ///\n    /// This matches some anchors, literals, boundaries, and character classes\n    /// which are represented as simple one-letter escape sequences. Unicode\n    /// classes are also parsed here, as well as hexadecimal numerical escapes.\n    fn parse_escape_sequence_main(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        match self.cursor.next() {\n            Some('A') =\u003e self.tok_kind(TokenKind::StartOfText),\n            Some('z') =\u003e self.tok_kind(TokenKind::EndOfText),\n            Some('b') =\u003e self.tok_kind(TokenKind::WordBoundary),\n            Some('B') =\u003e self.tok_kind(TokenKind::NonWordBoundary),\n            Some('a') =\u003e self.tok_kind(TokenKind::Literal('\\x07')),\n            Some('f') =\u003e self.tok_kind(TokenKind::Literal('\\x0C')),\n            Some('t') =\u003e self.tok_kind(TokenKind::Literal('\\t')),\n            Some('n') =\u003e self.tok_kind(TokenKind::Literal('\\n')),\n            Some('r') =\u003e self.tok_kind(TokenKind::Literal('\\r')),\n            Some('v') =\u003e self.tok_kind(TokenKind::Literal('\\x0B')),\n            Some('d') =\u003e self.tok_kind(TokenKind::Digit(false)),\n            Some('D') =\u003e self.tok_kind(TokenKind::Digit(true)),\n            Some('s') =\u003e self.tok_kind(TokenKind::Whitespace(false)),\n            Some('S') =\u003e self.tok_kind(TokenKind::Whitespace(true)),\n            Some('w') =\u003e self.tok_kind(TokenKind::WordChar(false)),\n            Some('W') =\u003e self.tok_kind(TokenKind::WordChar(true)),\n            // Parse a unicode class, whether a simple one-character escape\n            // sequence or a braced expression\n            Some('p') =\u003e self.parse_unicode(false),\n            // Parse a negated unicode class, whether a simple one-character\n            // escape sequence or a braced expression\n            Some('P') =\u003e self.parse_unicode(true),\n            // Parse a hex escape, which is a numerical representation of a\n            // single literal character (e.g. \\x7F)\n            Some(c) if Tokenizer::is_hex_escape(\u0026c) =\u003e self.parse_hex(c),\n            // Certain special characters can be escaped to a literal (e.g., \\})\n            Some(c) if Tokenizer::escapes_to_literal_main(\u0026c) =\u003e {\n                self.tok_kind(TokenKind::Literal(c))\n            },\n            // Everything else is an invalid escape sequence\n            Some(c) =\u003e self.err(ErrorKind::UnrecognizedEscape(c)),\n            // In lieu of an end of file error, we know that an errant \\ exists\n            // in the input, so use a more specific error\n            None =\u003e self.err(ErrorKind::UnexpectedChar('\\\\')),\n        }\n    }\n\n    /// Parse a hex escape sequence to create a literal\n    ///\n    /// Hex sequences without braces can match 2, 4, or 8 hexadecimal digits\n    /// as a literal:\n    ///\n    /// * \\x7F\n    /// * \\u007F\n    /// * \\U0000007F\n    ///\n    /// Any of these sequences can be surrounded by braces to match any number\n    /// of digits. Any number that doesn't represent a valid codepoint will be\n    /// rejected.\n    ///\n    /// * \\x{007F}\n    /// * \\u{0000007F}\n    /// * \\U{7F}\n    fn parse_hex(\u0026mut self, ident: char) -\u003e Result\u003cToken\u003e {\n        let mut number = String::new();\n        let bounded = self.cursor.matches('{');\n\n        let digits = match (bounded, ident) {\n            (true, _) =\u003e 8,\n            (_, 'x') =\u003e 2,\n            (_, 'u') =\u003e 4,\n            (_, 'U') =\u003e 8,\n            _ =\u003e panic!(\"accepted unknown hex escape specifier `{}`\", ident),\n        };\n\n        for _ in 0..digits {\n            match self.cursor.next() {\n                Some(c) if c.is_ascii_hexdigit() =\u003e number.push(c),\n                Some('}') if bounded =\u003e break,\n                Some(c) =\u003e return self.err(ErrorKind::InvalidHexDigit(c)),\n                None =\u003e {\n                    return self.err(ErrorKind::UnexpectedEOF(String::from(\n                        \"expected end of hex literal\",\n                    )))\n                },\n            };\n        }\n\n        let value = u32::from_str_radix(\u0026number, 16)\n            .unwrap_or_else(|_| panic!(\"accepted invalid hex string: {}\", number));\n        let c = char::from_u32(value)\n            .ok_or_else(|| self.raw_err(ErrorKind::InvalidCharCode(number).into()))?;\n\n        self.tok_kind(TokenKind::Literal(c))\n    }\n\n    /// Parse a unicode character class, either as a simple one-character\n    /// escape sequence or as a braced expression\n    ///\n    /// As a one-character escape, the class represents a single-character\n    /// general category (e.g., N for Numeric). The braced expression can\n    /// specify the same general category, as well as other properties:\n    ///\n    /// * `\\p{Alphabetic}` or `\\p{alpha}`: alphabetic class\n    /// * `\\p{Letter}` or `\\pL`: letter class\n    /// * `\\p{script!=Greek}` or `\\p{sc!=Greek}` or `\\P{sc=Greek}`:\n    ///     negated match of the Greek script\n    fn parse_unicode(\u0026mut self, negated: bool) -\u003e Result\u003cToken\u003e {\n        // Check for a braced expression and enter the `UnicodeProperties` state\n        if let Some('{') = self.cursor.first() {\n            self.push_state(State::UnicodeProperties);\n            return self.tok_kind(TokenKind::UnicodeLong(negated));\n        }\n\n        // Otherwise, it's a single-character class\n        match self.cursor.next() {\n            Some(c) if c.is_ascii_alphabetic() =\u003e {\n                self.tok_kind(TokenKind::UnicodeShort(c, negated))\n            },\n            Some(c) =\u003e self.err(ErrorKind::UnexpectedChar(c)),\n            None =\u003e self.err(ErrorKind::UnexpectedEOF(String::from(\n                \"expected single-character unicode general category\",\n            ))),\n        }\n    }\n\n    /// Read a valid identifier using the XID_START and XID_CONTINUE classes from the unicode\n    /// identifiers and syntax annex #31.\n    ///\n    /// Characters will be read from the stream so long as they belong to the XID_CONTINUE category,\n    /// except for the first character, which must belong to the XID_START category (a subgroup\n    /// of XID_CONTINUE). This allows, for example, numbers to appear in the identifier except in\n    /// the starting position.\n    fn parse_id(\u0026mut self) -\u003e String {\n        let mut id = String::new();\n        let mut first = true;\n        loop {\n            match self.cursor.first() {\n                Some(c) if first \u0026\u0026 unicode_ident::is_xid_start(c) =\u003e id.push(c),\n                Some(c) if !first \u0026\u0026 unicode_ident::is_xid_continue(c) =\u003e id.push(c),\n                _ =\u003e break,\n            }\n\n            self.cursor.bump();\n            first = false;\n        }\n\n        id\n    }\n\n    /// Parse an escape sequence in the `Class` state\n    ///\n    /// Escape sequences in the class state differ from the main state in that\n    /// the anchors and boundaries don't count, and the literal escapes are\n    /// different.\n    ///\n    /// The class escapes still match (e.g. \\s, \\w), and a subset of the same\n    /// literals (e.g. \\], \\^) as well as some escapes not valid in the `Main`\n    /// state (e.g. \\\u0026, \\-) can be escaped here.\n    fn parse_escape_sequence_class(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        match self.cursor.next() {\n            Some('s') =\u003e self.tok_kind(TokenKind::Whitespace(false)),\n            Some('S') =\u003e self.tok_kind(TokenKind::Whitespace(true)),\n            Some('d') =\u003e self.tok_kind(TokenKind::Digit(false)),\n            Some('D') =\u003e self.tok_kind(TokenKind::Digit(true)),\n            Some('w') =\u003e self.tok_kind(TokenKind::WordChar(false)),\n            Some('W') =\u003e self.tok_kind(TokenKind::WordChar(true)),\n            // Parse a hex escape, which is a numerical representation of a\n            // single literal character (e.g. \\x7F)\n            Some(c) if Tokenizer::is_hex_escape(\u0026c) =\u003e self.parse_hex(c),\n            Some(c) if Tokenizer::escapes_to_literal_class(\u0026c) =\u003e {\n                self.tok_kind(TokenKind::Literal(c))\n            },\n            Some(c) =\u003e self.err(ErrorKind::UnrecognizedEscape(c)),\n            None =\u003e self.err(ErrorKind::UnexpectedChar('\\\\')),\n        }\n    }\n\n    /// Parse a number in the `Range` state\n    ///\n    /// This is specifically for tokenizing numbers withing a character range,\n    /// e.g. `.{3,5}`\n    fn parse_number(\u0026mut self) -\u003e Result\u003cToken\u003e {\n        let mut number = String::new();\n        loop {\n            match self.cursor.first() {\n                // Any numeric character is added to the current number\n                Some(c) if c.is_numeric() =\u003e {\n                    self.cursor.bump();\n                    number.push(c);\n                },\n                // Otherwise just break\n                Some(_) =\u003e break,\n                None =\u003e {\n                    self.pop_all_states()?;\n                    break;\n                },\n            }\n        }\n\n        // This function is only for parsing the number, so a number should\n        // always be the output. Parse the input as an unsigned integer\n        let value = number\n            .parse::\u003cusize\u003e()\n            .unwrap_or_else(|_| panic!(\"accepted invalid number: {}\", number));\n\n        self.tok_kind(TokenKind::Number(value))\n    }\n\n    /// Check whether a character can be escaped in the `Main` state\n    fn escapes_to_literal_main(c: \u0026char) -\u003e bool {\n        matches!(\n            c,\n            '^' | '$' | '.' | '?' | '*' | '+' | '|' | '(' | ')' | '[' | ']' | '{' | '}' | '\\\\'\n        )\n    }\n\n    /// Check whether a character can be escaped in the `Class` state\n    fn escapes_to_literal_class(c: \u0026char) -\u003e bool {\n        matches!(c, '^' | '\u0026' | '~' | '-' | '[' | ']' | ':' | '\\\\')\n    }\n\n    /// Check whether a character is the beginning of a hex escape sequence\n    /// (e.g. in `\\x7F`, `\\u007F`, `\\x{12AB}`, etc.)\n    fn is_hex_escape(c: \u0026char) -\u003e bool {\n        matches!(c, 'x' | 'u' | 'U')\n    }\n\n    fn tok_kind(\u0026mut self, kind: TokenKind) -\u003e Result\u003cToken\u003e {\n        Ok(self.cursor.map_span(|span| Token { span, kind }))\n    }\n\n    #[inline]\n    fn err\u003cT\u003e(\u0026mut self, kind: ErrorKind) -\u003e Result\u003cT\u003e {\n        Err(self.raw_err(kind.into()))\n    }\n\n    fn fatal_err\u003cT\u003e(\u0026mut self, kind: FatalErrorKind) -\u003e Result\u003cT\u003e {\n        Err(self.raw_err(kind.into()))\n    }\n\n    #[inline]\n    fn raw_err(\u0026mut self, cause: ErrorCause) -\u003e Error {\n        self.cursor.map_span(|span| Error { span, cause })\n    }\n}\n\nimpl\u003c'a\u003e Iterator for Tokenizer\u003c'a\u003e {\n    type Item = Result\u003cToken\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let res = self.next_token();\n\n        if let Err(err) = \u0026res {\n            if err.is_eof() {\n                return None;\n            }\n        }\n\n        Some(res)\n    }\n}\n\npub struct TokenStackIterator\u003c'a\u003e {\n    tokenizer: Tokenizer\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e Iterator for TokenStackIterator\u003c'a\u003e {\n    type Item = StackResult\u003cTokenStack\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let res = self.tokenizer.next_token_stack();\n\n        if let Err(err) = \u0026res {\n            if err.is_eof() {\n                return None;\n            }\n        }\n\n        Some(res)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tokenize::assert_tokens;\n\n    #[test]\n    fn simple_main() {\n        // Check the basic tokens in the main state\n        let tr = Tokenizer::new(r\"a^$.?*+|()]}\");\n        assert_tokens(\n            tr,\n            vec![\n                TokenKind::Literal('a'),\n                TokenKind::StartOfLine,\n                TokenKind::EndOfLine,\n                TokenKind::Dot,\n                TokenKind::Question,\n                TokenKind::Star,\n                TokenKind::Plus,\n                TokenKind::Alternate,\n                TokenKind::OpenGroup,\n                TokenKind::CloseGroup,\n                TokenKind::CloseBracket,\n                TokenKind::CloseBrace,\n            ],\n        );\n    }\n\n    #[test]\n    fn extra_group_end() {\n        let tr = Tokenizer::new(r\"a))\");\n        let expected = vec![\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn expected_group_end() {\n        let mut tr = Tokenizer::new(r\"(\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n    }\n\n    #[test]\n    fn simple_escapes() {\n        let tr = Tokenizer::new(r\"\\A\\z\\b\\B\\a\\f\\t\\n\\r\\v\\d\\D\\s\\S\\w\\W\");\n        let expected = vec![\n            TokenKind::StartOfText,\n            TokenKind::EndOfText,\n            TokenKind::WordBoundary,\n            TokenKind::NonWordBoundary,\n            TokenKind::Literal('\\x07'),\n            TokenKind::Literal('\\x0C'),\n            TokenKind::Literal('\\t'),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('\\r'),\n            TokenKind::Literal('\\x0B'),\n            TokenKind::Digit(false),\n            TokenKind::Digit(true),\n            TokenKind::Whitespace(false),\n            TokenKind::Whitespace(true),\n            TokenKind::WordChar(false),\n            TokenKind::WordChar(true),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn literal_escapes() {\n        // Check all the literal escapes in the main state\n        let tr = Tokenizer::new(r\"\\^\\$\\.\\?\\*\\+\\|\\(\\)\\[\\]\\{\\}\\\\\");\n        let expected = vec![\n            TokenKind::Literal('^'),\n            TokenKind::Literal('$'),\n            TokenKind::Literal('.'),\n            TokenKind::Literal('?'),\n            TokenKind::Literal('*'),\n            TokenKind::Literal('+'),\n            TokenKind::Literal('|'),\n            TokenKind::Literal('('),\n            TokenKind::Literal(')'),\n            TokenKind::Literal('['),\n            TokenKind::Literal(']'),\n            TokenKind::Literal('{'),\n            TokenKind::Literal('}'),\n            TokenKind::Literal('\\\\'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn main_escape_errors() {\n        let mut tr = Tokenizer::new(r\"\\:\");\n        assert_next_err!(tr, ErrorKind::UnrecognizedEscape(':'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\\");\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('\\\\'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\p\");\n        assert_next_err!(tr, ErrorKind::UnexpectedEOF(_));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\u00\");\n        assert_next_err!(tr, ErrorKind::UnexpectedEOF(_));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"\\u00t\");\n        assert_next_err!(tr, ErrorKind::InvalidHexDigit('t'));\n        assert_next_none!(tr);\n\n        // 0xD83F is part of a surrogate pair, and is not a valid codepoint\n        let mut tr = Tokenizer::new(r\"\\uD83F\");\n        assert_next_err!(tr, ErrorKind::InvalidCharCode(_));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn class_escape_errors() {\n        let mut tr = Tokenizer::new(r\"[\\*\");\n        assert_next_tok!(tr, TokenKind::OpenBracket);\n        assert_next_err!(tr, ErrorKind::UnrecognizedEscape('*'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"[\\\");\n        assert_next_tok!(tr, TokenKind::OpenBracket);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('\\\\'));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn basic_group() {\n        // Check basic group functionality\n        let tr = Tokenizer::new(r\"(a)b\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('b'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn non_capturing_group() {\n        // Test a non-capturing group\n        let tr = Tokenizer::new(r\"(?:ab)\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn named_group() {\n        // Test a named group\n        let tr = Tokenizer::new(r\"(?P\u003cname\u003e\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::OpenGroupName,\n            TokenKind::Name(String::from(\"name\")),\n            TokenKind::CloseGroupName,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn group_errors() {\n        // This used to create an unexpected EOF error because the group name was all one token.\n        // now, the parser should handle this error as the group is not complete\n        let mut tr = Tokenizer::new(r\"(?P\u003cname\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_tok!(tr, TokenKind::Name(_));\n        assert_next_none!(tr);\n\n        // This will now create an error, as the tokenizer will keep trying to build the name\n        // until a non-identifier character is found\n        let mut tr = Tokenizer::new(r\"(?P\u003cname%\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_tok!(tr, TokenKind::Name(_));\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('%'));\n\n        // Different requirements for the first character in a name\n        let mut tr = Tokenizer::new(r\"(?P\u003c4name\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('4'));\n        assert_next_tok!(tr, TokenKind::Name(_));\n\n        let mut tr = Tokenizer::new(r\"(?P\u003cname4\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_tok!(tr, TokenKind::OpenGroupName);\n        assert_next_tok!(tr, TokenKind::Name(_));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"(?q\");\n        assert_next_tok!(tr, TokenKind::OpenGroup);\n        assert_next_tok!(tr, TokenKind::OpenGroupOptions);\n        assert_next_err!(tr, ErrorKind::UnrecognizedFlag('q'));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn flag_group() {\n        // Test a flags group\n        let tr = Tokenizer::new(r\"(?isUx)\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn non_capturing_flag_group() {\n        // Test a non-capturing flags group\n        let tr = Tokenizer::new(r\"(?mx:a)b\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::MultiLine),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('a'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('b'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn flag_parse() {\n        // Test the flags tokens in a variety of configurations\n        let tr = Tokenizer::new(r\"(?is-Ux)(?-iU:)(?sx-)\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::CaseInsensitive),\n            TokenKind::Flag(Flag::SwapGreed),\n            TokenKind::CloseGroupOptions,\n            TokenKind::CloseGroup,\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::DotMatchesNewline),\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::FlagDelimiter,\n            TokenKind::CloseGroup,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn linear_flag_settings() {\n        // Test that flag ignore_whitespace settings escape the group\n        let tr = Tokenizer::new(\" a\\nb(?x) a\\nb(?-x) a\\nb\");\n        let expected = vec![\n            TokenKind::Literal(' '),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('b'),\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal(' '),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('b'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn nested_flag_settings() {\n        // Test that ignore_whitespace can be limited to group scope\n        let tr = Tokenizer::new(\"(?x: \\nz(?-x: \\ny) \\nx) \\nw\");\n\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal('z'),\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::FlagDelimiter,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroupOptions,\n            TokenKind::Literal(' '),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('y'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('x'),\n            TokenKind::CloseGroup,\n            TokenKind::Literal(' '),\n            TokenKind::Literal('\\n'),\n            TokenKind::Literal('w'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn comment_skip() {\n        // Test that ignore_whitespace will skip comments\n        let tr = Tokenizer::new(\"(?x)#skip this comment\\na$\");\n        let expected = vec![\n            TokenKind::OpenGroup,\n            TokenKind::OpenGroupOptions,\n            TokenKind::Flag(Flag::IgnoreWhitespace),\n            TokenKind::CloseGroup,\n            TokenKind::Literal('a'),\n            TokenKind::EndOfLine,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn simple_class() {\n        // Test basic class tokens\n        let tr = Tokenizer::new(r\"[^-^a-z-]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Negated,\n            TokenKind::Literal('-'),\n            TokenKind::Literal('^'),\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::Literal('-'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn posix_class() {\n        let tr = Tokenizer::new(r\"[:a:][[:a:]a-z]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Name(String::from(\"a\")),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn class_names_and_differences() {\n        // Test named classes and some difference operators\n        let tr = Tokenizer::new(r\"[x[aA0~~[:^lower:]--[:alnum:]]\u0026\u0026a-z]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Literal('x'),\n            TokenKind::OpenBracket,\n            TokenKind::Literal('a'),\n            TokenKind::Literal('A'),\n            TokenKind::Literal('0'),\n            TokenKind::Symmetrical,\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Negated,\n            TokenKind::Name(String::from(\"lower\")),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::Difference,\n            TokenKind::OpenBracket,\n            TokenKind::Colon,\n            TokenKind::Name(String::from(\"alnum\")),\n            TokenKind::Colon,\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n            TokenKind::Intersection,\n            TokenKind::Literal('a'),\n            TokenKind::Range,\n            TokenKind::Literal('z'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn named_classes_and_bad_negations() {\n        // Test that named class negation works correctly\n        let tr = Tokenizer::new(r\"[[^:abc:]][:abc:]]]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Negated,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n            TokenKind::OpenBracket,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal('b'),\n            TokenKind::Literal('c'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn class_escapes() {\n        // Check that class escapes work correctly\n        let tr = Tokenizer::new(r\"[\\^\\\u0026\u0026~\\~\\]\\[[\\:a:]\\s\\W\\D\\--]\");\n        let expected = vec![\n            TokenKind::OpenBracket,\n            TokenKind::Literal('^'),\n            TokenKind::Literal('\u0026'),\n            TokenKind::Literal('\u0026'),\n            TokenKind::Literal('~'),\n            TokenKind::Literal('~'),\n            TokenKind::Literal(']'),\n            TokenKind::Literal('['),\n            TokenKind::OpenBracket,\n            TokenKind::Literal(':'),\n            TokenKind::Literal('a'),\n            TokenKind::Literal(':'),\n            TokenKind::CloseBracket,\n            TokenKind::Whitespace(false),\n            TokenKind::WordChar(true),\n            TokenKind::Digit(true),\n            TokenKind::Literal('-'),\n            TokenKind::Literal('-'),\n            TokenKind::CloseBracket,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn range() {\n        // Check that basic ranges work correctly with whitespace skipping\n        let tr = Tokenizer::new(r\"{ 1 , 234 }{,}\");\n        let expected = vec![\n            TokenKind::OpenBrace,\n            TokenKind::Number(1),\n            TokenKind::Comma,\n            TokenKind::Number(234),\n            TokenKind::CloseBrace,\n            TokenKind::OpenBrace,\n            TokenKind::Comma,\n            TokenKind::CloseBrace,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn range_errors() {\n        let mut tr = Tokenizer::new(r\"{:\");\n        assert_next_tok!(tr, TokenKind::OpenBrace);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar(':'));\n        assert_next_none!(tr);\n\n        let mut tr = Tokenizer::new(r\"{1a\");\n        assert_next_tok!(tr, TokenKind::OpenBrace);\n        assert_next_tok!(tr, TokenKind::Number(1));\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('a'));\n        assert_next_none!(tr);\n    }\n\n    #[test]\n    fn basic_unicode() {\n        // Check unbraced hex escapes\n        let tr = Tokenizer::new(r\"\\x7F1\\u4E2AE\\U0000007F0\");\n        let expected = vec![\n            TokenKind::Literal('\\x7F'),\n            TokenKind::Literal('1'),\n            TokenKind::Literal('\\u{4E2A}'),\n            TokenKind::Literal('E'),\n            TokenKind::Literal('\\x7F'),\n            TokenKind::Literal('0'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn braced_unicode_x() {\n        // Check that braced hex escapes work with \\x\n        let tr = Tokenizer::new(r\"\\x{1}\\x{12}\\x{123}\\x{1234}\\x{12345}\");\n        let expected = vec![\n            TokenKind::Literal('\\x01'),\n            TokenKind::Literal('\\x12'),\n            TokenKind::Literal('\\u{0123}'),\n            TokenKind::Literal('\\u{1234}'),\n            TokenKind::Literal('\\u{012345}'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn braced_unicode_u() {\n        // Check that braced hex escapes work with \\u\n        let tr = Tokenizer::new(r\"\\u{1}\\u{12}\\u{123}\\u{1234}\\u{12345}\");\n        let expected = vec![\n            TokenKind::Literal('\\x01'),\n            TokenKind::Literal('\\x12'),\n            TokenKind::Literal('\\u{0123}'),\n            TokenKind::Literal('\\u{1234}'),\n            TokenKind::Literal('\\u{012345}'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn braced_unicode_upper_u() {\n        // Check that braced hex escapes work with \\U\n        let tr = Tokenizer::new(r\"\\U{1}\\U{12}\\U{123}\\U{1234}\\U{12345}\");\n        let expected = vec![\n            TokenKind::Literal('\\x01'),\n            TokenKind::Literal('\\x12'),\n            TokenKind::Literal('\\u{0123}'),\n            TokenKind::Literal('\\u{1234}'),\n            TokenKind::Literal('\\u{012345}'),\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn unicode_properties() {\n        // Check that unicode property classes work\n        let tr = Tokenizer::new(r\"\\pL\\PN\\p{Mn}\\P{sc!=Greek}\");\n        let expected = vec![\n            TokenKind::UnicodeShort('L', false),\n            TokenKind::UnicodeShort('N', true),\n            TokenKind::UnicodeLong(false),\n            TokenKind::OpenBrace,\n            TokenKind::Name(String::from(\"Mn\")),\n            TokenKind::CloseBrace,\n            TokenKind::UnicodeLong(true),\n            TokenKind::OpenBrace,\n            TokenKind::Name(String::from(\"sc\")),\n            TokenKind::Bang,\n            TokenKind::Equal,\n            TokenKind::Name(String::from(\"Greek\")),\n            TokenKind::CloseBrace,\n        ];\n\n        assert_tokens(tr, expected);\n    }\n\n    #[test]\n    fn iter_basic() {\n        let tr = Tokenizer::new(r\"a(b[c-d]{1,2})$\");\n        let kinds = tr\n            .filter_map(|tok_result| tok_result.map(|tok| tok.kind).ok())\n            .collect::\u003cVec\u003cTokenKind\u003e\u003e();\n\n        assert_eq!(\n            kinds,\n            vec![\n                TokenKind::Literal('a'),\n                TokenKind::OpenGroup,\n                TokenKind::Literal('b'),\n                TokenKind::OpenBracket,\n                TokenKind::Literal('c'),\n                TokenKind::Range,\n                TokenKind::Literal('d'),\n                TokenKind::CloseBracket,\n                TokenKind::OpenBrace,\n                TokenKind::Number(1),\n                TokenKind::Comma,\n                TokenKind::Number(2),\n                TokenKind::CloseBrace,\n                TokenKind::CloseGroup,\n                TokenKind::EndOfLine,\n            ]\n        );\n    }\n\n    #[test]\n    fn iter_error() {\n        let mut tr = Tokenizer::new(r\"{\\\");\n        assert_next_tok!(tr, TokenKind::OpenBrace);\n        assert_next_err!(tr, ErrorKind::UnexpectedChar('\\\\'));\n        assert_next_none!(tr);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":720},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":309},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":360},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":364},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":261},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":89},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":137},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":309},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":927},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":415},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":323},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":276,"coverable":359},{"path":["/","home","carson","projects","aglet","aglet-test","src","main.rs"],"content":"use color_eyre::eyre::{Report, WrapErr};\nuse thiserror::Error;\n\nfn main() -\u003e Result\u003c(), Report\u003e {\n    color_eyre::install()?;\n\n    let stuff = do_thing()?;\n    println!(\"stuff: {}\", stuff);\n    Ok(())\n}\n\nfn do_thing() -\u003e Result\u003cString, Report\u003e {\n    other_thing()?;\n    let stuff = std::fs::read_to_string(\"fake_file\").wrap_err(\"Failed to open file\")?;\n\n    Ok(stuff.to_uppercase())\n}\n\nfn other_thing() -\u003e Result\u003cString, Report\u003e {\n    Err(CustomError::AnError(String::from(\"this is an error\")).into())\n}\n\n#[derive(Error, Debug)]\npub enum CustomError {\n    #[error(\"this is an error: {0}\")]\n    AnError(String),\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","carson","projects","aglet","aglet-text","src","cursor.rs"],"content":"use std::convert::From;\nuse std::mem;\nuse std::str::Chars;\n\nuse crate::Span;\n\npub struct Cursor\u003c'a\u003e {\n    src: Chars\u003c'a\u003e,\n    tok: Chars\u003c'a\u003e,\n    n:   usize,\n    t:   usize,\n}\n\nimpl\u003c'a\u003e Cursor\u003c'a\u003e {\n    pub fn new\u003cT: Into\u003c\u0026'a str\u003e\u003e(src: T) -\u003e Self {\n        let chars = src.into().chars();\n        Cursor {\n            src: chars.clone(),\n            tok: chars,\n            n:   0,\n            t:   0,\n        }\n    }\n\n    pub fn first(\u0026self) -\u003e Option\u003cchar\u003e {\n        self.src.clone().next()\n    }\n\n    pub fn second(\u0026self) -\u003e Option\u003cchar\u003e {\n        self.src.clone().skip(1).next()\n    }\n\n    pub fn next(\u0026mut self) -\u003e Option\u003cchar\u003e {\n        match self.src.next() {\n            Some(c) =\u003e {\n                self.n += 1;\n                Some(c)\n            },\n            _ =\u003e None,\n        }\n    }\n\n    pub fn skip(\u0026mut self, n: usize) {\n        for _ in 0..n {\n            self.bump();\n        }\n    }\n\n    pub fn bump(\u0026mut self) {\n        match self.src.next() {\n            Some(_) =\u003e self.n += 1,\n            _ =\u003e (),\n        }\n    }\n\n    pub fn span(\u0026self) -\u003e Span {\n        Span::new(self.t, self.n)\n    }\n\n    pub fn take_span(\u0026mut self) -\u003e Span {\n        let span = Span::new(self.t, self.n);\n        self.t = self.n;\n\n        span\n    }\n\n    pub fn text(\u0026self) -\u003e String {\n        self.tok.clone().take(self.n - self.t).collect::\u003cString\u003e()\n    }\n\n    pub fn take_text(\u0026mut self) -\u003e String {\n        let mut next_tok = self.src.clone();\n        mem::swap(\u0026mut next_tok, \u0026mut self.tok);\n        let text = next_tok.take(self.n - self.t).collect::\u003cString\u003e();\n        self.t = self.n;\n\n        text\n    }\n\n    pub fn map\u003cB, F\u003e(\u0026mut self, f: F) -\u003e B\n    where\n        F: FnOnce(Span, String) -\u003e B,\n    {\n        let span = self.span();\n        let text = self.take_text();\n\n        f(span, text)\n    }\n\n    pub fn map_span\u003cB, F\u003e(\u0026mut self, f: F) -\u003e B\n    where\n        F: FnOnce(Span) -\u003e B,\n    {\n        f(self.take_span())\n    }\n\n    pub fn matches(\u0026mut self, c: char) -\u003e bool {\n        match self.first() {\n            Some(found) if found == c =\u003e {\n                self.skip(1);\n                true\n            },\n            _ =\u003e false,\n        }\n    }\n\n    pub fn reset(\u0026mut self) {\n        self.tok = self.src.clone();\n        self.t = self.n;\n    }\n}\n\nimpl\u003c'a, T: Into\u003c\u0026'a str\u003e\u003e From\u003cT\u003e for Cursor\u003c'a\u003e {\n    fn from(value: T) -\u003e Self {\n        Cursor::new(value)\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":243},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":243},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":476},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":476},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":435},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":435},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":435},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":125},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":125},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":125},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":291},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":291},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":42},"fn_name":null}],"covered":33,"coverable":51},{"path":["/","home","carson","projects","aglet","aglet-text","src","error.rs"],"content":"#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"invalid input filename: {0}\")]\n    InvalidFilename(std::path::PathBuf),\n    #[error(\"io error: {0}\")]\n    IOError(#[from] std::io::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-text","src","lib.rs"],"content":"mod cursor;\nmod error;\nmod source_map;\nmod span;\n\nuse std::default::Default;\n\npub use cursor::Cursor;\npub use error::Error;\npub use source_map::{FileId, SourceFile, SourceMap};\npub use span::{FilePosition, FileSpan, Span};\n\npub trait DefaultWithSpan\nwhere\n    Self: Default,\n{\n    fn default_with_span(span: Span) -\u003e Self;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","carson","projects","aglet","aglet-text","src","source_map.rs"],"content":"use std::collections::HashMap;\nuse std::fs;\nuse std::path::Component::Normal;\nuse std::path::Path;\n\nuse crate::span::{FilePosition, FileSpan, Span};\nuse crate::Error;\n\npub type FileId = u32;\n\n#[derive(Debug, Clone)]\npub struct SourceFile {\n    pub prefix:   String,\n    pub filename: String,\n    pub src:      String,\n    pub lines:    Vec\u003cusize\u003e,\n}\n\nimpl SourceFile {\n    pub fn load_file(path: \u0026Path) -\u003e Result\u003cSelf, Error\u003e {\n        let prefix = String::from(\n            path.canonicalize()?\n                .parent()\n                .map(|p| p.to_path_buf())\n                .unwrap_or_default()\n                .to_str()\n                .ok_or_else(|| Error::InvalidFilename(path.to_path_buf()))?,\n        );\n\n        let filename = String::from(match path.components().last() {\n            Some(Normal(p)) =\u003e p\n                .to_str()\n                .ok_or_else(|| Error::InvalidFilename(path.to_path_buf())),\n            _ =\u003e Err(Error::InvalidFilename(path.to_path_buf())),\n        }?);\n\n        let src = fs::read_to_string(path)?;\n\n        Ok(SourceFile::new_from_source(prefix, filename, src))\n    }\n\n    pub fn new_from_source(prefix: String, filename: String, src: String) -\u003e Self {\n        let lines = SourceFile::map_lines(\u0026src);\n\n        Self {\n            prefix,\n            filename,\n            src,\n            lines,\n        }\n    }\n\n    pub fn file_position_from_offset(\u0026self, offset: \u0026usize) -\u003e Option\u003cFilePosition\u003e {\n        self.lines\n            .iter()\n            .enumerate()\n            .rev()\n            .find(|(_, start_offset)| start_offset \u003c= \u0026offset)\n            .map(|(line, start_offset)| FilePosition {\n                offset: *offset,\n                line:   line + 1,\n                column: offset - start_offset + 1,\n            })\n    }\n\n    fn map_lines(src: \u0026str) -\u003e Vec\u003cusize\u003e {\n        src.lines()\n            .scan(0, |state, line| {\n                let res = Some(*state);\n                *state = *state + line.len() + 1;\n                res\n            })\n            .collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct SourceMap {\n    next_id: FileId,\n    files:   HashMap\u003cFileId, SourceFile\u003e,\n}\n\nimpl SourceMap {\n    pub fn new() -\u003e Self {\n        Self {\n            next_id: 0,\n            files:   HashMap::new(),\n        }\n    }\n\n    pub fn add_file(\u0026mut self, file: SourceFile) -\u003e FileId {\n        let id = self.next_id;\n        self.next_id += 1;\n\n        self.files.insert(id, file);\n        id\n    }\n\n    pub fn get_span(\u0026self, file_id: \u0026FileId, span: \u0026Span) -\u003e Option\u003cFileSpan\u003e {\n        let source = self.files.get(file_id)?;\n        let start = source.file_position_from_offset(\u0026span.start)?;\n        let end = source.file_position_from_offset(\u0026span.end)?;\n\n        Some(FileSpan {\n            file_id: *file_id,\n            start,\n            end,\n        })\n    }\n\n    pub fn get_file(\u0026self, file_id: \u0026FileId) -\u003e Option\u003c\u0026SourceFile\u003e {\n        self.files.get(file_id)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_file_init() {\n        let input = vec![\"abcd\", \"\", \"efgh\"].join(\"\\n\");\n        let file = SourceFile::new_from_source(\n            \"\u003ctest\u003e\".to_string(),\n            \"test_file\".to_string(),\n            input.clone(),\n        );\n\n        assert_eq!(file.prefix, \"\u003ctest\u003e\".to_string());\n        assert_eq!(file.filename, \"test_file\".to_string());\n        assert_eq!(file.src, input);\n        assert_eq!(file.lines, vec![0, 5, 6]);\n    }\n\n    #[test]\n    fn test_file_positions() {\n        let input = vec![\n            \"01234\", // 0-5\n            \"67\",    // 6-8\n            \"\",      // 9\n            \"012\",   // 10-12\n        ]\n        .join(\"\\n\");\n        let file = SourceFile::new_from_source(\"\".to_string(), \"\u003ctest\u003e\".to_string(), input);\n\n        let pos = file.file_position_from_offset(\u00263).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 3);\n        assert_eq!(pos.line, 1);\n        assert_eq!(pos.column, 4);\n\n        let pos = file.file_position_from_offset(\u00265).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 5);\n        assert_eq!(pos.line, 1);\n        assert_eq!(pos.column, 6);\n\n        let pos = file.file_position_from_offset(\u00267).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 7);\n        assert_eq!(pos.line, 2);\n        assert_eq!(pos.column, 2);\n\n        let pos = file.file_position_from_offset(\u002611).expect(\"pos in bounds\");\n        assert_eq!(pos.offset, 11);\n        assert_eq!(pos.line, 4);\n        assert_eq!(pos.column, 2);\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":15,"coverable":44},{"path":["/","home","carson","projects","aglet","aglet-text","src","span.rs"],"content":"use std::default::Default;\nuse std::fmt;\n\nuse crate::source_map::FileId;\n\n#[derive(Copy, Clone, PartialEq, Eq)]\npub struct Span {\n    pub start: usize,\n    pub end:   usize,\n}\n\nimpl Span {\n    pub fn new(start: usize, end: usize) -\u003e Self {\n        Self { start, end }\n    }\n\n    pub fn wrap(start: \u0026Span, end: \u0026Span) -\u003e Self {\n        Span {\n            start: start.start,\n            end:   end.end,\n        }\n    }\n}\n\nimpl fmt::Debug for Span {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}-{}\", self.start, self.end)\n    }\n}\n\nimpl fmt::Display for Span {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}-{}\", self.start, self.end)\n    }\n}\n\nimpl Default for Span {\n    fn default() -\u003e Self {\n        Self { start: 0, end: 0 }\n    }\n}\n\npub struct FileSpan {\n    pub file_id: FileId,\n    pub start:   FilePosition,\n    pub end:     FilePosition,\n}\n\nimpl fmt::Debug for FileSpan {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(\n            f,\n            \"\u003cfile_id {}\u003e {:?}-{:?}\",\n            self.file_id, self.start, self.end\n        )\n    }\n}\n\nimpl fmt::Display for FileSpan {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}-{}\", self.start, self.end)\n    }\n}\n\npub struct FilePosition {\n    pub offset: usize,\n    pub line:   usize,\n    pub column: usize,\n}\n\nimpl fmt::Debug for FilePosition {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}:{}[{}]\", self.line, self.column, self.offset)\n    }\n}\n\nimpl fmt::Display for FilePosition {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}:{}\", self.line, self.column)\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":962},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":19}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>